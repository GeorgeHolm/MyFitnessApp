
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model Workout
 * 
 */
export type Workout = $Result.DefaultSelection<Prisma.$WorkoutPayload>
/**
 * Model Exercise
 * 
 */
export type Exercise = $Result.DefaultSelection<Prisma.$ExercisePayload>
/**
 * Model Set
 * 
 */
export type Set = $Result.DefaultSelection<Prisma.$SetPayload>
/**
 * Model Meal
 * 
 */
export type Meal = $Result.DefaultSelection<Prisma.$MealPayload>
/**
 * Model Food
 * 
 */
export type Food = $Result.DefaultSelection<Prisma.$FoodPayload>
/**
 * Model ProfileWorkoutLikes
 * 
 */
export type ProfileWorkoutLikes = $Result.DefaultSelection<Prisma.$ProfileWorkoutLikesPayload>
/**
 * Model ProfileWorkoutTouched
 * 
 */
export type ProfileWorkoutTouched = $Result.DefaultSelection<Prisma.$ProfileWorkoutTouchedPayload>
/**
 * Model ProfileMealLikes
 * 
 */
export type ProfileMealLikes = $Result.DefaultSelection<Prisma.$ProfileMealLikesPayload>
/**
 * Model ProfileMealTouched
 * 
 */
export type ProfileMealTouched = $Result.DefaultSelection<Prisma.$ProfileMealTouchedPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Profiles
 * const profiles = await prisma.profile.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Profiles
   * const profiles = await prisma.profile.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs>;

  /**
   * `prisma.workout`: Exposes CRUD operations for the **Workout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workouts
    * const workouts = await prisma.workout.findMany()
    * ```
    */
  get workout(): Prisma.WorkoutDelegate<ExtArgs>;

  /**
   * `prisma.exercise`: Exposes CRUD operations for the **Exercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exercises
    * const exercises = await prisma.exercise.findMany()
    * ```
    */
  get exercise(): Prisma.ExerciseDelegate<ExtArgs>;

  /**
   * `prisma.set`: Exposes CRUD operations for the **Set** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sets
    * const sets = await prisma.set.findMany()
    * ```
    */
  get set(): Prisma.SetDelegate<ExtArgs>;

  /**
   * `prisma.meal`: Exposes CRUD operations for the **Meal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meals
    * const meals = await prisma.meal.findMany()
    * ```
    */
  get meal(): Prisma.MealDelegate<ExtArgs>;

  /**
   * `prisma.food`: Exposes CRUD operations for the **Food** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Foods
    * const foods = await prisma.food.findMany()
    * ```
    */
  get food(): Prisma.FoodDelegate<ExtArgs>;

  /**
   * `prisma.profileWorkoutLikes`: Exposes CRUD operations for the **ProfileWorkoutLikes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileWorkoutLikes
    * const profileWorkoutLikes = await prisma.profileWorkoutLikes.findMany()
    * ```
    */
  get profileWorkoutLikes(): Prisma.ProfileWorkoutLikesDelegate<ExtArgs>;

  /**
   * `prisma.profileWorkoutTouched`: Exposes CRUD operations for the **ProfileWorkoutTouched** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileWorkoutToucheds
    * const profileWorkoutToucheds = await prisma.profileWorkoutTouched.findMany()
    * ```
    */
  get profileWorkoutTouched(): Prisma.ProfileWorkoutTouchedDelegate<ExtArgs>;

  /**
   * `prisma.profileMealLikes`: Exposes CRUD operations for the **ProfileMealLikes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileMealLikes
    * const profileMealLikes = await prisma.profileMealLikes.findMany()
    * ```
    */
  get profileMealLikes(): Prisma.ProfileMealLikesDelegate<ExtArgs>;

  /**
   * `prisma.profileMealTouched`: Exposes CRUD operations for the **ProfileMealTouched** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileMealToucheds
    * const profileMealToucheds = await prisma.profileMealTouched.findMany()
    * ```
    */
  get profileMealTouched(): Prisma.ProfileMealTouchedDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.17.0
   * Query Engine version: 34ace0eb2704183d2c05b60b52fba5c43c13f303
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Profile: 'Profile',
    Workout: 'Workout',
    Exercise: 'Exercise',
    Set: 'Set',
    Meal: 'Meal',
    Food: 'Food',
    ProfileWorkoutLikes: 'ProfileWorkoutLikes',
    ProfileWorkoutTouched: 'ProfileWorkoutTouched',
    ProfileMealLikes: 'ProfileMealLikes',
    ProfileMealTouched: 'ProfileMealTouched'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "profile" | "workout" | "exercise" | "set" | "meal" | "food" | "profileWorkoutLikes" | "profileWorkoutTouched" | "profileMealLikes" | "profileMealTouched"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      Workout: {
        payload: Prisma.$WorkoutPayload<ExtArgs>
        fields: Prisma.WorkoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkoutFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkoutFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>
          }
          findFirst: {
            args: Prisma.WorkoutFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkoutFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>
          }
          findMany: {
            args: Prisma.WorkoutFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>[]
          }
          create: {
            args: Prisma.WorkoutCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>
          }
          createMany: {
            args: Prisma.WorkoutCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkoutCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>[]
          }
          delete: {
            args: Prisma.WorkoutDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>
          }
          update: {
            args: Prisma.WorkoutUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>
          }
          deleteMany: {
            args: Prisma.WorkoutDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkoutUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkoutUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkoutPayload>
          }
          aggregate: {
            args: Prisma.WorkoutAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkout>
          }
          groupBy: {
            args: Prisma.WorkoutGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkoutGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkoutCountArgs<ExtArgs>
            result: $Utils.Optional<WorkoutCountAggregateOutputType> | number
          }
        }
      }
      Exercise: {
        payload: Prisma.$ExercisePayload<ExtArgs>
        fields: Prisma.ExerciseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExerciseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExerciseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          findFirst: {
            args: Prisma.ExerciseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExerciseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          findMany: {
            args: Prisma.ExerciseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          create: {
            args: Prisma.ExerciseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          createMany: {
            args: Prisma.ExerciseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExerciseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>[]
          }
          delete: {
            args: Prisma.ExerciseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          update: {
            args: Prisma.ExerciseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          deleteMany: {
            args: Prisma.ExerciseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExerciseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExerciseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExercisePayload>
          }
          aggregate: {
            args: Prisma.ExerciseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExercise>
          }
          groupBy: {
            args: Prisma.ExerciseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExerciseCountArgs<ExtArgs>
            result: $Utils.Optional<ExerciseCountAggregateOutputType> | number
          }
        }
      }
      Set: {
        payload: Prisma.$SetPayload<ExtArgs>
        fields: Prisma.SetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SetPayload>
          }
          findFirst: {
            args: Prisma.SetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SetPayload>
          }
          findMany: {
            args: Prisma.SetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SetPayload>[]
          }
          create: {
            args: Prisma.SetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SetPayload>
          }
          createMany: {
            args: Prisma.SetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SetPayload>[]
          }
          delete: {
            args: Prisma.SetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SetPayload>
          }
          update: {
            args: Prisma.SetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SetPayload>
          }
          deleteMany: {
            args: Prisma.SetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SetPayload>
          }
          aggregate: {
            args: Prisma.SetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSet>
          }
          groupBy: {
            args: Prisma.SetGroupByArgs<ExtArgs>
            result: $Utils.Optional<SetGroupByOutputType>[]
          }
          count: {
            args: Prisma.SetCountArgs<ExtArgs>
            result: $Utils.Optional<SetCountAggregateOutputType> | number
          }
        }
      }
      Meal: {
        payload: Prisma.$MealPayload<ExtArgs>
        fields: Prisma.MealFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MealFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MealFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>
          }
          findFirst: {
            args: Prisma.MealFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MealFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>
          }
          findMany: {
            args: Prisma.MealFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>[]
          }
          create: {
            args: Prisma.MealCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>
          }
          createMany: {
            args: Prisma.MealCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MealCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>[]
          }
          delete: {
            args: Prisma.MealDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>
          }
          update: {
            args: Prisma.MealUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>
          }
          deleteMany: {
            args: Prisma.MealDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MealUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MealUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MealPayload>
          }
          aggregate: {
            args: Prisma.MealAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeal>
          }
          groupBy: {
            args: Prisma.MealGroupByArgs<ExtArgs>
            result: $Utils.Optional<MealGroupByOutputType>[]
          }
          count: {
            args: Prisma.MealCountArgs<ExtArgs>
            result: $Utils.Optional<MealCountAggregateOutputType> | number
          }
        }
      }
      Food: {
        payload: Prisma.$FoodPayload<ExtArgs>
        fields: Prisma.FoodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          findFirst: {
            args: Prisma.FoodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          findMany: {
            args: Prisma.FoodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>[]
          }
          create: {
            args: Prisma.FoodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          createMany: {
            args: Prisma.FoodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>[]
          }
          delete: {
            args: Prisma.FoodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          update: {
            args: Prisma.FoodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          deleteMany: {
            args: Prisma.FoodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FoodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodPayload>
          }
          aggregate: {
            args: Prisma.FoodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFood>
          }
          groupBy: {
            args: Prisma.FoodGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodCountArgs<ExtArgs>
            result: $Utils.Optional<FoodCountAggregateOutputType> | number
          }
        }
      }
      ProfileWorkoutLikes: {
        payload: Prisma.$ProfileWorkoutLikesPayload<ExtArgs>
        fields: Prisma.ProfileWorkoutLikesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileWorkoutLikesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileWorkoutLikesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileWorkoutLikesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileWorkoutLikesPayload>
          }
          findFirst: {
            args: Prisma.ProfileWorkoutLikesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileWorkoutLikesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileWorkoutLikesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileWorkoutLikesPayload>
          }
          findMany: {
            args: Prisma.ProfileWorkoutLikesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileWorkoutLikesPayload>[]
          }
          create: {
            args: Prisma.ProfileWorkoutLikesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileWorkoutLikesPayload>
          }
          createMany: {
            args: Prisma.ProfileWorkoutLikesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileWorkoutLikesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileWorkoutLikesPayload>[]
          }
          delete: {
            args: Prisma.ProfileWorkoutLikesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileWorkoutLikesPayload>
          }
          update: {
            args: Prisma.ProfileWorkoutLikesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileWorkoutLikesPayload>
          }
          deleteMany: {
            args: Prisma.ProfileWorkoutLikesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileWorkoutLikesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileWorkoutLikesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileWorkoutLikesPayload>
          }
          aggregate: {
            args: Prisma.ProfileWorkoutLikesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileWorkoutLikes>
          }
          groupBy: {
            args: Prisma.ProfileWorkoutLikesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileWorkoutLikesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileWorkoutLikesCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileWorkoutLikesCountAggregateOutputType> | number
          }
        }
      }
      ProfileWorkoutTouched: {
        payload: Prisma.$ProfileWorkoutTouchedPayload<ExtArgs>
        fields: Prisma.ProfileWorkoutTouchedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileWorkoutTouchedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileWorkoutTouchedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileWorkoutTouchedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileWorkoutTouchedPayload>
          }
          findFirst: {
            args: Prisma.ProfileWorkoutTouchedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileWorkoutTouchedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileWorkoutTouchedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileWorkoutTouchedPayload>
          }
          findMany: {
            args: Prisma.ProfileWorkoutTouchedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileWorkoutTouchedPayload>[]
          }
          create: {
            args: Prisma.ProfileWorkoutTouchedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileWorkoutTouchedPayload>
          }
          createMany: {
            args: Prisma.ProfileWorkoutTouchedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileWorkoutTouchedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileWorkoutTouchedPayload>[]
          }
          delete: {
            args: Prisma.ProfileWorkoutTouchedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileWorkoutTouchedPayload>
          }
          update: {
            args: Prisma.ProfileWorkoutTouchedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileWorkoutTouchedPayload>
          }
          deleteMany: {
            args: Prisma.ProfileWorkoutTouchedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileWorkoutTouchedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileWorkoutTouchedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileWorkoutTouchedPayload>
          }
          aggregate: {
            args: Prisma.ProfileWorkoutTouchedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileWorkoutTouched>
          }
          groupBy: {
            args: Prisma.ProfileWorkoutTouchedGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileWorkoutTouchedGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileWorkoutTouchedCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileWorkoutTouchedCountAggregateOutputType> | number
          }
        }
      }
      ProfileMealLikes: {
        payload: Prisma.$ProfileMealLikesPayload<ExtArgs>
        fields: Prisma.ProfileMealLikesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileMealLikesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileMealLikesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileMealLikesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileMealLikesPayload>
          }
          findFirst: {
            args: Prisma.ProfileMealLikesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileMealLikesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileMealLikesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileMealLikesPayload>
          }
          findMany: {
            args: Prisma.ProfileMealLikesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileMealLikesPayload>[]
          }
          create: {
            args: Prisma.ProfileMealLikesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileMealLikesPayload>
          }
          createMany: {
            args: Prisma.ProfileMealLikesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileMealLikesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileMealLikesPayload>[]
          }
          delete: {
            args: Prisma.ProfileMealLikesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileMealLikesPayload>
          }
          update: {
            args: Prisma.ProfileMealLikesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileMealLikesPayload>
          }
          deleteMany: {
            args: Prisma.ProfileMealLikesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileMealLikesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileMealLikesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileMealLikesPayload>
          }
          aggregate: {
            args: Prisma.ProfileMealLikesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileMealLikes>
          }
          groupBy: {
            args: Prisma.ProfileMealLikesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileMealLikesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileMealLikesCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileMealLikesCountAggregateOutputType> | number
          }
        }
      }
      ProfileMealTouched: {
        payload: Prisma.$ProfileMealTouchedPayload<ExtArgs>
        fields: Prisma.ProfileMealTouchedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileMealTouchedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileMealTouchedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileMealTouchedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileMealTouchedPayload>
          }
          findFirst: {
            args: Prisma.ProfileMealTouchedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileMealTouchedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileMealTouchedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileMealTouchedPayload>
          }
          findMany: {
            args: Prisma.ProfileMealTouchedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileMealTouchedPayload>[]
          }
          create: {
            args: Prisma.ProfileMealTouchedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileMealTouchedPayload>
          }
          createMany: {
            args: Prisma.ProfileMealTouchedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileMealTouchedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileMealTouchedPayload>[]
          }
          delete: {
            args: Prisma.ProfileMealTouchedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileMealTouchedPayload>
          }
          update: {
            args: Prisma.ProfileMealTouchedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileMealTouchedPayload>
          }
          deleteMany: {
            args: Prisma.ProfileMealTouchedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileMealTouchedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileMealTouchedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileMealTouchedPayload>
          }
          aggregate: {
            args: Prisma.ProfileMealTouchedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileMealTouched>
          }
          groupBy: {
            args: Prisma.ProfileMealTouchedGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileMealTouchedGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileMealTouchedCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileMealTouchedCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProfileCountOutputType
   */

  export type ProfileCountOutputType = {
    workouts: number
    meals: number
    likedWorkouts: number
    touchWorkouts: number
    likedMeals: number
    touchMeals: number
  }

  export type ProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workouts?: boolean | ProfileCountOutputTypeCountWorkoutsArgs
    meals?: boolean | ProfileCountOutputTypeCountMealsArgs
    likedWorkouts?: boolean | ProfileCountOutputTypeCountLikedWorkoutsArgs
    touchWorkouts?: boolean | ProfileCountOutputTypeCountTouchWorkoutsArgs
    likedMeals?: boolean | ProfileCountOutputTypeCountLikedMealsArgs
    touchMeals?: boolean | ProfileCountOutputTypeCountTouchMealsArgs
  }

  // Custom InputTypes
  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileCountOutputType
     */
    select?: ProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountWorkoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountMealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MealWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountLikedWorkoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWorkoutLikesWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountTouchWorkoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWorkoutTouchedWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountLikedMealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileMealLikesWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountTouchMealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileMealTouchedWhereInput
  }


  /**
   * Count Type WorkoutCountOutputType
   */

  export type WorkoutCountOutputType = {
    exercises: number
    profileLikes: number
    profileTouch: number
  }

  export type WorkoutCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercises?: boolean | WorkoutCountOutputTypeCountExercisesArgs
    profileLikes?: boolean | WorkoutCountOutputTypeCountProfileLikesArgs
    profileTouch?: boolean | WorkoutCountOutputTypeCountProfileTouchArgs
  }

  // Custom InputTypes
  /**
   * WorkoutCountOutputType without action
   */
  export type WorkoutCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkoutCountOutputType
     */
    select?: WorkoutCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkoutCountOutputType without action
   */
  export type WorkoutCountOutputTypeCountExercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
  }

  /**
   * WorkoutCountOutputType without action
   */
  export type WorkoutCountOutputTypeCountProfileLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWorkoutLikesWhereInput
  }

  /**
   * WorkoutCountOutputType without action
   */
  export type WorkoutCountOutputTypeCountProfileTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWorkoutTouchedWhereInput
  }


  /**
   * Count Type ExerciseCountOutputType
   */

  export type ExerciseCountOutputType = {
    sets: number
  }

  export type ExerciseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sets?: boolean | ExerciseCountOutputTypeCountSetsArgs
  }

  // Custom InputTypes
  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExerciseCountOutputType
     */
    select?: ExerciseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeCountSetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SetWhereInput
  }


  /**
   * Count Type MealCountOutputType
   */

  export type MealCountOutputType = {
    foods: number
    profileLikes: number
    profileTouch: number
  }

  export type MealCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    foods?: boolean | MealCountOutputTypeCountFoodsArgs
    profileLikes?: boolean | MealCountOutputTypeCountProfileLikesArgs
    profileTouch?: boolean | MealCountOutputTypeCountProfileTouchArgs
  }

  // Custom InputTypes
  /**
   * MealCountOutputType without action
   */
  export type MealCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MealCountOutputType
     */
    select?: MealCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MealCountOutputType without action
   */
  export type MealCountOutputTypeCountFoodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodWhereInput
  }

  /**
   * MealCountOutputType without action
   */
  export type MealCountOutputTypeCountProfileLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileMealLikesWhereInput
  }

  /**
   * MealCountOutputType without action
   */
  export type MealCountOutputTypeCountProfileTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileMealTouchedWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    id: number | null
    age: number | null
  }

  export type ProfileSumAggregateOutputType = {
    id: number | null
    age: number | null
  }

  export type ProfileMinAggregateOutputType = {
    id: number | null
    uid: string | null
    email: string | null
    name: string | null
    sex: string | null
    age: number | null
    bio: string | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: number | null
    uid: string | null
    email: string | null
    name: string | null
    sex: string | null
    age: number | null
    bio: string | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    uid: number
    email: number
    name: number
    sex: number
    age: number
    bio: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    id?: true
    age?: true
  }

  export type ProfileSumAggregateInputType = {
    id?: true
    age?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    uid?: true
    email?: true
    name?: true
    sex?: true
    age?: true
    bio?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    uid?: true
    email?: true
    name?: true
    sex?: true
    age?: true
    bio?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    uid?: true
    email?: true
    name?: true
    sex?: true
    age?: true
    bio?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: number
    uid: string
    email: string
    name: string
    sex: string
    age: number
    bio: string
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uid?: boolean
    email?: boolean
    name?: boolean
    sex?: boolean
    age?: boolean
    bio?: boolean
    workouts?: boolean | Profile$workoutsArgs<ExtArgs>
    meals?: boolean | Profile$mealsArgs<ExtArgs>
    likedWorkouts?: boolean | Profile$likedWorkoutsArgs<ExtArgs>
    touchWorkouts?: boolean | Profile$touchWorkoutsArgs<ExtArgs>
    likedMeals?: boolean | Profile$likedMealsArgs<ExtArgs>
    touchMeals?: boolean | Profile$touchMealsArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uid?: boolean
    email?: boolean
    name?: boolean
    sex?: boolean
    age?: boolean
    bio?: boolean
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    uid?: boolean
    email?: boolean
    name?: boolean
    sex?: boolean
    age?: boolean
    bio?: boolean
  }

  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workouts?: boolean | Profile$workoutsArgs<ExtArgs>
    meals?: boolean | Profile$mealsArgs<ExtArgs>
    likedWorkouts?: boolean | Profile$likedWorkoutsArgs<ExtArgs>
    touchWorkouts?: boolean | Profile$touchWorkoutsArgs<ExtArgs>
    likedMeals?: boolean | Profile$likedMealsArgs<ExtArgs>
    touchMeals?: boolean | Profile$touchMealsArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      workouts: Prisma.$WorkoutPayload<ExtArgs>[]
      meals: Prisma.$MealPayload<ExtArgs>[]
      likedWorkouts: Prisma.$ProfileWorkoutLikesPayload<ExtArgs>[]
      touchWorkouts: Prisma.$ProfileWorkoutTouchedPayload<ExtArgs>[]
      likedMeals: Prisma.$ProfileMealLikesPayload<ExtArgs>[]
      touchMeals: Prisma.$ProfileMealTouchedPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uid: string
      email: string
      name: string
      sex: string
      age: number
      bio: string
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workouts<T extends Profile$workoutsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$workoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findMany"> | Null>
    meals<T extends Profile$mealsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$mealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "findMany"> | Null>
    likedWorkouts<T extends Profile$likedWorkoutsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$likedWorkoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileWorkoutLikesPayload<ExtArgs>, T, "findMany"> | Null>
    touchWorkouts<T extends Profile$touchWorkoutsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$touchWorkoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileWorkoutTouchedPayload<ExtArgs>, T, "findMany"> | Null>
    likedMeals<T extends Profile$likedMealsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$likedMealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileMealLikesPayload<ExtArgs>, T, "findMany"> | Null>
    touchMeals<T extends Profile$touchMealsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$touchMealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileMealTouchedPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */ 
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'Int'>
    readonly uid: FieldRef<"Profile", 'String'>
    readonly email: FieldRef<"Profile", 'String'>
    readonly name: FieldRef<"Profile", 'String'>
    readonly sex: FieldRef<"Profile", 'String'>
    readonly age: FieldRef<"Profile", 'Int'>
    readonly bio: FieldRef<"Profile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile.workouts
   */
  export type Profile$workoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    where?: WorkoutWhereInput
    orderBy?: WorkoutOrderByWithRelationInput | WorkoutOrderByWithRelationInput[]
    cursor?: WorkoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkoutScalarFieldEnum | WorkoutScalarFieldEnum[]
  }

  /**
   * Profile.meals
   */
  export type Profile$mealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    where?: MealWhereInput
    orderBy?: MealOrderByWithRelationInput | MealOrderByWithRelationInput[]
    cursor?: MealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MealScalarFieldEnum | MealScalarFieldEnum[]
  }

  /**
   * Profile.likedWorkouts
   */
  export type Profile$likedWorkoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutLikes
     */
    select?: ProfileWorkoutLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutLikesInclude<ExtArgs> | null
    where?: ProfileWorkoutLikesWhereInput
    orderBy?: ProfileWorkoutLikesOrderByWithRelationInput | ProfileWorkoutLikesOrderByWithRelationInput[]
    cursor?: ProfileWorkoutLikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileWorkoutLikesScalarFieldEnum | ProfileWorkoutLikesScalarFieldEnum[]
  }

  /**
   * Profile.touchWorkouts
   */
  export type Profile$touchWorkoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutTouched
     */
    select?: ProfileWorkoutTouchedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutTouchedInclude<ExtArgs> | null
    where?: ProfileWorkoutTouchedWhereInput
    orderBy?: ProfileWorkoutTouchedOrderByWithRelationInput | ProfileWorkoutTouchedOrderByWithRelationInput[]
    cursor?: ProfileWorkoutTouchedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileWorkoutTouchedScalarFieldEnum | ProfileWorkoutTouchedScalarFieldEnum[]
  }

  /**
   * Profile.likedMeals
   */
  export type Profile$likedMealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealLikes
     */
    select?: ProfileMealLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealLikesInclude<ExtArgs> | null
    where?: ProfileMealLikesWhereInput
    orderBy?: ProfileMealLikesOrderByWithRelationInput | ProfileMealLikesOrderByWithRelationInput[]
    cursor?: ProfileMealLikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileMealLikesScalarFieldEnum | ProfileMealLikesScalarFieldEnum[]
  }

  /**
   * Profile.touchMeals
   */
  export type Profile$touchMealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealTouched
     */
    select?: ProfileMealTouchedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealTouchedInclude<ExtArgs> | null
    where?: ProfileMealTouchedWhereInput
    orderBy?: ProfileMealTouchedOrderByWithRelationInput | ProfileMealTouchedOrderByWithRelationInput[]
    cursor?: ProfileMealTouchedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileMealTouchedScalarFieldEnum | ProfileMealTouchedScalarFieldEnum[]
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model Workout
   */

  export type AggregateWorkout = {
    _count: WorkoutCountAggregateOutputType | null
    _avg: WorkoutAvgAggregateOutputType | null
    _sum: WorkoutSumAggregateOutputType | null
    _min: WorkoutMinAggregateOutputType | null
    _max: WorkoutMaxAggregateOutputType | null
  }

  export type WorkoutAvgAggregateOutputType = {
    id: number | null
    profileId: number | null
  }

  export type WorkoutSumAggregateOutputType = {
    id: number | null
    profileId: number | null
  }

  export type WorkoutMinAggregateOutputType = {
    id: number | null
    profileId: number | null
    notes: string | null
    private: boolean | null
  }

  export type WorkoutMaxAggregateOutputType = {
    id: number | null
    profileId: number | null
    notes: string | null
    private: boolean | null
  }

  export type WorkoutCountAggregateOutputType = {
    id: number
    profileId: number
    notes: number
    private: number
    _all: number
  }


  export type WorkoutAvgAggregateInputType = {
    id?: true
    profileId?: true
  }

  export type WorkoutSumAggregateInputType = {
    id?: true
    profileId?: true
  }

  export type WorkoutMinAggregateInputType = {
    id?: true
    profileId?: true
    notes?: true
    private?: true
  }

  export type WorkoutMaxAggregateInputType = {
    id?: true
    profileId?: true
    notes?: true
    private?: true
  }

  export type WorkoutCountAggregateInputType = {
    id?: true
    profileId?: true
    notes?: true
    private?: true
    _all?: true
  }

  export type WorkoutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workout to aggregate.
     */
    where?: WorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workouts to fetch.
     */
    orderBy?: WorkoutOrderByWithRelationInput | WorkoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workouts
    **/
    _count?: true | WorkoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkoutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkoutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkoutMaxAggregateInputType
  }

  export type GetWorkoutAggregateType<T extends WorkoutAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkout[P]>
      : GetScalarType<T[P], AggregateWorkout[P]>
  }




  export type WorkoutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkoutWhereInput
    orderBy?: WorkoutOrderByWithAggregationInput | WorkoutOrderByWithAggregationInput[]
    by: WorkoutScalarFieldEnum[] | WorkoutScalarFieldEnum
    having?: WorkoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkoutCountAggregateInputType | true
    _avg?: WorkoutAvgAggregateInputType
    _sum?: WorkoutSumAggregateInputType
    _min?: WorkoutMinAggregateInputType
    _max?: WorkoutMaxAggregateInputType
  }

  export type WorkoutGroupByOutputType = {
    id: number
    profileId: number
    notes: string
    private: boolean
    _count: WorkoutCountAggregateOutputType | null
    _avg: WorkoutAvgAggregateOutputType | null
    _sum: WorkoutSumAggregateOutputType | null
    _min: WorkoutMinAggregateOutputType | null
    _max: WorkoutMaxAggregateOutputType | null
  }

  type GetWorkoutGroupByPayload<T extends WorkoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkoutGroupByOutputType[P]>
            : GetScalarType<T[P], WorkoutGroupByOutputType[P]>
        }
      >
    >


  export type WorkoutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    notes?: boolean
    private?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    exercises?: boolean | Workout$exercisesArgs<ExtArgs>
    profileLikes?: boolean | Workout$profileLikesArgs<ExtArgs>
    profileTouch?: boolean | Workout$profileTouchArgs<ExtArgs>
    _count?: boolean | WorkoutCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workout"]>

  export type WorkoutSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    notes?: boolean
    private?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workout"]>

  export type WorkoutSelectScalar = {
    id?: boolean
    profileId?: boolean
    notes?: boolean
    private?: boolean
  }

  export type WorkoutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    exercises?: boolean | Workout$exercisesArgs<ExtArgs>
    profileLikes?: boolean | Workout$profileLikesArgs<ExtArgs>
    profileTouch?: boolean | Workout$profileTouchArgs<ExtArgs>
    _count?: boolean | WorkoutCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkoutIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $WorkoutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workout"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
      exercises: Prisma.$ExercisePayload<ExtArgs>[]
      profileLikes: Prisma.$ProfileWorkoutLikesPayload<ExtArgs>[]
      profileTouch: Prisma.$ProfileWorkoutTouchedPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      profileId: number
      notes: string
      private: boolean
    }, ExtArgs["result"]["workout"]>
    composites: {}
  }

  type WorkoutGetPayload<S extends boolean | null | undefined | WorkoutDefaultArgs> = $Result.GetResult<Prisma.$WorkoutPayload, S>

  type WorkoutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkoutFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkoutCountAggregateInputType | true
    }

  export interface WorkoutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workout'], meta: { name: 'Workout' } }
    /**
     * Find zero or one Workout that matches the filter.
     * @param {WorkoutFindUniqueArgs} args - Arguments to find a Workout
     * @example
     * // Get one Workout
     * const workout = await prisma.workout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkoutFindUniqueArgs>(args: SelectSubset<T, WorkoutFindUniqueArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Workout that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkoutFindUniqueOrThrowArgs} args - Arguments to find a Workout
     * @example
     * // Get one Workout
     * const workout = await prisma.workout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkoutFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkoutFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Workout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutFindFirstArgs} args - Arguments to find a Workout
     * @example
     * // Get one Workout
     * const workout = await prisma.workout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkoutFindFirstArgs>(args?: SelectSubset<T, WorkoutFindFirstArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Workout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutFindFirstOrThrowArgs} args - Arguments to find a Workout
     * @example
     * // Get one Workout
     * const workout = await prisma.workout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkoutFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkoutFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Workouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workouts
     * const workouts = await prisma.workout.findMany()
     * 
     * // Get first 10 Workouts
     * const workouts = await prisma.workout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workoutWithIdOnly = await prisma.workout.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkoutFindManyArgs>(args?: SelectSubset<T, WorkoutFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Workout.
     * @param {WorkoutCreateArgs} args - Arguments to create a Workout.
     * @example
     * // Create one Workout
     * const Workout = await prisma.workout.create({
     *   data: {
     *     // ... data to create a Workout
     *   }
     * })
     * 
     */
    create<T extends WorkoutCreateArgs>(args: SelectSubset<T, WorkoutCreateArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Workouts.
     * @param {WorkoutCreateManyArgs} args - Arguments to create many Workouts.
     * @example
     * // Create many Workouts
     * const workout = await prisma.workout.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkoutCreateManyArgs>(args?: SelectSubset<T, WorkoutCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workouts and returns the data saved in the database.
     * @param {WorkoutCreateManyAndReturnArgs} args - Arguments to create many Workouts.
     * @example
     * // Create many Workouts
     * const workout = await prisma.workout.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workouts and only return the `id`
     * const workoutWithIdOnly = await prisma.workout.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkoutCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkoutCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Workout.
     * @param {WorkoutDeleteArgs} args - Arguments to delete one Workout.
     * @example
     * // Delete one Workout
     * const Workout = await prisma.workout.delete({
     *   where: {
     *     // ... filter to delete one Workout
     *   }
     * })
     * 
     */
    delete<T extends WorkoutDeleteArgs>(args: SelectSubset<T, WorkoutDeleteArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Workout.
     * @param {WorkoutUpdateArgs} args - Arguments to update one Workout.
     * @example
     * // Update one Workout
     * const workout = await prisma.workout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkoutUpdateArgs>(args: SelectSubset<T, WorkoutUpdateArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Workouts.
     * @param {WorkoutDeleteManyArgs} args - Arguments to filter Workouts to delete.
     * @example
     * // Delete a few Workouts
     * const { count } = await prisma.workout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkoutDeleteManyArgs>(args?: SelectSubset<T, WorkoutDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workouts
     * const workout = await prisma.workout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkoutUpdateManyArgs>(args: SelectSubset<T, WorkoutUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Workout.
     * @param {WorkoutUpsertArgs} args - Arguments to update or create a Workout.
     * @example
     * // Update or create a Workout
     * const workout = await prisma.workout.upsert({
     *   create: {
     *     // ... data to create a Workout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workout we want to update
     *   }
     * })
     */
    upsert<T extends WorkoutUpsertArgs>(args: SelectSubset<T, WorkoutUpsertArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Workouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutCountArgs} args - Arguments to filter Workouts to count.
     * @example
     * // Count the number of Workouts
     * const count = await prisma.workout.count({
     *   where: {
     *     // ... the filter for the Workouts we want to count
     *   }
     * })
    **/
    count<T extends WorkoutCountArgs>(
      args?: Subset<T, WorkoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkoutAggregateArgs>(args: Subset<T, WorkoutAggregateArgs>): Prisma.PrismaPromise<GetWorkoutAggregateType<T>>

    /**
     * Group by Workout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkoutGroupByArgs['orderBy'] }
        : { orderBy?: WorkoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workout model
   */
  readonly fields: WorkoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkoutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    exercises<T extends Workout$exercisesArgs<ExtArgs> = {}>(args?: Subset<T, Workout$exercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany"> | Null>
    profileLikes<T extends Workout$profileLikesArgs<ExtArgs> = {}>(args?: Subset<T, Workout$profileLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileWorkoutLikesPayload<ExtArgs>, T, "findMany"> | Null>
    profileTouch<T extends Workout$profileTouchArgs<ExtArgs> = {}>(args?: Subset<T, Workout$profileTouchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileWorkoutTouchedPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workout model
   */ 
  interface WorkoutFieldRefs {
    readonly id: FieldRef<"Workout", 'Int'>
    readonly profileId: FieldRef<"Workout", 'Int'>
    readonly notes: FieldRef<"Workout", 'String'>
    readonly private: FieldRef<"Workout", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Workout findUnique
   */
  export type WorkoutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * Filter, which Workout to fetch.
     */
    where: WorkoutWhereUniqueInput
  }

  /**
   * Workout findUniqueOrThrow
   */
  export type WorkoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * Filter, which Workout to fetch.
     */
    where: WorkoutWhereUniqueInput
  }

  /**
   * Workout findFirst
   */
  export type WorkoutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * Filter, which Workout to fetch.
     */
    where?: WorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workouts to fetch.
     */
    orderBy?: WorkoutOrderByWithRelationInput | WorkoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workouts.
     */
    cursor?: WorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workouts.
     */
    distinct?: WorkoutScalarFieldEnum | WorkoutScalarFieldEnum[]
  }

  /**
   * Workout findFirstOrThrow
   */
  export type WorkoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * Filter, which Workout to fetch.
     */
    where?: WorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workouts to fetch.
     */
    orderBy?: WorkoutOrderByWithRelationInput | WorkoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workouts.
     */
    cursor?: WorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workouts.
     */
    distinct?: WorkoutScalarFieldEnum | WorkoutScalarFieldEnum[]
  }

  /**
   * Workout findMany
   */
  export type WorkoutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * Filter, which Workouts to fetch.
     */
    where?: WorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workouts to fetch.
     */
    orderBy?: WorkoutOrderByWithRelationInput | WorkoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workouts.
     */
    cursor?: WorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workouts.
     */
    skip?: number
    distinct?: WorkoutScalarFieldEnum | WorkoutScalarFieldEnum[]
  }

  /**
   * Workout create
   */
  export type WorkoutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * The data needed to create a Workout.
     */
    data: XOR<WorkoutCreateInput, WorkoutUncheckedCreateInput>
  }

  /**
   * Workout createMany
   */
  export type WorkoutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workouts.
     */
    data: WorkoutCreateManyInput | WorkoutCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workout createManyAndReturn
   */
  export type WorkoutCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Workouts.
     */
    data: WorkoutCreateManyInput | WorkoutCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workout update
   */
  export type WorkoutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * The data needed to update a Workout.
     */
    data: XOR<WorkoutUpdateInput, WorkoutUncheckedUpdateInput>
    /**
     * Choose, which Workout to update.
     */
    where: WorkoutWhereUniqueInput
  }

  /**
   * Workout updateMany
   */
  export type WorkoutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workouts.
     */
    data: XOR<WorkoutUpdateManyMutationInput, WorkoutUncheckedUpdateManyInput>
    /**
     * Filter which Workouts to update
     */
    where?: WorkoutWhereInput
  }

  /**
   * Workout upsert
   */
  export type WorkoutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * The filter to search for the Workout to update in case it exists.
     */
    where: WorkoutWhereUniqueInput
    /**
     * In case the Workout found by the `where` argument doesn't exist, create a new Workout with this data.
     */
    create: XOR<WorkoutCreateInput, WorkoutUncheckedCreateInput>
    /**
     * In case the Workout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkoutUpdateInput, WorkoutUncheckedUpdateInput>
  }

  /**
   * Workout delete
   */
  export type WorkoutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    /**
     * Filter which Workout to delete.
     */
    where: WorkoutWhereUniqueInput
  }

  /**
   * Workout deleteMany
   */
  export type WorkoutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workouts to delete
     */
    where?: WorkoutWhereInput
  }

  /**
   * Workout.exercises
   */
  export type Workout$exercisesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    cursor?: ExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Workout.profileLikes
   */
  export type Workout$profileLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutLikes
     */
    select?: ProfileWorkoutLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutLikesInclude<ExtArgs> | null
    where?: ProfileWorkoutLikesWhereInput
    orderBy?: ProfileWorkoutLikesOrderByWithRelationInput | ProfileWorkoutLikesOrderByWithRelationInput[]
    cursor?: ProfileWorkoutLikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileWorkoutLikesScalarFieldEnum | ProfileWorkoutLikesScalarFieldEnum[]
  }

  /**
   * Workout.profileTouch
   */
  export type Workout$profileTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutTouched
     */
    select?: ProfileWorkoutTouchedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutTouchedInclude<ExtArgs> | null
    where?: ProfileWorkoutTouchedWhereInput
    orderBy?: ProfileWorkoutTouchedOrderByWithRelationInput | ProfileWorkoutTouchedOrderByWithRelationInput[]
    cursor?: ProfileWorkoutTouchedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileWorkoutTouchedScalarFieldEnum | ProfileWorkoutTouchedScalarFieldEnum[]
  }

  /**
   * Workout without action
   */
  export type WorkoutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
  }


  /**
   * Model Exercise
   */

  export type AggregateExercise = {
    _count: ExerciseCountAggregateOutputType | null
    _avg: ExerciseAvgAggregateOutputType | null
    _sum: ExerciseSumAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  export type ExerciseAvgAggregateOutputType = {
    id: number | null
    workoutId: number | null
  }

  export type ExerciseSumAggregateOutputType = {
    id: number | null
    workoutId: number | null
  }

  export type ExerciseMinAggregateOutputType = {
    id: number | null
    workoutId: number | null
    name: string | null
  }

  export type ExerciseMaxAggregateOutputType = {
    id: number | null
    workoutId: number | null
    name: string | null
  }

  export type ExerciseCountAggregateOutputType = {
    id: number
    workoutId: number
    name: number
    _all: number
  }


  export type ExerciseAvgAggregateInputType = {
    id?: true
    workoutId?: true
  }

  export type ExerciseSumAggregateInputType = {
    id?: true
    workoutId?: true
  }

  export type ExerciseMinAggregateInputType = {
    id?: true
    workoutId?: true
    name?: true
  }

  export type ExerciseMaxAggregateInputType = {
    id?: true
    workoutId?: true
    name?: true
  }

  export type ExerciseCountAggregateInputType = {
    id?: true
    workoutId?: true
    name?: true
    _all?: true
  }

  export type ExerciseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercise to aggregate.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exercises
    **/
    _count?: true | ExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseMaxAggregateInputType
  }

  export type GetExerciseAggregateType<T extends ExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExercise[P]>
      : GetScalarType<T[P], AggregateExercise[P]>
  }




  export type ExerciseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
    orderBy?: ExerciseOrderByWithAggregationInput | ExerciseOrderByWithAggregationInput[]
    by: ExerciseScalarFieldEnum[] | ExerciseScalarFieldEnum
    having?: ExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseCountAggregateInputType | true
    _avg?: ExerciseAvgAggregateInputType
    _sum?: ExerciseSumAggregateInputType
    _min?: ExerciseMinAggregateInputType
    _max?: ExerciseMaxAggregateInputType
  }

  export type ExerciseGroupByOutputType = {
    id: number
    workoutId: number
    name: string
    _count: ExerciseCountAggregateOutputType | null
    _avg: ExerciseAvgAggregateOutputType | null
    _sum: ExerciseSumAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  type GetExerciseGroupByPayload<T extends ExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workoutId?: boolean
    name?: boolean
    workout?: boolean | WorkoutDefaultArgs<ExtArgs>
    sets?: boolean | Exercise$setsArgs<ExtArgs>
    _count?: boolean | ExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workoutId?: boolean
    name?: boolean
    workout?: boolean | WorkoutDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectScalar = {
    id?: boolean
    workoutId?: boolean
    name?: boolean
  }

  export type ExerciseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workout?: boolean | WorkoutDefaultArgs<ExtArgs>
    sets?: boolean | Exercise$setsArgs<ExtArgs>
    _count?: boolean | ExerciseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExerciseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workout?: boolean | WorkoutDefaultArgs<ExtArgs>
  }

  export type $ExercisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exercise"
    objects: {
      workout: Prisma.$WorkoutPayload<ExtArgs>
      sets: Prisma.$SetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      workoutId: number
      name: string
    }, ExtArgs["result"]["exercise"]>
    composites: {}
  }

  type ExerciseGetPayload<S extends boolean | null | undefined | ExerciseDefaultArgs> = $Result.GetResult<Prisma.$ExercisePayload, S>

  type ExerciseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExerciseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExerciseCountAggregateInputType | true
    }

  export interface ExerciseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exercise'], meta: { name: 'Exercise' } }
    /**
     * Find zero or one Exercise that matches the filter.
     * @param {ExerciseFindUniqueArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExerciseFindUniqueArgs>(args: SelectSubset<T, ExerciseFindUniqueArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Exercise that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExerciseFindUniqueOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExerciseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExerciseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Exercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExerciseFindFirstArgs>(args?: SelectSubset<T, ExerciseFindFirstArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Exercise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExerciseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExerciseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Exercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exercises
     * const exercises = await prisma.exercise.findMany()
     * 
     * // Get first 10 Exercises
     * const exercises = await prisma.exercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseWithIdOnly = await prisma.exercise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExerciseFindManyArgs>(args?: SelectSubset<T, ExerciseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Exercise.
     * @param {ExerciseCreateArgs} args - Arguments to create a Exercise.
     * @example
     * // Create one Exercise
     * const Exercise = await prisma.exercise.create({
     *   data: {
     *     // ... data to create a Exercise
     *   }
     * })
     * 
     */
    create<T extends ExerciseCreateArgs>(args: SelectSubset<T, ExerciseCreateArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Exercises.
     * @param {ExerciseCreateManyArgs} args - Arguments to create many Exercises.
     * @example
     * // Create many Exercises
     * const exercise = await prisma.exercise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExerciseCreateManyArgs>(args?: SelectSubset<T, ExerciseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exercises and returns the data saved in the database.
     * @param {ExerciseCreateManyAndReturnArgs} args - Arguments to create many Exercises.
     * @example
     * // Create many Exercises
     * const exercise = await prisma.exercise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exercises and only return the `id`
     * const exerciseWithIdOnly = await prisma.exercise.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExerciseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExerciseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Exercise.
     * @param {ExerciseDeleteArgs} args - Arguments to delete one Exercise.
     * @example
     * // Delete one Exercise
     * const Exercise = await prisma.exercise.delete({
     *   where: {
     *     // ... filter to delete one Exercise
     *   }
     * })
     * 
     */
    delete<T extends ExerciseDeleteArgs>(args: SelectSubset<T, ExerciseDeleteArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Exercise.
     * @param {ExerciseUpdateArgs} args - Arguments to update one Exercise.
     * @example
     * // Update one Exercise
     * const exercise = await prisma.exercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExerciseUpdateArgs>(args: SelectSubset<T, ExerciseUpdateArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Exercises.
     * @param {ExerciseDeleteManyArgs} args - Arguments to filter Exercises to delete.
     * @example
     * // Delete a few Exercises
     * const { count } = await prisma.exercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExerciseDeleteManyArgs>(args?: SelectSubset<T, ExerciseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exercises
     * const exercise = await prisma.exercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExerciseUpdateManyArgs>(args: SelectSubset<T, ExerciseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Exercise.
     * @param {ExerciseUpsertArgs} args - Arguments to update or create a Exercise.
     * @example
     * // Update or create a Exercise
     * const exercise = await prisma.exercise.upsert({
     *   create: {
     *     // ... data to create a Exercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exercise we want to update
     *   }
     * })
     */
    upsert<T extends ExerciseUpsertArgs>(args: SelectSubset<T, ExerciseUpsertArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseCountArgs} args - Arguments to filter Exercises to count.
     * @example
     * // Count the number of Exercises
     * const count = await prisma.exercise.count({
     *   where: {
     *     // ... the filter for the Exercises we want to count
     *   }
     * })
    **/
    count<T extends ExerciseCountArgs>(
      args?: Subset<T, ExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseAggregateArgs>(args: Subset<T, ExerciseAggregateArgs>): Prisma.PrismaPromise<GetExerciseAggregateType<T>>

    /**
     * Group by Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exercise model
   */
  readonly fields: ExerciseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExerciseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workout<T extends WorkoutDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkoutDefaultArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sets<T extends Exercise$setsArgs<ExtArgs> = {}>(args?: Subset<T, Exercise$setsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SetPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exercise model
   */ 
  interface ExerciseFieldRefs {
    readonly id: FieldRef<"Exercise", 'Int'>
    readonly workoutId: FieldRef<"Exercise", 'Int'>
    readonly name: FieldRef<"Exercise", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Exercise findUnique
   */
  export type ExerciseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise findUniqueOrThrow
   */
  export type ExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise findFirst
   */
  export type ExerciseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise findFirstOrThrow
   */
  export type ExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise findMany
   */
  export type ExerciseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercises to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: ExerciseOrderByWithRelationInput | ExerciseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    distinct?: ExerciseScalarFieldEnum | ExerciseScalarFieldEnum[]
  }

  /**
   * Exercise create
   */
  export type ExerciseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The data needed to create a Exercise.
     */
    data: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
  }

  /**
   * Exercise createMany
   */
  export type ExerciseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exercises.
     */
    data: ExerciseCreateManyInput | ExerciseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exercise createManyAndReturn
   */
  export type ExerciseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Exercises.
     */
    data: ExerciseCreateManyInput | ExerciseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exercise update
   */
  export type ExerciseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The data needed to update a Exercise.
     */
    data: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
    /**
     * Choose, which Exercise to update.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise updateMany
   */
  export type ExerciseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exercises.
     */
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyInput>
    /**
     * Filter which Exercises to update
     */
    where?: ExerciseWhereInput
  }

  /**
   * Exercise upsert
   */
  export type ExerciseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The filter to search for the Exercise to update in case it exists.
     */
    where: ExerciseWhereUniqueInput
    /**
     * In case the Exercise found by the `where` argument doesn't exist, create a new Exercise with this data.
     */
    create: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
    /**
     * In case the Exercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
  }

  /**
   * Exercise delete
   */
  export type ExerciseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter which Exercise to delete.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise deleteMany
   */
  export type ExerciseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercises to delete
     */
    where?: ExerciseWhereInput
  }

  /**
   * Exercise.sets
   */
  export type Exercise$setsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Set
     */
    select?: SetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SetInclude<ExtArgs> | null
    where?: SetWhereInput
    orderBy?: SetOrderByWithRelationInput | SetOrderByWithRelationInput[]
    cursor?: SetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SetScalarFieldEnum | SetScalarFieldEnum[]
  }

  /**
   * Exercise without action
   */
  export type ExerciseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExerciseInclude<ExtArgs> | null
  }


  /**
   * Model Set
   */

  export type AggregateSet = {
    _count: SetCountAggregateOutputType | null
    _avg: SetAvgAggregateOutputType | null
    _sum: SetSumAggregateOutputType | null
    _min: SetMinAggregateOutputType | null
    _max: SetMaxAggregateOutputType | null
  }

  export type SetAvgAggregateOutputType = {
    id: number | null
    exerciseId: number | null
    weight: number | null
    reps: number | null
  }

  export type SetSumAggregateOutputType = {
    id: number | null
    exerciseId: number | null
    weight: number | null
    reps: number | null
  }

  export type SetMinAggregateOutputType = {
    id: number | null
    exerciseId: number | null
    weight: number | null
    reps: number | null
  }

  export type SetMaxAggregateOutputType = {
    id: number | null
    exerciseId: number | null
    weight: number | null
    reps: number | null
  }

  export type SetCountAggregateOutputType = {
    id: number
    exerciseId: number
    weight: number
    reps: number
    _all: number
  }


  export type SetAvgAggregateInputType = {
    id?: true
    exerciseId?: true
    weight?: true
    reps?: true
  }

  export type SetSumAggregateInputType = {
    id?: true
    exerciseId?: true
    weight?: true
    reps?: true
  }

  export type SetMinAggregateInputType = {
    id?: true
    exerciseId?: true
    weight?: true
    reps?: true
  }

  export type SetMaxAggregateInputType = {
    id?: true
    exerciseId?: true
    weight?: true
    reps?: true
  }

  export type SetCountAggregateInputType = {
    id?: true
    exerciseId?: true
    weight?: true
    reps?: true
    _all?: true
  }

  export type SetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Set to aggregate.
     */
    where?: SetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sets to fetch.
     */
    orderBy?: SetOrderByWithRelationInput | SetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sets
    **/
    _count?: true | SetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SetMaxAggregateInputType
  }

  export type GetSetAggregateType<T extends SetAggregateArgs> = {
        [P in keyof T & keyof AggregateSet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSet[P]>
      : GetScalarType<T[P], AggregateSet[P]>
  }




  export type SetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SetWhereInput
    orderBy?: SetOrderByWithAggregationInput | SetOrderByWithAggregationInput[]
    by: SetScalarFieldEnum[] | SetScalarFieldEnum
    having?: SetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SetCountAggregateInputType | true
    _avg?: SetAvgAggregateInputType
    _sum?: SetSumAggregateInputType
    _min?: SetMinAggregateInputType
    _max?: SetMaxAggregateInputType
  }

  export type SetGroupByOutputType = {
    id: number
    exerciseId: number
    weight: number
    reps: number
    _count: SetCountAggregateOutputType | null
    _avg: SetAvgAggregateOutputType | null
    _sum: SetSumAggregateOutputType | null
    _min: SetMinAggregateOutputType | null
    _max: SetMaxAggregateOutputType | null
  }

  type GetSetGroupByPayload<T extends SetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SetGroupByOutputType[P]>
            : GetScalarType<T[P], SetGroupByOutputType[P]>
        }
      >
    >


  export type SetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exerciseId?: boolean
    weight?: boolean
    reps?: boolean
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["set"]>

  export type SetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exerciseId?: boolean
    weight?: boolean
    reps?: boolean
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["set"]>

  export type SetSelectScalar = {
    id?: boolean
    exerciseId?: boolean
    weight?: boolean
    reps?: boolean
  }

  export type SetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }
  export type SetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exercise?: boolean | ExerciseDefaultArgs<ExtArgs>
  }

  export type $SetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Set"
    objects: {
      exercise: Prisma.$ExercisePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      exerciseId: number
      weight: number
      reps: number
    }, ExtArgs["result"]["set"]>
    composites: {}
  }

  type SetGetPayload<S extends boolean | null | undefined | SetDefaultArgs> = $Result.GetResult<Prisma.$SetPayload, S>

  type SetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SetCountAggregateInputType | true
    }

  export interface SetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Set'], meta: { name: 'Set' } }
    /**
     * Find zero or one Set that matches the filter.
     * @param {SetFindUniqueArgs} args - Arguments to find a Set
     * @example
     * // Get one Set
     * const set = await prisma.set.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SetFindUniqueArgs>(args: SelectSubset<T, SetFindUniqueArgs<ExtArgs>>): Prisma__SetClient<$Result.GetResult<Prisma.$SetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Set that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SetFindUniqueOrThrowArgs} args - Arguments to find a Set
     * @example
     * // Get one Set
     * const set = await prisma.set.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SetFindUniqueOrThrowArgs>(args: SelectSubset<T, SetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SetClient<$Result.GetResult<Prisma.$SetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Set that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SetFindFirstArgs} args - Arguments to find a Set
     * @example
     * // Get one Set
     * const set = await prisma.set.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SetFindFirstArgs>(args?: SelectSubset<T, SetFindFirstArgs<ExtArgs>>): Prisma__SetClient<$Result.GetResult<Prisma.$SetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Set that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SetFindFirstOrThrowArgs} args - Arguments to find a Set
     * @example
     * // Get one Set
     * const set = await prisma.set.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SetFindFirstOrThrowArgs>(args?: SelectSubset<T, SetFindFirstOrThrowArgs<ExtArgs>>): Prisma__SetClient<$Result.GetResult<Prisma.$SetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sets
     * const sets = await prisma.set.findMany()
     * 
     * // Get first 10 Sets
     * const sets = await prisma.set.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const setWithIdOnly = await prisma.set.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SetFindManyArgs>(args?: SelectSubset<T, SetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Set.
     * @param {SetCreateArgs} args - Arguments to create a Set.
     * @example
     * // Create one Set
     * const Set = await prisma.set.create({
     *   data: {
     *     // ... data to create a Set
     *   }
     * })
     * 
     */
    create<T extends SetCreateArgs>(args: SelectSubset<T, SetCreateArgs<ExtArgs>>): Prisma__SetClient<$Result.GetResult<Prisma.$SetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sets.
     * @param {SetCreateManyArgs} args - Arguments to create many Sets.
     * @example
     * // Create many Sets
     * const set = await prisma.set.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SetCreateManyArgs>(args?: SelectSubset<T, SetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sets and returns the data saved in the database.
     * @param {SetCreateManyAndReturnArgs} args - Arguments to create many Sets.
     * @example
     * // Create many Sets
     * const set = await prisma.set.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sets and only return the `id`
     * const setWithIdOnly = await prisma.set.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SetCreateManyAndReturnArgs>(args?: SelectSubset<T, SetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Set.
     * @param {SetDeleteArgs} args - Arguments to delete one Set.
     * @example
     * // Delete one Set
     * const Set = await prisma.set.delete({
     *   where: {
     *     // ... filter to delete one Set
     *   }
     * })
     * 
     */
    delete<T extends SetDeleteArgs>(args: SelectSubset<T, SetDeleteArgs<ExtArgs>>): Prisma__SetClient<$Result.GetResult<Prisma.$SetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Set.
     * @param {SetUpdateArgs} args - Arguments to update one Set.
     * @example
     * // Update one Set
     * const set = await prisma.set.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SetUpdateArgs>(args: SelectSubset<T, SetUpdateArgs<ExtArgs>>): Prisma__SetClient<$Result.GetResult<Prisma.$SetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sets.
     * @param {SetDeleteManyArgs} args - Arguments to filter Sets to delete.
     * @example
     * // Delete a few Sets
     * const { count } = await prisma.set.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SetDeleteManyArgs>(args?: SelectSubset<T, SetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sets
     * const set = await prisma.set.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SetUpdateManyArgs>(args: SelectSubset<T, SetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Set.
     * @param {SetUpsertArgs} args - Arguments to update or create a Set.
     * @example
     * // Update or create a Set
     * const set = await prisma.set.upsert({
     *   create: {
     *     // ... data to create a Set
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Set we want to update
     *   }
     * })
     */
    upsert<T extends SetUpsertArgs>(args: SelectSubset<T, SetUpsertArgs<ExtArgs>>): Prisma__SetClient<$Result.GetResult<Prisma.$SetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SetCountArgs} args - Arguments to filter Sets to count.
     * @example
     * // Count the number of Sets
     * const count = await prisma.set.count({
     *   where: {
     *     // ... the filter for the Sets we want to count
     *   }
     * })
    **/
    count<T extends SetCountArgs>(
      args?: Subset<T, SetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Set.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SetAggregateArgs>(args: Subset<T, SetAggregateArgs>): Prisma.PrismaPromise<GetSetAggregateType<T>>

    /**
     * Group by Set.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SetGroupByArgs['orderBy'] }
        : { orderBy?: SetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Set model
   */
  readonly fields: SetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Set.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exercise<T extends ExerciseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExerciseDefaultArgs<ExtArgs>>): Prisma__ExerciseClient<$Result.GetResult<Prisma.$ExercisePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Set model
   */ 
  interface SetFieldRefs {
    readonly id: FieldRef<"Set", 'Int'>
    readonly exerciseId: FieldRef<"Set", 'Int'>
    readonly weight: FieldRef<"Set", 'Float'>
    readonly reps: FieldRef<"Set", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Set findUnique
   */
  export type SetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Set
     */
    select?: SetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SetInclude<ExtArgs> | null
    /**
     * Filter, which Set to fetch.
     */
    where: SetWhereUniqueInput
  }

  /**
   * Set findUniqueOrThrow
   */
  export type SetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Set
     */
    select?: SetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SetInclude<ExtArgs> | null
    /**
     * Filter, which Set to fetch.
     */
    where: SetWhereUniqueInput
  }

  /**
   * Set findFirst
   */
  export type SetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Set
     */
    select?: SetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SetInclude<ExtArgs> | null
    /**
     * Filter, which Set to fetch.
     */
    where?: SetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sets to fetch.
     */
    orderBy?: SetOrderByWithRelationInput | SetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sets.
     */
    cursor?: SetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sets.
     */
    distinct?: SetScalarFieldEnum | SetScalarFieldEnum[]
  }

  /**
   * Set findFirstOrThrow
   */
  export type SetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Set
     */
    select?: SetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SetInclude<ExtArgs> | null
    /**
     * Filter, which Set to fetch.
     */
    where?: SetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sets to fetch.
     */
    orderBy?: SetOrderByWithRelationInput | SetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sets.
     */
    cursor?: SetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sets.
     */
    distinct?: SetScalarFieldEnum | SetScalarFieldEnum[]
  }

  /**
   * Set findMany
   */
  export type SetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Set
     */
    select?: SetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SetInclude<ExtArgs> | null
    /**
     * Filter, which Sets to fetch.
     */
    where?: SetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sets to fetch.
     */
    orderBy?: SetOrderByWithRelationInput | SetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sets.
     */
    cursor?: SetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sets.
     */
    skip?: number
    distinct?: SetScalarFieldEnum | SetScalarFieldEnum[]
  }

  /**
   * Set create
   */
  export type SetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Set
     */
    select?: SetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SetInclude<ExtArgs> | null
    /**
     * The data needed to create a Set.
     */
    data: XOR<SetCreateInput, SetUncheckedCreateInput>
  }

  /**
   * Set createMany
   */
  export type SetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sets.
     */
    data: SetCreateManyInput | SetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Set createManyAndReturn
   */
  export type SetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Set
     */
    select?: SetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sets.
     */
    data: SetCreateManyInput | SetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Set update
   */
  export type SetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Set
     */
    select?: SetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SetInclude<ExtArgs> | null
    /**
     * The data needed to update a Set.
     */
    data: XOR<SetUpdateInput, SetUncheckedUpdateInput>
    /**
     * Choose, which Set to update.
     */
    where: SetWhereUniqueInput
  }

  /**
   * Set updateMany
   */
  export type SetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sets.
     */
    data: XOR<SetUpdateManyMutationInput, SetUncheckedUpdateManyInput>
    /**
     * Filter which Sets to update
     */
    where?: SetWhereInput
  }

  /**
   * Set upsert
   */
  export type SetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Set
     */
    select?: SetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SetInclude<ExtArgs> | null
    /**
     * The filter to search for the Set to update in case it exists.
     */
    where: SetWhereUniqueInput
    /**
     * In case the Set found by the `where` argument doesn't exist, create a new Set with this data.
     */
    create: XOR<SetCreateInput, SetUncheckedCreateInput>
    /**
     * In case the Set was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SetUpdateInput, SetUncheckedUpdateInput>
  }

  /**
   * Set delete
   */
  export type SetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Set
     */
    select?: SetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SetInclude<ExtArgs> | null
    /**
     * Filter which Set to delete.
     */
    where: SetWhereUniqueInput
  }

  /**
   * Set deleteMany
   */
  export type SetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sets to delete
     */
    where?: SetWhereInput
  }

  /**
   * Set without action
   */
  export type SetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Set
     */
    select?: SetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SetInclude<ExtArgs> | null
  }


  /**
   * Model Meal
   */

  export type AggregateMeal = {
    _count: MealCountAggregateOutputType | null
    _avg: MealAvgAggregateOutputType | null
    _sum: MealSumAggregateOutputType | null
    _min: MealMinAggregateOutputType | null
    _max: MealMaxAggregateOutputType | null
  }

  export type MealAvgAggregateOutputType = {
    id: number | null
    profileId: number | null
    totalCalories: number | null
    totalCarbs: number | null
    totalFats: number | null
    totalProteins: number | null
    totalGrams: number | null
  }

  export type MealSumAggregateOutputType = {
    id: number | null
    profileId: number | null
    totalCalories: number | null
    totalCarbs: number | null
    totalFats: number | null
    totalProteins: number | null
    totalGrams: number | null
  }

  export type MealMinAggregateOutputType = {
    id: number | null
    profileId: number | null
    notes: string | null
    totalCalories: number | null
    totalCarbs: number | null
    totalFats: number | null
    totalProteins: number | null
    totalGrams: number | null
    private: boolean | null
  }

  export type MealMaxAggregateOutputType = {
    id: number | null
    profileId: number | null
    notes: string | null
    totalCalories: number | null
    totalCarbs: number | null
    totalFats: number | null
    totalProteins: number | null
    totalGrams: number | null
    private: boolean | null
  }

  export type MealCountAggregateOutputType = {
    id: number
    profileId: number
    notes: number
    totalCalories: number
    totalCarbs: number
    totalFats: number
    totalProteins: number
    totalGrams: number
    private: number
    _all: number
  }


  export type MealAvgAggregateInputType = {
    id?: true
    profileId?: true
    totalCalories?: true
    totalCarbs?: true
    totalFats?: true
    totalProteins?: true
    totalGrams?: true
  }

  export type MealSumAggregateInputType = {
    id?: true
    profileId?: true
    totalCalories?: true
    totalCarbs?: true
    totalFats?: true
    totalProteins?: true
    totalGrams?: true
  }

  export type MealMinAggregateInputType = {
    id?: true
    profileId?: true
    notes?: true
    totalCalories?: true
    totalCarbs?: true
    totalFats?: true
    totalProteins?: true
    totalGrams?: true
    private?: true
  }

  export type MealMaxAggregateInputType = {
    id?: true
    profileId?: true
    notes?: true
    totalCalories?: true
    totalCarbs?: true
    totalFats?: true
    totalProteins?: true
    totalGrams?: true
    private?: true
  }

  export type MealCountAggregateInputType = {
    id?: true
    profileId?: true
    notes?: true
    totalCalories?: true
    totalCarbs?: true
    totalFats?: true
    totalProteins?: true
    totalGrams?: true
    private?: true
    _all?: true
  }

  export type MealAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meal to aggregate.
     */
    where?: MealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meals to fetch.
     */
    orderBy?: MealOrderByWithRelationInput | MealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Meals
    **/
    _count?: true | MealCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MealAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MealSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MealMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MealMaxAggregateInputType
  }

  export type GetMealAggregateType<T extends MealAggregateArgs> = {
        [P in keyof T & keyof AggregateMeal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeal[P]>
      : GetScalarType<T[P], AggregateMeal[P]>
  }




  export type MealGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MealWhereInput
    orderBy?: MealOrderByWithAggregationInput | MealOrderByWithAggregationInput[]
    by: MealScalarFieldEnum[] | MealScalarFieldEnum
    having?: MealScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MealCountAggregateInputType | true
    _avg?: MealAvgAggregateInputType
    _sum?: MealSumAggregateInputType
    _min?: MealMinAggregateInputType
    _max?: MealMaxAggregateInputType
  }

  export type MealGroupByOutputType = {
    id: number
    profileId: number
    notes: string
    totalCalories: number
    totalCarbs: number
    totalFats: number
    totalProteins: number
    totalGrams: number
    private: boolean
    _count: MealCountAggregateOutputType | null
    _avg: MealAvgAggregateOutputType | null
    _sum: MealSumAggregateOutputType | null
    _min: MealMinAggregateOutputType | null
    _max: MealMaxAggregateOutputType | null
  }

  type GetMealGroupByPayload<T extends MealGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MealGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MealGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MealGroupByOutputType[P]>
            : GetScalarType<T[P], MealGroupByOutputType[P]>
        }
      >
    >


  export type MealSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    notes?: boolean
    totalCalories?: boolean
    totalCarbs?: boolean
    totalFats?: boolean
    totalProteins?: boolean
    totalGrams?: boolean
    private?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    foods?: boolean | Meal$foodsArgs<ExtArgs>
    profileLikes?: boolean | Meal$profileLikesArgs<ExtArgs>
    profileTouch?: boolean | Meal$profileTouchArgs<ExtArgs>
    _count?: boolean | MealCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meal"]>

  export type MealSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    notes?: boolean
    totalCalories?: boolean
    totalCarbs?: boolean
    totalFats?: boolean
    totalProteins?: boolean
    totalGrams?: boolean
    private?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meal"]>

  export type MealSelectScalar = {
    id?: boolean
    profileId?: boolean
    notes?: boolean
    totalCalories?: boolean
    totalCarbs?: boolean
    totalFats?: boolean
    totalProteins?: boolean
    totalGrams?: boolean
    private?: boolean
  }

  export type MealInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    foods?: boolean | Meal$foodsArgs<ExtArgs>
    profileLikes?: boolean | Meal$profileLikesArgs<ExtArgs>
    profileTouch?: boolean | Meal$profileTouchArgs<ExtArgs>
    _count?: boolean | MealCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MealIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $MealPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Meal"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
      foods: Prisma.$FoodPayload<ExtArgs>[]
      profileLikes: Prisma.$ProfileMealLikesPayload<ExtArgs>[]
      profileTouch: Prisma.$ProfileMealTouchedPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      profileId: number
      notes: string
      totalCalories: number
      totalCarbs: number
      totalFats: number
      totalProteins: number
      totalGrams: number
      private: boolean
    }, ExtArgs["result"]["meal"]>
    composites: {}
  }

  type MealGetPayload<S extends boolean | null | undefined | MealDefaultArgs> = $Result.GetResult<Prisma.$MealPayload, S>

  type MealCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MealFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MealCountAggregateInputType | true
    }

  export interface MealDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Meal'], meta: { name: 'Meal' } }
    /**
     * Find zero or one Meal that matches the filter.
     * @param {MealFindUniqueArgs} args - Arguments to find a Meal
     * @example
     * // Get one Meal
     * const meal = await prisma.meal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MealFindUniqueArgs>(args: SelectSubset<T, MealFindUniqueArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Meal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MealFindUniqueOrThrowArgs} args - Arguments to find a Meal
     * @example
     * // Get one Meal
     * const meal = await prisma.meal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MealFindUniqueOrThrowArgs>(args: SelectSubset<T, MealFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Meal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealFindFirstArgs} args - Arguments to find a Meal
     * @example
     * // Get one Meal
     * const meal = await prisma.meal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MealFindFirstArgs>(args?: SelectSubset<T, MealFindFirstArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Meal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealFindFirstOrThrowArgs} args - Arguments to find a Meal
     * @example
     * // Get one Meal
     * const meal = await prisma.meal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MealFindFirstOrThrowArgs>(args?: SelectSubset<T, MealFindFirstOrThrowArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Meals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meals
     * const meals = await prisma.meal.findMany()
     * 
     * // Get first 10 Meals
     * const meals = await prisma.meal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mealWithIdOnly = await prisma.meal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MealFindManyArgs>(args?: SelectSubset<T, MealFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Meal.
     * @param {MealCreateArgs} args - Arguments to create a Meal.
     * @example
     * // Create one Meal
     * const Meal = await prisma.meal.create({
     *   data: {
     *     // ... data to create a Meal
     *   }
     * })
     * 
     */
    create<T extends MealCreateArgs>(args: SelectSubset<T, MealCreateArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Meals.
     * @param {MealCreateManyArgs} args - Arguments to create many Meals.
     * @example
     * // Create many Meals
     * const meal = await prisma.meal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MealCreateManyArgs>(args?: SelectSubset<T, MealCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Meals and returns the data saved in the database.
     * @param {MealCreateManyAndReturnArgs} args - Arguments to create many Meals.
     * @example
     * // Create many Meals
     * const meal = await prisma.meal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Meals and only return the `id`
     * const mealWithIdOnly = await prisma.meal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MealCreateManyAndReturnArgs>(args?: SelectSubset<T, MealCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Meal.
     * @param {MealDeleteArgs} args - Arguments to delete one Meal.
     * @example
     * // Delete one Meal
     * const Meal = await prisma.meal.delete({
     *   where: {
     *     // ... filter to delete one Meal
     *   }
     * })
     * 
     */
    delete<T extends MealDeleteArgs>(args: SelectSubset<T, MealDeleteArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Meal.
     * @param {MealUpdateArgs} args - Arguments to update one Meal.
     * @example
     * // Update one Meal
     * const meal = await prisma.meal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MealUpdateArgs>(args: SelectSubset<T, MealUpdateArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Meals.
     * @param {MealDeleteManyArgs} args - Arguments to filter Meals to delete.
     * @example
     * // Delete a few Meals
     * const { count } = await prisma.meal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MealDeleteManyArgs>(args?: SelectSubset<T, MealDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meals
     * const meal = await prisma.meal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MealUpdateManyArgs>(args: SelectSubset<T, MealUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meal.
     * @param {MealUpsertArgs} args - Arguments to update or create a Meal.
     * @example
     * // Update or create a Meal
     * const meal = await prisma.meal.upsert({
     *   create: {
     *     // ... data to create a Meal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meal we want to update
     *   }
     * })
     */
    upsert<T extends MealUpsertArgs>(args: SelectSubset<T, MealUpsertArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Meals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealCountArgs} args - Arguments to filter Meals to count.
     * @example
     * // Count the number of Meals
     * const count = await prisma.meal.count({
     *   where: {
     *     // ... the filter for the Meals we want to count
     *   }
     * })
    **/
    count<T extends MealCountArgs>(
      args?: Subset<T, MealCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MealCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MealAggregateArgs>(args: Subset<T, MealAggregateArgs>): Prisma.PrismaPromise<GetMealAggregateType<T>>

    /**
     * Group by Meal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MealGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MealGroupByArgs['orderBy'] }
        : { orderBy?: MealGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MealGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMealGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Meal model
   */
  readonly fields: MealFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Meal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MealClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    foods<T extends Meal$foodsArgs<ExtArgs> = {}>(args?: Subset<T, Meal$foodsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findMany"> | Null>
    profileLikes<T extends Meal$profileLikesArgs<ExtArgs> = {}>(args?: Subset<T, Meal$profileLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileMealLikesPayload<ExtArgs>, T, "findMany"> | Null>
    profileTouch<T extends Meal$profileTouchArgs<ExtArgs> = {}>(args?: Subset<T, Meal$profileTouchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileMealTouchedPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Meal model
   */ 
  interface MealFieldRefs {
    readonly id: FieldRef<"Meal", 'Int'>
    readonly profileId: FieldRef<"Meal", 'Int'>
    readonly notes: FieldRef<"Meal", 'String'>
    readonly totalCalories: FieldRef<"Meal", 'Float'>
    readonly totalCarbs: FieldRef<"Meal", 'Float'>
    readonly totalFats: FieldRef<"Meal", 'Float'>
    readonly totalProteins: FieldRef<"Meal", 'Float'>
    readonly totalGrams: FieldRef<"Meal", 'Float'>
    readonly private: FieldRef<"Meal", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Meal findUnique
   */
  export type MealFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * Filter, which Meal to fetch.
     */
    where: MealWhereUniqueInput
  }

  /**
   * Meal findUniqueOrThrow
   */
  export type MealFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * Filter, which Meal to fetch.
     */
    where: MealWhereUniqueInput
  }

  /**
   * Meal findFirst
   */
  export type MealFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * Filter, which Meal to fetch.
     */
    where?: MealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meals to fetch.
     */
    orderBy?: MealOrderByWithRelationInput | MealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meals.
     */
    cursor?: MealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meals.
     */
    distinct?: MealScalarFieldEnum | MealScalarFieldEnum[]
  }

  /**
   * Meal findFirstOrThrow
   */
  export type MealFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * Filter, which Meal to fetch.
     */
    where?: MealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meals to fetch.
     */
    orderBy?: MealOrderByWithRelationInput | MealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meals.
     */
    cursor?: MealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meals.
     */
    distinct?: MealScalarFieldEnum | MealScalarFieldEnum[]
  }

  /**
   * Meal findMany
   */
  export type MealFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * Filter, which Meals to fetch.
     */
    where?: MealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meals to fetch.
     */
    orderBy?: MealOrderByWithRelationInput | MealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Meals.
     */
    cursor?: MealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meals.
     */
    skip?: number
    distinct?: MealScalarFieldEnum | MealScalarFieldEnum[]
  }

  /**
   * Meal create
   */
  export type MealCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * The data needed to create a Meal.
     */
    data: XOR<MealCreateInput, MealUncheckedCreateInput>
  }

  /**
   * Meal createMany
   */
  export type MealCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Meals.
     */
    data: MealCreateManyInput | MealCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Meal createManyAndReturn
   */
  export type MealCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Meals.
     */
    data: MealCreateManyInput | MealCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Meal update
   */
  export type MealUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * The data needed to update a Meal.
     */
    data: XOR<MealUpdateInput, MealUncheckedUpdateInput>
    /**
     * Choose, which Meal to update.
     */
    where: MealWhereUniqueInput
  }

  /**
   * Meal updateMany
   */
  export type MealUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Meals.
     */
    data: XOR<MealUpdateManyMutationInput, MealUncheckedUpdateManyInput>
    /**
     * Filter which Meals to update
     */
    where?: MealWhereInput
  }

  /**
   * Meal upsert
   */
  export type MealUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * The filter to search for the Meal to update in case it exists.
     */
    where: MealWhereUniqueInput
    /**
     * In case the Meal found by the `where` argument doesn't exist, create a new Meal with this data.
     */
    create: XOR<MealCreateInput, MealUncheckedCreateInput>
    /**
     * In case the Meal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MealUpdateInput, MealUncheckedUpdateInput>
  }

  /**
   * Meal delete
   */
  export type MealDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    /**
     * Filter which Meal to delete.
     */
    where: MealWhereUniqueInput
  }

  /**
   * Meal deleteMany
   */
  export type MealDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meals to delete
     */
    where?: MealWhereInput
  }

  /**
   * Meal.foods
   */
  export type Meal$foodsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    where?: FoodWhereInput
    orderBy?: FoodOrderByWithRelationInput | FoodOrderByWithRelationInput[]
    cursor?: FoodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodScalarFieldEnum | FoodScalarFieldEnum[]
  }

  /**
   * Meal.profileLikes
   */
  export type Meal$profileLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealLikes
     */
    select?: ProfileMealLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealLikesInclude<ExtArgs> | null
    where?: ProfileMealLikesWhereInput
    orderBy?: ProfileMealLikesOrderByWithRelationInput | ProfileMealLikesOrderByWithRelationInput[]
    cursor?: ProfileMealLikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileMealLikesScalarFieldEnum | ProfileMealLikesScalarFieldEnum[]
  }

  /**
   * Meal.profileTouch
   */
  export type Meal$profileTouchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealTouched
     */
    select?: ProfileMealTouchedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealTouchedInclude<ExtArgs> | null
    where?: ProfileMealTouchedWhereInput
    orderBy?: ProfileMealTouchedOrderByWithRelationInput | ProfileMealTouchedOrderByWithRelationInput[]
    cursor?: ProfileMealTouchedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileMealTouchedScalarFieldEnum | ProfileMealTouchedScalarFieldEnum[]
  }

  /**
   * Meal without action
   */
  export type MealDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
  }


  /**
   * Model Food
   */

  export type AggregateFood = {
    _count: FoodCountAggregateOutputType | null
    _avg: FoodAvgAggregateOutputType | null
    _sum: FoodSumAggregateOutputType | null
    _min: FoodMinAggregateOutputType | null
    _max: FoodMaxAggregateOutputType | null
  }

  export type FoodAvgAggregateOutputType = {
    id: number | null
    mealId: number | null
    calories: number | null
    carbs: number | null
    fats: number | null
    proteins: number | null
    grams: number | null
  }

  export type FoodSumAggregateOutputType = {
    id: number | null
    mealId: number | null
    calories: number | null
    carbs: number | null
    fats: number | null
    proteins: number | null
    grams: number | null
  }

  export type FoodMinAggregateOutputType = {
    id: number | null
    mealId: number | null
    name: string | null
    calories: number | null
    carbs: number | null
    fats: number | null
    proteins: number | null
    grams: number | null
  }

  export type FoodMaxAggregateOutputType = {
    id: number | null
    mealId: number | null
    name: string | null
    calories: number | null
    carbs: number | null
    fats: number | null
    proteins: number | null
    grams: number | null
  }

  export type FoodCountAggregateOutputType = {
    id: number
    mealId: number
    name: number
    calories: number
    carbs: number
    fats: number
    proteins: number
    grams: number
    _all: number
  }


  export type FoodAvgAggregateInputType = {
    id?: true
    mealId?: true
    calories?: true
    carbs?: true
    fats?: true
    proteins?: true
    grams?: true
  }

  export type FoodSumAggregateInputType = {
    id?: true
    mealId?: true
    calories?: true
    carbs?: true
    fats?: true
    proteins?: true
    grams?: true
  }

  export type FoodMinAggregateInputType = {
    id?: true
    mealId?: true
    name?: true
    calories?: true
    carbs?: true
    fats?: true
    proteins?: true
    grams?: true
  }

  export type FoodMaxAggregateInputType = {
    id?: true
    mealId?: true
    name?: true
    calories?: true
    carbs?: true
    fats?: true
    proteins?: true
    grams?: true
  }

  export type FoodCountAggregateInputType = {
    id?: true
    mealId?: true
    name?: true
    calories?: true
    carbs?: true
    fats?: true
    proteins?: true
    grams?: true
    _all?: true
  }

  export type FoodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Food to aggregate.
     */
    where?: FoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foods to fetch.
     */
    orderBy?: FoodOrderByWithRelationInput | FoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Foods
    **/
    _count?: true | FoodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodMaxAggregateInputType
  }

  export type GetFoodAggregateType<T extends FoodAggregateArgs> = {
        [P in keyof T & keyof AggregateFood]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFood[P]>
      : GetScalarType<T[P], AggregateFood[P]>
  }




  export type FoodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodWhereInput
    orderBy?: FoodOrderByWithAggregationInput | FoodOrderByWithAggregationInput[]
    by: FoodScalarFieldEnum[] | FoodScalarFieldEnum
    having?: FoodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodCountAggregateInputType | true
    _avg?: FoodAvgAggregateInputType
    _sum?: FoodSumAggregateInputType
    _min?: FoodMinAggregateInputType
    _max?: FoodMaxAggregateInputType
  }

  export type FoodGroupByOutputType = {
    id: number
    mealId: number
    name: string
    calories: number
    carbs: number
    fats: number
    proteins: number
    grams: number
    _count: FoodCountAggregateOutputType | null
    _avg: FoodAvgAggregateOutputType | null
    _sum: FoodSumAggregateOutputType | null
    _min: FoodMinAggregateOutputType | null
    _max: FoodMaxAggregateOutputType | null
  }

  type GetFoodGroupByPayload<T extends FoodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodGroupByOutputType[P]>
            : GetScalarType<T[P], FoodGroupByOutputType[P]>
        }
      >
    >


  export type FoodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mealId?: boolean
    name?: boolean
    calories?: boolean
    carbs?: boolean
    fats?: boolean
    proteins?: boolean
    grams?: boolean
    meal?: boolean | MealDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["food"]>

  export type FoodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mealId?: boolean
    name?: boolean
    calories?: boolean
    carbs?: boolean
    fats?: boolean
    proteins?: boolean
    grams?: boolean
    meal?: boolean | MealDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["food"]>

  export type FoodSelectScalar = {
    id?: boolean
    mealId?: boolean
    name?: boolean
    calories?: boolean
    carbs?: boolean
    fats?: boolean
    proteins?: boolean
    grams?: boolean
  }

  export type FoodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meal?: boolean | MealDefaultArgs<ExtArgs>
  }
  export type FoodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meal?: boolean | MealDefaultArgs<ExtArgs>
  }

  export type $FoodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Food"
    objects: {
      meal: Prisma.$MealPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      mealId: number
      name: string
      calories: number
      carbs: number
      fats: number
      proteins: number
      grams: number
    }, ExtArgs["result"]["food"]>
    composites: {}
  }

  type FoodGetPayload<S extends boolean | null | undefined | FoodDefaultArgs> = $Result.GetResult<Prisma.$FoodPayload, S>

  type FoodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FoodFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FoodCountAggregateInputType | true
    }

  export interface FoodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Food'], meta: { name: 'Food' } }
    /**
     * Find zero or one Food that matches the filter.
     * @param {FoodFindUniqueArgs} args - Arguments to find a Food
     * @example
     * // Get one Food
     * const food = await prisma.food.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodFindUniqueArgs>(args: SelectSubset<T, FoodFindUniqueArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Food that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FoodFindUniqueOrThrowArgs} args - Arguments to find a Food
     * @example
     * // Get one Food
     * const food = await prisma.food.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Food that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodFindFirstArgs} args - Arguments to find a Food
     * @example
     * // Get one Food
     * const food = await prisma.food.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodFindFirstArgs>(args?: SelectSubset<T, FoodFindFirstArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Food that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodFindFirstOrThrowArgs} args - Arguments to find a Food
     * @example
     * // Get one Food
     * const food = await prisma.food.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Foods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Foods
     * const foods = await prisma.food.findMany()
     * 
     * // Get first 10 Foods
     * const foods = await prisma.food.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodWithIdOnly = await prisma.food.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodFindManyArgs>(args?: SelectSubset<T, FoodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Food.
     * @param {FoodCreateArgs} args - Arguments to create a Food.
     * @example
     * // Create one Food
     * const Food = await prisma.food.create({
     *   data: {
     *     // ... data to create a Food
     *   }
     * })
     * 
     */
    create<T extends FoodCreateArgs>(args: SelectSubset<T, FoodCreateArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Foods.
     * @param {FoodCreateManyArgs} args - Arguments to create many Foods.
     * @example
     * // Create many Foods
     * const food = await prisma.food.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodCreateManyArgs>(args?: SelectSubset<T, FoodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Foods and returns the data saved in the database.
     * @param {FoodCreateManyAndReturnArgs} args - Arguments to create many Foods.
     * @example
     * // Create many Foods
     * const food = await prisma.food.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Foods and only return the `id`
     * const foodWithIdOnly = await prisma.food.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Food.
     * @param {FoodDeleteArgs} args - Arguments to delete one Food.
     * @example
     * // Delete one Food
     * const Food = await prisma.food.delete({
     *   where: {
     *     // ... filter to delete one Food
     *   }
     * })
     * 
     */
    delete<T extends FoodDeleteArgs>(args: SelectSubset<T, FoodDeleteArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Food.
     * @param {FoodUpdateArgs} args - Arguments to update one Food.
     * @example
     * // Update one Food
     * const food = await prisma.food.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodUpdateArgs>(args: SelectSubset<T, FoodUpdateArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Foods.
     * @param {FoodDeleteManyArgs} args - Arguments to filter Foods to delete.
     * @example
     * // Delete a few Foods
     * const { count } = await prisma.food.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodDeleteManyArgs>(args?: SelectSubset<T, FoodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Foods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Foods
     * const food = await prisma.food.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodUpdateManyArgs>(args: SelectSubset<T, FoodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Food.
     * @param {FoodUpsertArgs} args - Arguments to update or create a Food.
     * @example
     * // Update or create a Food
     * const food = await prisma.food.upsert({
     *   create: {
     *     // ... data to create a Food
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Food we want to update
     *   }
     * })
     */
    upsert<T extends FoodUpsertArgs>(args: SelectSubset<T, FoodUpsertArgs<ExtArgs>>): Prisma__FoodClient<$Result.GetResult<Prisma.$FoodPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Foods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCountArgs} args - Arguments to filter Foods to count.
     * @example
     * // Count the number of Foods
     * const count = await prisma.food.count({
     *   where: {
     *     // ... the filter for the Foods we want to count
     *   }
     * })
    **/
    count<T extends FoodCountArgs>(
      args?: Subset<T, FoodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Food.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodAggregateArgs>(args: Subset<T, FoodAggregateArgs>): Prisma.PrismaPromise<GetFoodAggregateType<T>>

    /**
     * Group by Food.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodGroupByArgs['orderBy'] }
        : { orderBy?: FoodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Food model
   */
  readonly fields: FoodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Food.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    meal<T extends MealDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MealDefaultArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Food model
   */ 
  interface FoodFieldRefs {
    readonly id: FieldRef<"Food", 'Int'>
    readonly mealId: FieldRef<"Food", 'Int'>
    readonly name: FieldRef<"Food", 'String'>
    readonly calories: FieldRef<"Food", 'Float'>
    readonly carbs: FieldRef<"Food", 'Float'>
    readonly fats: FieldRef<"Food", 'Float'>
    readonly proteins: FieldRef<"Food", 'Float'>
    readonly grams: FieldRef<"Food", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Food findUnique
   */
  export type FoodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Food to fetch.
     */
    where: FoodWhereUniqueInput
  }

  /**
   * Food findUniqueOrThrow
   */
  export type FoodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Food to fetch.
     */
    where: FoodWhereUniqueInput
  }

  /**
   * Food findFirst
   */
  export type FoodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Food to fetch.
     */
    where?: FoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foods to fetch.
     */
    orderBy?: FoodOrderByWithRelationInput | FoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Foods.
     */
    cursor?: FoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Foods.
     */
    distinct?: FoodScalarFieldEnum | FoodScalarFieldEnum[]
  }

  /**
   * Food findFirstOrThrow
   */
  export type FoodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Food to fetch.
     */
    where?: FoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foods to fetch.
     */
    orderBy?: FoodOrderByWithRelationInput | FoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Foods.
     */
    cursor?: FoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Foods.
     */
    distinct?: FoodScalarFieldEnum | FoodScalarFieldEnum[]
  }

  /**
   * Food findMany
   */
  export type FoodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter, which Foods to fetch.
     */
    where?: FoodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foods to fetch.
     */
    orderBy?: FoodOrderByWithRelationInput | FoodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Foods.
     */
    cursor?: FoodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foods.
     */
    skip?: number
    distinct?: FoodScalarFieldEnum | FoodScalarFieldEnum[]
  }

  /**
   * Food create
   */
  export type FoodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * The data needed to create a Food.
     */
    data: XOR<FoodCreateInput, FoodUncheckedCreateInput>
  }

  /**
   * Food createMany
   */
  export type FoodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Foods.
     */
    data: FoodCreateManyInput | FoodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Food createManyAndReturn
   */
  export type FoodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Foods.
     */
    data: FoodCreateManyInput | FoodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Food update
   */
  export type FoodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * The data needed to update a Food.
     */
    data: XOR<FoodUpdateInput, FoodUncheckedUpdateInput>
    /**
     * Choose, which Food to update.
     */
    where: FoodWhereUniqueInput
  }

  /**
   * Food updateMany
   */
  export type FoodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Foods.
     */
    data: XOR<FoodUpdateManyMutationInput, FoodUncheckedUpdateManyInput>
    /**
     * Filter which Foods to update
     */
    where?: FoodWhereInput
  }

  /**
   * Food upsert
   */
  export type FoodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * The filter to search for the Food to update in case it exists.
     */
    where: FoodWhereUniqueInput
    /**
     * In case the Food found by the `where` argument doesn't exist, create a new Food with this data.
     */
    create: XOR<FoodCreateInput, FoodUncheckedCreateInput>
    /**
     * In case the Food was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodUpdateInput, FoodUncheckedUpdateInput>
  }

  /**
   * Food delete
   */
  export type FoodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
    /**
     * Filter which Food to delete.
     */
    where: FoodWhereUniqueInput
  }

  /**
   * Food deleteMany
   */
  export type FoodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Foods to delete
     */
    where?: FoodWhereInput
  }

  /**
   * Food without action
   */
  export type FoodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Food
     */
    select?: FoodSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodInclude<ExtArgs> | null
  }


  /**
   * Model ProfileWorkoutLikes
   */

  export type AggregateProfileWorkoutLikes = {
    _count: ProfileWorkoutLikesCountAggregateOutputType | null
    _avg: ProfileWorkoutLikesAvgAggregateOutputType | null
    _sum: ProfileWorkoutLikesSumAggregateOutputType | null
    _min: ProfileWorkoutLikesMinAggregateOutputType | null
    _max: ProfileWorkoutLikesMaxAggregateOutputType | null
  }

  export type ProfileWorkoutLikesAvgAggregateOutputType = {
    id: number | null
    profileId: number | null
    workoutId: number | null
  }

  export type ProfileWorkoutLikesSumAggregateOutputType = {
    id: number | null
    profileId: number | null
    workoutId: number | null
  }

  export type ProfileWorkoutLikesMinAggregateOutputType = {
    id: number | null
    profileId: number | null
    workoutId: number | null
  }

  export type ProfileWorkoutLikesMaxAggregateOutputType = {
    id: number | null
    profileId: number | null
    workoutId: number | null
  }

  export type ProfileWorkoutLikesCountAggregateOutputType = {
    id: number
    profileId: number
    workoutId: number
    _all: number
  }


  export type ProfileWorkoutLikesAvgAggregateInputType = {
    id?: true
    profileId?: true
    workoutId?: true
  }

  export type ProfileWorkoutLikesSumAggregateInputType = {
    id?: true
    profileId?: true
    workoutId?: true
  }

  export type ProfileWorkoutLikesMinAggregateInputType = {
    id?: true
    profileId?: true
    workoutId?: true
  }

  export type ProfileWorkoutLikesMaxAggregateInputType = {
    id?: true
    profileId?: true
    workoutId?: true
  }

  export type ProfileWorkoutLikesCountAggregateInputType = {
    id?: true
    profileId?: true
    workoutId?: true
    _all?: true
  }

  export type ProfileWorkoutLikesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileWorkoutLikes to aggregate.
     */
    where?: ProfileWorkoutLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileWorkoutLikes to fetch.
     */
    orderBy?: ProfileWorkoutLikesOrderByWithRelationInput | ProfileWorkoutLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWorkoutLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileWorkoutLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileWorkoutLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileWorkoutLikes
    **/
    _count?: true | ProfileWorkoutLikesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileWorkoutLikesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileWorkoutLikesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileWorkoutLikesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileWorkoutLikesMaxAggregateInputType
  }

  export type GetProfileWorkoutLikesAggregateType<T extends ProfileWorkoutLikesAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileWorkoutLikes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileWorkoutLikes[P]>
      : GetScalarType<T[P], AggregateProfileWorkoutLikes[P]>
  }




  export type ProfileWorkoutLikesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWorkoutLikesWhereInput
    orderBy?: ProfileWorkoutLikesOrderByWithAggregationInput | ProfileWorkoutLikesOrderByWithAggregationInput[]
    by: ProfileWorkoutLikesScalarFieldEnum[] | ProfileWorkoutLikesScalarFieldEnum
    having?: ProfileWorkoutLikesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileWorkoutLikesCountAggregateInputType | true
    _avg?: ProfileWorkoutLikesAvgAggregateInputType
    _sum?: ProfileWorkoutLikesSumAggregateInputType
    _min?: ProfileWorkoutLikesMinAggregateInputType
    _max?: ProfileWorkoutLikesMaxAggregateInputType
  }

  export type ProfileWorkoutLikesGroupByOutputType = {
    id: number
    profileId: number | null
    workoutId: number | null
    _count: ProfileWorkoutLikesCountAggregateOutputType | null
    _avg: ProfileWorkoutLikesAvgAggregateOutputType | null
    _sum: ProfileWorkoutLikesSumAggregateOutputType | null
    _min: ProfileWorkoutLikesMinAggregateOutputType | null
    _max: ProfileWorkoutLikesMaxAggregateOutputType | null
  }

  type GetProfileWorkoutLikesGroupByPayload<T extends ProfileWorkoutLikesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileWorkoutLikesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileWorkoutLikesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileWorkoutLikesGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileWorkoutLikesGroupByOutputType[P]>
        }
      >
    >


  export type ProfileWorkoutLikesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    workoutId?: boolean
    profile?: boolean | ProfileWorkoutLikes$profileArgs<ExtArgs>
    workout?: boolean | ProfileWorkoutLikes$workoutArgs<ExtArgs>
  }, ExtArgs["result"]["profileWorkoutLikes"]>

  export type ProfileWorkoutLikesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    workoutId?: boolean
    profile?: boolean | ProfileWorkoutLikes$profileArgs<ExtArgs>
    workout?: boolean | ProfileWorkoutLikes$workoutArgs<ExtArgs>
  }, ExtArgs["result"]["profileWorkoutLikes"]>

  export type ProfileWorkoutLikesSelectScalar = {
    id?: boolean
    profileId?: boolean
    workoutId?: boolean
  }

  export type ProfileWorkoutLikesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileWorkoutLikes$profileArgs<ExtArgs>
    workout?: boolean | ProfileWorkoutLikes$workoutArgs<ExtArgs>
  }
  export type ProfileWorkoutLikesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileWorkoutLikes$profileArgs<ExtArgs>
    workout?: boolean | ProfileWorkoutLikes$workoutArgs<ExtArgs>
  }

  export type $ProfileWorkoutLikesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileWorkoutLikes"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      workout: Prisma.$WorkoutPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      profileId: number | null
      workoutId: number | null
    }, ExtArgs["result"]["profileWorkoutLikes"]>
    composites: {}
  }

  type ProfileWorkoutLikesGetPayload<S extends boolean | null | undefined | ProfileWorkoutLikesDefaultArgs> = $Result.GetResult<Prisma.$ProfileWorkoutLikesPayload, S>

  type ProfileWorkoutLikesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileWorkoutLikesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileWorkoutLikesCountAggregateInputType | true
    }

  export interface ProfileWorkoutLikesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileWorkoutLikes'], meta: { name: 'ProfileWorkoutLikes' } }
    /**
     * Find zero or one ProfileWorkoutLikes that matches the filter.
     * @param {ProfileWorkoutLikesFindUniqueArgs} args - Arguments to find a ProfileWorkoutLikes
     * @example
     * // Get one ProfileWorkoutLikes
     * const profileWorkoutLikes = await prisma.profileWorkoutLikes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileWorkoutLikesFindUniqueArgs>(args: SelectSubset<T, ProfileWorkoutLikesFindUniqueArgs<ExtArgs>>): Prisma__ProfileWorkoutLikesClient<$Result.GetResult<Prisma.$ProfileWorkoutLikesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProfileWorkoutLikes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileWorkoutLikesFindUniqueOrThrowArgs} args - Arguments to find a ProfileWorkoutLikes
     * @example
     * // Get one ProfileWorkoutLikes
     * const profileWorkoutLikes = await prisma.profileWorkoutLikes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileWorkoutLikesFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileWorkoutLikesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileWorkoutLikesClient<$Result.GetResult<Prisma.$ProfileWorkoutLikesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProfileWorkoutLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileWorkoutLikesFindFirstArgs} args - Arguments to find a ProfileWorkoutLikes
     * @example
     * // Get one ProfileWorkoutLikes
     * const profileWorkoutLikes = await prisma.profileWorkoutLikes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileWorkoutLikesFindFirstArgs>(args?: SelectSubset<T, ProfileWorkoutLikesFindFirstArgs<ExtArgs>>): Prisma__ProfileWorkoutLikesClient<$Result.GetResult<Prisma.$ProfileWorkoutLikesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProfileWorkoutLikes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileWorkoutLikesFindFirstOrThrowArgs} args - Arguments to find a ProfileWorkoutLikes
     * @example
     * // Get one ProfileWorkoutLikes
     * const profileWorkoutLikes = await prisma.profileWorkoutLikes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileWorkoutLikesFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileWorkoutLikesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileWorkoutLikesClient<$Result.GetResult<Prisma.$ProfileWorkoutLikesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProfileWorkoutLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileWorkoutLikesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileWorkoutLikes
     * const profileWorkoutLikes = await prisma.profileWorkoutLikes.findMany()
     * 
     * // Get first 10 ProfileWorkoutLikes
     * const profileWorkoutLikes = await prisma.profileWorkoutLikes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWorkoutLikesWithIdOnly = await prisma.profileWorkoutLikes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileWorkoutLikesFindManyArgs>(args?: SelectSubset<T, ProfileWorkoutLikesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileWorkoutLikesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProfileWorkoutLikes.
     * @param {ProfileWorkoutLikesCreateArgs} args - Arguments to create a ProfileWorkoutLikes.
     * @example
     * // Create one ProfileWorkoutLikes
     * const ProfileWorkoutLikes = await prisma.profileWorkoutLikes.create({
     *   data: {
     *     // ... data to create a ProfileWorkoutLikes
     *   }
     * })
     * 
     */
    create<T extends ProfileWorkoutLikesCreateArgs>(args: SelectSubset<T, ProfileWorkoutLikesCreateArgs<ExtArgs>>): Prisma__ProfileWorkoutLikesClient<$Result.GetResult<Prisma.$ProfileWorkoutLikesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProfileWorkoutLikes.
     * @param {ProfileWorkoutLikesCreateManyArgs} args - Arguments to create many ProfileWorkoutLikes.
     * @example
     * // Create many ProfileWorkoutLikes
     * const profileWorkoutLikes = await prisma.profileWorkoutLikes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileWorkoutLikesCreateManyArgs>(args?: SelectSubset<T, ProfileWorkoutLikesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfileWorkoutLikes and returns the data saved in the database.
     * @param {ProfileWorkoutLikesCreateManyAndReturnArgs} args - Arguments to create many ProfileWorkoutLikes.
     * @example
     * // Create many ProfileWorkoutLikes
     * const profileWorkoutLikes = await prisma.profileWorkoutLikes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfileWorkoutLikes and only return the `id`
     * const profileWorkoutLikesWithIdOnly = await prisma.profileWorkoutLikes.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileWorkoutLikesCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileWorkoutLikesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileWorkoutLikesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProfileWorkoutLikes.
     * @param {ProfileWorkoutLikesDeleteArgs} args - Arguments to delete one ProfileWorkoutLikes.
     * @example
     * // Delete one ProfileWorkoutLikes
     * const ProfileWorkoutLikes = await prisma.profileWorkoutLikes.delete({
     *   where: {
     *     // ... filter to delete one ProfileWorkoutLikes
     *   }
     * })
     * 
     */
    delete<T extends ProfileWorkoutLikesDeleteArgs>(args: SelectSubset<T, ProfileWorkoutLikesDeleteArgs<ExtArgs>>): Prisma__ProfileWorkoutLikesClient<$Result.GetResult<Prisma.$ProfileWorkoutLikesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProfileWorkoutLikes.
     * @param {ProfileWorkoutLikesUpdateArgs} args - Arguments to update one ProfileWorkoutLikes.
     * @example
     * // Update one ProfileWorkoutLikes
     * const profileWorkoutLikes = await prisma.profileWorkoutLikes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileWorkoutLikesUpdateArgs>(args: SelectSubset<T, ProfileWorkoutLikesUpdateArgs<ExtArgs>>): Prisma__ProfileWorkoutLikesClient<$Result.GetResult<Prisma.$ProfileWorkoutLikesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProfileWorkoutLikes.
     * @param {ProfileWorkoutLikesDeleteManyArgs} args - Arguments to filter ProfileWorkoutLikes to delete.
     * @example
     * // Delete a few ProfileWorkoutLikes
     * const { count } = await prisma.profileWorkoutLikes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileWorkoutLikesDeleteManyArgs>(args?: SelectSubset<T, ProfileWorkoutLikesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileWorkoutLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileWorkoutLikesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileWorkoutLikes
     * const profileWorkoutLikes = await prisma.profileWorkoutLikes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileWorkoutLikesUpdateManyArgs>(args: SelectSubset<T, ProfileWorkoutLikesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProfileWorkoutLikes.
     * @param {ProfileWorkoutLikesUpsertArgs} args - Arguments to update or create a ProfileWorkoutLikes.
     * @example
     * // Update or create a ProfileWorkoutLikes
     * const profileWorkoutLikes = await prisma.profileWorkoutLikes.upsert({
     *   create: {
     *     // ... data to create a ProfileWorkoutLikes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileWorkoutLikes we want to update
     *   }
     * })
     */
    upsert<T extends ProfileWorkoutLikesUpsertArgs>(args: SelectSubset<T, ProfileWorkoutLikesUpsertArgs<ExtArgs>>): Prisma__ProfileWorkoutLikesClient<$Result.GetResult<Prisma.$ProfileWorkoutLikesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProfileWorkoutLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileWorkoutLikesCountArgs} args - Arguments to filter ProfileWorkoutLikes to count.
     * @example
     * // Count the number of ProfileWorkoutLikes
     * const count = await prisma.profileWorkoutLikes.count({
     *   where: {
     *     // ... the filter for the ProfileWorkoutLikes we want to count
     *   }
     * })
    **/
    count<T extends ProfileWorkoutLikesCountArgs>(
      args?: Subset<T, ProfileWorkoutLikesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileWorkoutLikesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileWorkoutLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileWorkoutLikesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileWorkoutLikesAggregateArgs>(args: Subset<T, ProfileWorkoutLikesAggregateArgs>): Prisma.PrismaPromise<GetProfileWorkoutLikesAggregateType<T>>

    /**
     * Group by ProfileWorkoutLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileWorkoutLikesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileWorkoutLikesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileWorkoutLikesGroupByArgs['orderBy'] }
        : { orderBy?: ProfileWorkoutLikesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileWorkoutLikesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileWorkoutLikesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileWorkoutLikes model
   */
  readonly fields: ProfileWorkoutLikesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileWorkoutLikes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileWorkoutLikesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileWorkoutLikes$profileArgs<ExtArgs> = {}>(args?: Subset<T, ProfileWorkoutLikes$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    workout<T extends ProfileWorkoutLikes$workoutArgs<ExtArgs> = {}>(args?: Subset<T, ProfileWorkoutLikes$workoutArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileWorkoutLikes model
   */ 
  interface ProfileWorkoutLikesFieldRefs {
    readonly id: FieldRef<"ProfileWorkoutLikes", 'Int'>
    readonly profileId: FieldRef<"ProfileWorkoutLikes", 'Int'>
    readonly workoutId: FieldRef<"ProfileWorkoutLikes", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProfileWorkoutLikes findUnique
   */
  export type ProfileWorkoutLikesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutLikes
     */
    select?: ProfileWorkoutLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutLikesInclude<ExtArgs> | null
    /**
     * Filter, which ProfileWorkoutLikes to fetch.
     */
    where: ProfileWorkoutLikesWhereUniqueInput
  }

  /**
   * ProfileWorkoutLikes findUniqueOrThrow
   */
  export type ProfileWorkoutLikesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutLikes
     */
    select?: ProfileWorkoutLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutLikesInclude<ExtArgs> | null
    /**
     * Filter, which ProfileWorkoutLikes to fetch.
     */
    where: ProfileWorkoutLikesWhereUniqueInput
  }

  /**
   * ProfileWorkoutLikes findFirst
   */
  export type ProfileWorkoutLikesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutLikes
     */
    select?: ProfileWorkoutLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutLikesInclude<ExtArgs> | null
    /**
     * Filter, which ProfileWorkoutLikes to fetch.
     */
    where?: ProfileWorkoutLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileWorkoutLikes to fetch.
     */
    orderBy?: ProfileWorkoutLikesOrderByWithRelationInput | ProfileWorkoutLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileWorkoutLikes.
     */
    cursor?: ProfileWorkoutLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileWorkoutLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileWorkoutLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileWorkoutLikes.
     */
    distinct?: ProfileWorkoutLikesScalarFieldEnum | ProfileWorkoutLikesScalarFieldEnum[]
  }

  /**
   * ProfileWorkoutLikes findFirstOrThrow
   */
  export type ProfileWorkoutLikesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutLikes
     */
    select?: ProfileWorkoutLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutLikesInclude<ExtArgs> | null
    /**
     * Filter, which ProfileWorkoutLikes to fetch.
     */
    where?: ProfileWorkoutLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileWorkoutLikes to fetch.
     */
    orderBy?: ProfileWorkoutLikesOrderByWithRelationInput | ProfileWorkoutLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileWorkoutLikes.
     */
    cursor?: ProfileWorkoutLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileWorkoutLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileWorkoutLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileWorkoutLikes.
     */
    distinct?: ProfileWorkoutLikesScalarFieldEnum | ProfileWorkoutLikesScalarFieldEnum[]
  }

  /**
   * ProfileWorkoutLikes findMany
   */
  export type ProfileWorkoutLikesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutLikes
     */
    select?: ProfileWorkoutLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutLikesInclude<ExtArgs> | null
    /**
     * Filter, which ProfileWorkoutLikes to fetch.
     */
    where?: ProfileWorkoutLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileWorkoutLikes to fetch.
     */
    orderBy?: ProfileWorkoutLikesOrderByWithRelationInput | ProfileWorkoutLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileWorkoutLikes.
     */
    cursor?: ProfileWorkoutLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileWorkoutLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileWorkoutLikes.
     */
    skip?: number
    distinct?: ProfileWorkoutLikesScalarFieldEnum | ProfileWorkoutLikesScalarFieldEnum[]
  }

  /**
   * ProfileWorkoutLikes create
   */
  export type ProfileWorkoutLikesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutLikes
     */
    select?: ProfileWorkoutLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutLikesInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileWorkoutLikes.
     */
    data?: XOR<ProfileWorkoutLikesCreateInput, ProfileWorkoutLikesUncheckedCreateInput>
  }

  /**
   * ProfileWorkoutLikes createMany
   */
  export type ProfileWorkoutLikesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileWorkoutLikes.
     */
    data: ProfileWorkoutLikesCreateManyInput | ProfileWorkoutLikesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileWorkoutLikes createManyAndReturn
   */
  export type ProfileWorkoutLikesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutLikes
     */
    select?: ProfileWorkoutLikesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProfileWorkoutLikes.
     */
    data: ProfileWorkoutLikesCreateManyInput | ProfileWorkoutLikesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutLikesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileWorkoutLikes update
   */
  export type ProfileWorkoutLikesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutLikes
     */
    select?: ProfileWorkoutLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutLikesInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileWorkoutLikes.
     */
    data: XOR<ProfileWorkoutLikesUpdateInput, ProfileWorkoutLikesUncheckedUpdateInput>
    /**
     * Choose, which ProfileWorkoutLikes to update.
     */
    where: ProfileWorkoutLikesWhereUniqueInput
  }

  /**
   * ProfileWorkoutLikes updateMany
   */
  export type ProfileWorkoutLikesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileWorkoutLikes.
     */
    data: XOR<ProfileWorkoutLikesUpdateManyMutationInput, ProfileWorkoutLikesUncheckedUpdateManyInput>
    /**
     * Filter which ProfileWorkoutLikes to update
     */
    where?: ProfileWorkoutLikesWhereInput
  }

  /**
   * ProfileWorkoutLikes upsert
   */
  export type ProfileWorkoutLikesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutLikes
     */
    select?: ProfileWorkoutLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutLikesInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileWorkoutLikes to update in case it exists.
     */
    where: ProfileWorkoutLikesWhereUniqueInput
    /**
     * In case the ProfileWorkoutLikes found by the `where` argument doesn't exist, create a new ProfileWorkoutLikes with this data.
     */
    create: XOR<ProfileWorkoutLikesCreateInput, ProfileWorkoutLikesUncheckedCreateInput>
    /**
     * In case the ProfileWorkoutLikes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileWorkoutLikesUpdateInput, ProfileWorkoutLikesUncheckedUpdateInput>
  }

  /**
   * ProfileWorkoutLikes delete
   */
  export type ProfileWorkoutLikesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutLikes
     */
    select?: ProfileWorkoutLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutLikesInclude<ExtArgs> | null
    /**
     * Filter which ProfileWorkoutLikes to delete.
     */
    where: ProfileWorkoutLikesWhereUniqueInput
  }

  /**
   * ProfileWorkoutLikes deleteMany
   */
  export type ProfileWorkoutLikesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileWorkoutLikes to delete
     */
    where?: ProfileWorkoutLikesWhereInput
  }

  /**
   * ProfileWorkoutLikes.profile
   */
  export type ProfileWorkoutLikes$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * ProfileWorkoutLikes.workout
   */
  export type ProfileWorkoutLikes$workoutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    where?: WorkoutWhereInput
  }

  /**
   * ProfileWorkoutLikes without action
   */
  export type ProfileWorkoutLikesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutLikes
     */
    select?: ProfileWorkoutLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutLikesInclude<ExtArgs> | null
  }


  /**
   * Model ProfileWorkoutTouched
   */

  export type AggregateProfileWorkoutTouched = {
    _count: ProfileWorkoutTouchedCountAggregateOutputType | null
    _avg: ProfileWorkoutTouchedAvgAggregateOutputType | null
    _sum: ProfileWorkoutTouchedSumAggregateOutputType | null
    _min: ProfileWorkoutTouchedMinAggregateOutputType | null
    _max: ProfileWorkoutTouchedMaxAggregateOutputType | null
  }

  export type ProfileWorkoutTouchedAvgAggregateOutputType = {
    id: number | null
    profileId: number | null
    workoutId: number | null
  }

  export type ProfileWorkoutTouchedSumAggregateOutputType = {
    id: number | null
    profileId: number | null
    workoutId: number | null
  }

  export type ProfileWorkoutTouchedMinAggregateOutputType = {
    id: number | null
    profileId: number | null
    workoutId: number | null
  }

  export type ProfileWorkoutTouchedMaxAggregateOutputType = {
    id: number | null
    profileId: number | null
    workoutId: number | null
  }

  export type ProfileWorkoutTouchedCountAggregateOutputType = {
    id: number
    profileId: number
    workoutId: number
    _all: number
  }


  export type ProfileWorkoutTouchedAvgAggregateInputType = {
    id?: true
    profileId?: true
    workoutId?: true
  }

  export type ProfileWorkoutTouchedSumAggregateInputType = {
    id?: true
    profileId?: true
    workoutId?: true
  }

  export type ProfileWorkoutTouchedMinAggregateInputType = {
    id?: true
    profileId?: true
    workoutId?: true
  }

  export type ProfileWorkoutTouchedMaxAggregateInputType = {
    id?: true
    profileId?: true
    workoutId?: true
  }

  export type ProfileWorkoutTouchedCountAggregateInputType = {
    id?: true
    profileId?: true
    workoutId?: true
    _all?: true
  }

  export type ProfileWorkoutTouchedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileWorkoutTouched to aggregate.
     */
    where?: ProfileWorkoutTouchedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileWorkoutToucheds to fetch.
     */
    orderBy?: ProfileWorkoutTouchedOrderByWithRelationInput | ProfileWorkoutTouchedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWorkoutTouchedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileWorkoutToucheds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileWorkoutToucheds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileWorkoutToucheds
    **/
    _count?: true | ProfileWorkoutTouchedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileWorkoutTouchedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileWorkoutTouchedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileWorkoutTouchedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileWorkoutTouchedMaxAggregateInputType
  }

  export type GetProfileWorkoutTouchedAggregateType<T extends ProfileWorkoutTouchedAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileWorkoutTouched]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileWorkoutTouched[P]>
      : GetScalarType<T[P], AggregateProfileWorkoutTouched[P]>
  }




  export type ProfileWorkoutTouchedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWorkoutTouchedWhereInput
    orderBy?: ProfileWorkoutTouchedOrderByWithAggregationInput | ProfileWorkoutTouchedOrderByWithAggregationInput[]
    by: ProfileWorkoutTouchedScalarFieldEnum[] | ProfileWorkoutTouchedScalarFieldEnum
    having?: ProfileWorkoutTouchedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileWorkoutTouchedCountAggregateInputType | true
    _avg?: ProfileWorkoutTouchedAvgAggregateInputType
    _sum?: ProfileWorkoutTouchedSumAggregateInputType
    _min?: ProfileWorkoutTouchedMinAggregateInputType
    _max?: ProfileWorkoutTouchedMaxAggregateInputType
  }

  export type ProfileWorkoutTouchedGroupByOutputType = {
    id: number
    profileId: number | null
    workoutId: number | null
    _count: ProfileWorkoutTouchedCountAggregateOutputType | null
    _avg: ProfileWorkoutTouchedAvgAggregateOutputType | null
    _sum: ProfileWorkoutTouchedSumAggregateOutputType | null
    _min: ProfileWorkoutTouchedMinAggregateOutputType | null
    _max: ProfileWorkoutTouchedMaxAggregateOutputType | null
  }

  type GetProfileWorkoutTouchedGroupByPayload<T extends ProfileWorkoutTouchedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileWorkoutTouchedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileWorkoutTouchedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileWorkoutTouchedGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileWorkoutTouchedGroupByOutputType[P]>
        }
      >
    >


  export type ProfileWorkoutTouchedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    workoutId?: boolean
    profile?: boolean | ProfileWorkoutTouched$profileArgs<ExtArgs>
    workout?: boolean | ProfileWorkoutTouched$workoutArgs<ExtArgs>
  }, ExtArgs["result"]["profileWorkoutTouched"]>

  export type ProfileWorkoutTouchedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    workoutId?: boolean
    profile?: boolean | ProfileWorkoutTouched$profileArgs<ExtArgs>
    workout?: boolean | ProfileWorkoutTouched$workoutArgs<ExtArgs>
  }, ExtArgs["result"]["profileWorkoutTouched"]>

  export type ProfileWorkoutTouchedSelectScalar = {
    id?: boolean
    profileId?: boolean
    workoutId?: boolean
  }

  export type ProfileWorkoutTouchedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileWorkoutTouched$profileArgs<ExtArgs>
    workout?: boolean | ProfileWorkoutTouched$workoutArgs<ExtArgs>
  }
  export type ProfileWorkoutTouchedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileWorkoutTouched$profileArgs<ExtArgs>
    workout?: boolean | ProfileWorkoutTouched$workoutArgs<ExtArgs>
  }

  export type $ProfileWorkoutTouchedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileWorkoutTouched"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      workout: Prisma.$WorkoutPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      profileId: number | null
      workoutId: number | null
    }, ExtArgs["result"]["profileWorkoutTouched"]>
    composites: {}
  }

  type ProfileWorkoutTouchedGetPayload<S extends boolean | null | undefined | ProfileWorkoutTouchedDefaultArgs> = $Result.GetResult<Prisma.$ProfileWorkoutTouchedPayload, S>

  type ProfileWorkoutTouchedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileWorkoutTouchedFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileWorkoutTouchedCountAggregateInputType | true
    }

  export interface ProfileWorkoutTouchedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileWorkoutTouched'], meta: { name: 'ProfileWorkoutTouched' } }
    /**
     * Find zero or one ProfileWorkoutTouched that matches the filter.
     * @param {ProfileWorkoutTouchedFindUniqueArgs} args - Arguments to find a ProfileWorkoutTouched
     * @example
     * // Get one ProfileWorkoutTouched
     * const profileWorkoutTouched = await prisma.profileWorkoutTouched.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileWorkoutTouchedFindUniqueArgs>(args: SelectSubset<T, ProfileWorkoutTouchedFindUniqueArgs<ExtArgs>>): Prisma__ProfileWorkoutTouchedClient<$Result.GetResult<Prisma.$ProfileWorkoutTouchedPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProfileWorkoutTouched that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileWorkoutTouchedFindUniqueOrThrowArgs} args - Arguments to find a ProfileWorkoutTouched
     * @example
     * // Get one ProfileWorkoutTouched
     * const profileWorkoutTouched = await prisma.profileWorkoutTouched.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileWorkoutTouchedFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileWorkoutTouchedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileWorkoutTouchedClient<$Result.GetResult<Prisma.$ProfileWorkoutTouchedPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProfileWorkoutTouched that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileWorkoutTouchedFindFirstArgs} args - Arguments to find a ProfileWorkoutTouched
     * @example
     * // Get one ProfileWorkoutTouched
     * const profileWorkoutTouched = await prisma.profileWorkoutTouched.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileWorkoutTouchedFindFirstArgs>(args?: SelectSubset<T, ProfileWorkoutTouchedFindFirstArgs<ExtArgs>>): Prisma__ProfileWorkoutTouchedClient<$Result.GetResult<Prisma.$ProfileWorkoutTouchedPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProfileWorkoutTouched that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileWorkoutTouchedFindFirstOrThrowArgs} args - Arguments to find a ProfileWorkoutTouched
     * @example
     * // Get one ProfileWorkoutTouched
     * const profileWorkoutTouched = await prisma.profileWorkoutTouched.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileWorkoutTouchedFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileWorkoutTouchedFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileWorkoutTouchedClient<$Result.GetResult<Prisma.$ProfileWorkoutTouchedPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProfileWorkoutToucheds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileWorkoutTouchedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileWorkoutToucheds
     * const profileWorkoutToucheds = await prisma.profileWorkoutTouched.findMany()
     * 
     * // Get first 10 ProfileWorkoutToucheds
     * const profileWorkoutToucheds = await prisma.profileWorkoutTouched.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWorkoutTouchedWithIdOnly = await prisma.profileWorkoutTouched.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileWorkoutTouchedFindManyArgs>(args?: SelectSubset<T, ProfileWorkoutTouchedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileWorkoutTouchedPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProfileWorkoutTouched.
     * @param {ProfileWorkoutTouchedCreateArgs} args - Arguments to create a ProfileWorkoutTouched.
     * @example
     * // Create one ProfileWorkoutTouched
     * const ProfileWorkoutTouched = await prisma.profileWorkoutTouched.create({
     *   data: {
     *     // ... data to create a ProfileWorkoutTouched
     *   }
     * })
     * 
     */
    create<T extends ProfileWorkoutTouchedCreateArgs>(args: SelectSubset<T, ProfileWorkoutTouchedCreateArgs<ExtArgs>>): Prisma__ProfileWorkoutTouchedClient<$Result.GetResult<Prisma.$ProfileWorkoutTouchedPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProfileWorkoutToucheds.
     * @param {ProfileWorkoutTouchedCreateManyArgs} args - Arguments to create many ProfileWorkoutToucheds.
     * @example
     * // Create many ProfileWorkoutToucheds
     * const profileWorkoutTouched = await prisma.profileWorkoutTouched.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileWorkoutTouchedCreateManyArgs>(args?: SelectSubset<T, ProfileWorkoutTouchedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfileWorkoutToucheds and returns the data saved in the database.
     * @param {ProfileWorkoutTouchedCreateManyAndReturnArgs} args - Arguments to create many ProfileWorkoutToucheds.
     * @example
     * // Create many ProfileWorkoutToucheds
     * const profileWorkoutTouched = await prisma.profileWorkoutTouched.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfileWorkoutToucheds and only return the `id`
     * const profileWorkoutTouchedWithIdOnly = await prisma.profileWorkoutTouched.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileWorkoutTouchedCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileWorkoutTouchedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileWorkoutTouchedPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProfileWorkoutTouched.
     * @param {ProfileWorkoutTouchedDeleteArgs} args - Arguments to delete one ProfileWorkoutTouched.
     * @example
     * // Delete one ProfileWorkoutTouched
     * const ProfileWorkoutTouched = await prisma.profileWorkoutTouched.delete({
     *   where: {
     *     // ... filter to delete one ProfileWorkoutTouched
     *   }
     * })
     * 
     */
    delete<T extends ProfileWorkoutTouchedDeleteArgs>(args: SelectSubset<T, ProfileWorkoutTouchedDeleteArgs<ExtArgs>>): Prisma__ProfileWorkoutTouchedClient<$Result.GetResult<Prisma.$ProfileWorkoutTouchedPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProfileWorkoutTouched.
     * @param {ProfileWorkoutTouchedUpdateArgs} args - Arguments to update one ProfileWorkoutTouched.
     * @example
     * // Update one ProfileWorkoutTouched
     * const profileWorkoutTouched = await prisma.profileWorkoutTouched.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileWorkoutTouchedUpdateArgs>(args: SelectSubset<T, ProfileWorkoutTouchedUpdateArgs<ExtArgs>>): Prisma__ProfileWorkoutTouchedClient<$Result.GetResult<Prisma.$ProfileWorkoutTouchedPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProfileWorkoutToucheds.
     * @param {ProfileWorkoutTouchedDeleteManyArgs} args - Arguments to filter ProfileWorkoutToucheds to delete.
     * @example
     * // Delete a few ProfileWorkoutToucheds
     * const { count } = await prisma.profileWorkoutTouched.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileWorkoutTouchedDeleteManyArgs>(args?: SelectSubset<T, ProfileWorkoutTouchedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileWorkoutToucheds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileWorkoutTouchedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileWorkoutToucheds
     * const profileWorkoutTouched = await prisma.profileWorkoutTouched.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileWorkoutTouchedUpdateManyArgs>(args: SelectSubset<T, ProfileWorkoutTouchedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProfileWorkoutTouched.
     * @param {ProfileWorkoutTouchedUpsertArgs} args - Arguments to update or create a ProfileWorkoutTouched.
     * @example
     * // Update or create a ProfileWorkoutTouched
     * const profileWorkoutTouched = await prisma.profileWorkoutTouched.upsert({
     *   create: {
     *     // ... data to create a ProfileWorkoutTouched
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileWorkoutTouched we want to update
     *   }
     * })
     */
    upsert<T extends ProfileWorkoutTouchedUpsertArgs>(args: SelectSubset<T, ProfileWorkoutTouchedUpsertArgs<ExtArgs>>): Prisma__ProfileWorkoutTouchedClient<$Result.GetResult<Prisma.$ProfileWorkoutTouchedPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProfileWorkoutToucheds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileWorkoutTouchedCountArgs} args - Arguments to filter ProfileWorkoutToucheds to count.
     * @example
     * // Count the number of ProfileWorkoutToucheds
     * const count = await prisma.profileWorkoutTouched.count({
     *   where: {
     *     // ... the filter for the ProfileWorkoutToucheds we want to count
     *   }
     * })
    **/
    count<T extends ProfileWorkoutTouchedCountArgs>(
      args?: Subset<T, ProfileWorkoutTouchedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileWorkoutTouchedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileWorkoutTouched.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileWorkoutTouchedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileWorkoutTouchedAggregateArgs>(args: Subset<T, ProfileWorkoutTouchedAggregateArgs>): Prisma.PrismaPromise<GetProfileWorkoutTouchedAggregateType<T>>

    /**
     * Group by ProfileWorkoutTouched.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileWorkoutTouchedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileWorkoutTouchedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileWorkoutTouchedGroupByArgs['orderBy'] }
        : { orderBy?: ProfileWorkoutTouchedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileWorkoutTouchedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileWorkoutTouchedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileWorkoutTouched model
   */
  readonly fields: ProfileWorkoutTouchedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileWorkoutTouched.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileWorkoutTouchedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileWorkoutTouched$profileArgs<ExtArgs> = {}>(args?: Subset<T, ProfileWorkoutTouched$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    workout<T extends ProfileWorkoutTouched$workoutArgs<ExtArgs> = {}>(args?: Subset<T, ProfileWorkoutTouched$workoutArgs<ExtArgs>>): Prisma__WorkoutClient<$Result.GetResult<Prisma.$WorkoutPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileWorkoutTouched model
   */ 
  interface ProfileWorkoutTouchedFieldRefs {
    readonly id: FieldRef<"ProfileWorkoutTouched", 'Int'>
    readonly profileId: FieldRef<"ProfileWorkoutTouched", 'Int'>
    readonly workoutId: FieldRef<"ProfileWorkoutTouched", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProfileWorkoutTouched findUnique
   */
  export type ProfileWorkoutTouchedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutTouched
     */
    select?: ProfileWorkoutTouchedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutTouchedInclude<ExtArgs> | null
    /**
     * Filter, which ProfileWorkoutTouched to fetch.
     */
    where: ProfileWorkoutTouchedWhereUniqueInput
  }

  /**
   * ProfileWorkoutTouched findUniqueOrThrow
   */
  export type ProfileWorkoutTouchedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutTouched
     */
    select?: ProfileWorkoutTouchedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutTouchedInclude<ExtArgs> | null
    /**
     * Filter, which ProfileWorkoutTouched to fetch.
     */
    where: ProfileWorkoutTouchedWhereUniqueInput
  }

  /**
   * ProfileWorkoutTouched findFirst
   */
  export type ProfileWorkoutTouchedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutTouched
     */
    select?: ProfileWorkoutTouchedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutTouchedInclude<ExtArgs> | null
    /**
     * Filter, which ProfileWorkoutTouched to fetch.
     */
    where?: ProfileWorkoutTouchedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileWorkoutToucheds to fetch.
     */
    orderBy?: ProfileWorkoutTouchedOrderByWithRelationInput | ProfileWorkoutTouchedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileWorkoutToucheds.
     */
    cursor?: ProfileWorkoutTouchedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileWorkoutToucheds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileWorkoutToucheds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileWorkoutToucheds.
     */
    distinct?: ProfileWorkoutTouchedScalarFieldEnum | ProfileWorkoutTouchedScalarFieldEnum[]
  }

  /**
   * ProfileWorkoutTouched findFirstOrThrow
   */
  export type ProfileWorkoutTouchedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutTouched
     */
    select?: ProfileWorkoutTouchedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutTouchedInclude<ExtArgs> | null
    /**
     * Filter, which ProfileWorkoutTouched to fetch.
     */
    where?: ProfileWorkoutTouchedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileWorkoutToucheds to fetch.
     */
    orderBy?: ProfileWorkoutTouchedOrderByWithRelationInput | ProfileWorkoutTouchedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileWorkoutToucheds.
     */
    cursor?: ProfileWorkoutTouchedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileWorkoutToucheds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileWorkoutToucheds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileWorkoutToucheds.
     */
    distinct?: ProfileWorkoutTouchedScalarFieldEnum | ProfileWorkoutTouchedScalarFieldEnum[]
  }

  /**
   * ProfileWorkoutTouched findMany
   */
  export type ProfileWorkoutTouchedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutTouched
     */
    select?: ProfileWorkoutTouchedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutTouchedInclude<ExtArgs> | null
    /**
     * Filter, which ProfileWorkoutToucheds to fetch.
     */
    where?: ProfileWorkoutTouchedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileWorkoutToucheds to fetch.
     */
    orderBy?: ProfileWorkoutTouchedOrderByWithRelationInput | ProfileWorkoutTouchedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileWorkoutToucheds.
     */
    cursor?: ProfileWorkoutTouchedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileWorkoutToucheds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileWorkoutToucheds.
     */
    skip?: number
    distinct?: ProfileWorkoutTouchedScalarFieldEnum | ProfileWorkoutTouchedScalarFieldEnum[]
  }

  /**
   * ProfileWorkoutTouched create
   */
  export type ProfileWorkoutTouchedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutTouched
     */
    select?: ProfileWorkoutTouchedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutTouchedInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileWorkoutTouched.
     */
    data?: XOR<ProfileWorkoutTouchedCreateInput, ProfileWorkoutTouchedUncheckedCreateInput>
  }

  /**
   * ProfileWorkoutTouched createMany
   */
  export type ProfileWorkoutTouchedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileWorkoutToucheds.
     */
    data: ProfileWorkoutTouchedCreateManyInput | ProfileWorkoutTouchedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileWorkoutTouched createManyAndReturn
   */
  export type ProfileWorkoutTouchedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutTouched
     */
    select?: ProfileWorkoutTouchedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProfileWorkoutToucheds.
     */
    data: ProfileWorkoutTouchedCreateManyInput | ProfileWorkoutTouchedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutTouchedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileWorkoutTouched update
   */
  export type ProfileWorkoutTouchedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutTouched
     */
    select?: ProfileWorkoutTouchedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutTouchedInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileWorkoutTouched.
     */
    data: XOR<ProfileWorkoutTouchedUpdateInput, ProfileWorkoutTouchedUncheckedUpdateInput>
    /**
     * Choose, which ProfileWorkoutTouched to update.
     */
    where: ProfileWorkoutTouchedWhereUniqueInput
  }

  /**
   * ProfileWorkoutTouched updateMany
   */
  export type ProfileWorkoutTouchedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileWorkoutToucheds.
     */
    data: XOR<ProfileWorkoutTouchedUpdateManyMutationInput, ProfileWorkoutTouchedUncheckedUpdateManyInput>
    /**
     * Filter which ProfileWorkoutToucheds to update
     */
    where?: ProfileWorkoutTouchedWhereInput
  }

  /**
   * ProfileWorkoutTouched upsert
   */
  export type ProfileWorkoutTouchedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutTouched
     */
    select?: ProfileWorkoutTouchedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutTouchedInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileWorkoutTouched to update in case it exists.
     */
    where: ProfileWorkoutTouchedWhereUniqueInput
    /**
     * In case the ProfileWorkoutTouched found by the `where` argument doesn't exist, create a new ProfileWorkoutTouched with this data.
     */
    create: XOR<ProfileWorkoutTouchedCreateInput, ProfileWorkoutTouchedUncheckedCreateInput>
    /**
     * In case the ProfileWorkoutTouched was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileWorkoutTouchedUpdateInput, ProfileWorkoutTouchedUncheckedUpdateInput>
  }

  /**
   * ProfileWorkoutTouched delete
   */
  export type ProfileWorkoutTouchedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutTouched
     */
    select?: ProfileWorkoutTouchedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutTouchedInclude<ExtArgs> | null
    /**
     * Filter which ProfileWorkoutTouched to delete.
     */
    where: ProfileWorkoutTouchedWhereUniqueInput
  }

  /**
   * ProfileWorkoutTouched deleteMany
   */
  export type ProfileWorkoutTouchedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileWorkoutToucheds to delete
     */
    where?: ProfileWorkoutTouchedWhereInput
  }

  /**
   * ProfileWorkoutTouched.profile
   */
  export type ProfileWorkoutTouched$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * ProfileWorkoutTouched.workout
   */
  export type ProfileWorkoutTouched$workoutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkoutInclude<ExtArgs> | null
    where?: WorkoutWhereInput
  }

  /**
   * ProfileWorkoutTouched without action
   */
  export type ProfileWorkoutTouchedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileWorkoutTouched
     */
    select?: ProfileWorkoutTouchedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileWorkoutTouchedInclude<ExtArgs> | null
  }


  /**
   * Model ProfileMealLikes
   */

  export type AggregateProfileMealLikes = {
    _count: ProfileMealLikesCountAggregateOutputType | null
    _avg: ProfileMealLikesAvgAggregateOutputType | null
    _sum: ProfileMealLikesSumAggregateOutputType | null
    _min: ProfileMealLikesMinAggregateOutputType | null
    _max: ProfileMealLikesMaxAggregateOutputType | null
  }

  export type ProfileMealLikesAvgAggregateOutputType = {
    id: number | null
    profileId: number | null
    mealId: number | null
  }

  export type ProfileMealLikesSumAggregateOutputType = {
    id: number | null
    profileId: number | null
    mealId: number | null
  }

  export type ProfileMealLikesMinAggregateOutputType = {
    id: number | null
    profileId: number | null
    mealId: number | null
  }

  export type ProfileMealLikesMaxAggregateOutputType = {
    id: number | null
    profileId: number | null
    mealId: number | null
  }

  export type ProfileMealLikesCountAggregateOutputType = {
    id: number
    profileId: number
    mealId: number
    _all: number
  }


  export type ProfileMealLikesAvgAggregateInputType = {
    id?: true
    profileId?: true
    mealId?: true
  }

  export type ProfileMealLikesSumAggregateInputType = {
    id?: true
    profileId?: true
    mealId?: true
  }

  export type ProfileMealLikesMinAggregateInputType = {
    id?: true
    profileId?: true
    mealId?: true
  }

  export type ProfileMealLikesMaxAggregateInputType = {
    id?: true
    profileId?: true
    mealId?: true
  }

  export type ProfileMealLikesCountAggregateInputType = {
    id?: true
    profileId?: true
    mealId?: true
    _all?: true
  }

  export type ProfileMealLikesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileMealLikes to aggregate.
     */
    where?: ProfileMealLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileMealLikes to fetch.
     */
    orderBy?: ProfileMealLikesOrderByWithRelationInput | ProfileMealLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileMealLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileMealLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileMealLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileMealLikes
    **/
    _count?: true | ProfileMealLikesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileMealLikesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileMealLikesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMealLikesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMealLikesMaxAggregateInputType
  }

  export type GetProfileMealLikesAggregateType<T extends ProfileMealLikesAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileMealLikes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileMealLikes[P]>
      : GetScalarType<T[P], AggregateProfileMealLikes[P]>
  }




  export type ProfileMealLikesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileMealLikesWhereInput
    orderBy?: ProfileMealLikesOrderByWithAggregationInput | ProfileMealLikesOrderByWithAggregationInput[]
    by: ProfileMealLikesScalarFieldEnum[] | ProfileMealLikesScalarFieldEnum
    having?: ProfileMealLikesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileMealLikesCountAggregateInputType | true
    _avg?: ProfileMealLikesAvgAggregateInputType
    _sum?: ProfileMealLikesSumAggregateInputType
    _min?: ProfileMealLikesMinAggregateInputType
    _max?: ProfileMealLikesMaxAggregateInputType
  }

  export type ProfileMealLikesGroupByOutputType = {
    id: number
    profileId: number | null
    mealId: number | null
    _count: ProfileMealLikesCountAggregateOutputType | null
    _avg: ProfileMealLikesAvgAggregateOutputType | null
    _sum: ProfileMealLikesSumAggregateOutputType | null
    _min: ProfileMealLikesMinAggregateOutputType | null
    _max: ProfileMealLikesMaxAggregateOutputType | null
  }

  type GetProfileMealLikesGroupByPayload<T extends ProfileMealLikesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileMealLikesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileMealLikesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileMealLikesGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileMealLikesGroupByOutputType[P]>
        }
      >
    >


  export type ProfileMealLikesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    mealId?: boolean
    profile?: boolean | ProfileMealLikes$profileArgs<ExtArgs>
    meal?: boolean | ProfileMealLikes$mealArgs<ExtArgs>
  }, ExtArgs["result"]["profileMealLikes"]>

  export type ProfileMealLikesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    mealId?: boolean
    profile?: boolean | ProfileMealLikes$profileArgs<ExtArgs>
    meal?: boolean | ProfileMealLikes$mealArgs<ExtArgs>
  }, ExtArgs["result"]["profileMealLikes"]>

  export type ProfileMealLikesSelectScalar = {
    id?: boolean
    profileId?: boolean
    mealId?: boolean
  }

  export type ProfileMealLikesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileMealLikes$profileArgs<ExtArgs>
    meal?: boolean | ProfileMealLikes$mealArgs<ExtArgs>
  }
  export type ProfileMealLikesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileMealLikes$profileArgs<ExtArgs>
    meal?: boolean | ProfileMealLikes$mealArgs<ExtArgs>
  }

  export type $ProfileMealLikesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileMealLikes"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      meal: Prisma.$MealPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      profileId: number | null
      mealId: number | null
    }, ExtArgs["result"]["profileMealLikes"]>
    composites: {}
  }

  type ProfileMealLikesGetPayload<S extends boolean | null | undefined | ProfileMealLikesDefaultArgs> = $Result.GetResult<Prisma.$ProfileMealLikesPayload, S>

  type ProfileMealLikesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileMealLikesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileMealLikesCountAggregateInputType | true
    }

  export interface ProfileMealLikesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileMealLikes'], meta: { name: 'ProfileMealLikes' } }
    /**
     * Find zero or one ProfileMealLikes that matches the filter.
     * @param {ProfileMealLikesFindUniqueArgs} args - Arguments to find a ProfileMealLikes
     * @example
     * // Get one ProfileMealLikes
     * const profileMealLikes = await prisma.profileMealLikes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileMealLikesFindUniqueArgs>(args: SelectSubset<T, ProfileMealLikesFindUniqueArgs<ExtArgs>>): Prisma__ProfileMealLikesClient<$Result.GetResult<Prisma.$ProfileMealLikesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProfileMealLikes that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileMealLikesFindUniqueOrThrowArgs} args - Arguments to find a ProfileMealLikes
     * @example
     * // Get one ProfileMealLikes
     * const profileMealLikes = await prisma.profileMealLikes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileMealLikesFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileMealLikesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileMealLikesClient<$Result.GetResult<Prisma.$ProfileMealLikesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProfileMealLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileMealLikesFindFirstArgs} args - Arguments to find a ProfileMealLikes
     * @example
     * // Get one ProfileMealLikes
     * const profileMealLikes = await prisma.profileMealLikes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileMealLikesFindFirstArgs>(args?: SelectSubset<T, ProfileMealLikesFindFirstArgs<ExtArgs>>): Prisma__ProfileMealLikesClient<$Result.GetResult<Prisma.$ProfileMealLikesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProfileMealLikes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileMealLikesFindFirstOrThrowArgs} args - Arguments to find a ProfileMealLikes
     * @example
     * // Get one ProfileMealLikes
     * const profileMealLikes = await prisma.profileMealLikes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileMealLikesFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileMealLikesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileMealLikesClient<$Result.GetResult<Prisma.$ProfileMealLikesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProfileMealLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileMealLikesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileMealLikes
     * const profileMealLikes = await prisma.profileMealLikes.findMany()
     * 
     * // Get first 10 ProfileMealLikes
     * const profileMealLikes = await prisma.profileMealLikes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileMealLikesWithIdOnly = await prisma.profileMealLikes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileMealLikesFindManyArgs>(args?: SelectSubset<T, ProfileMealLikesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileMealLikesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProfileMealLikes.
     * @param {ProfileMealLikesCreateArgs} args - Arguments to create a ProfileMealLikes.
     * @example
     * // Create one ProfileMealLikes
     * const ProfileMealLikes = await prisma.profileMealLikes.create({
     *   data: {
     *     // ... data to create a ProfileMealLikes
     *   }
     * })
     * 
     */
    create<T extends ProfileMealLikesCreateArgs>(args: SelectSubset<T, ProfileMealLikesCreateArgs<ExtArgs>>): Prisma__ProfileMealLikesClient<$Result.GetResult<Prisma.$ProfileMealLikesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProfileMealLikes.
     * @param {ProfileMealLikesCreateManyArgs} args - Arguments to create many ProfileMealLikes.
     * @example
     * // Create many ProfileMealLikes
     * const profileMealLikes = await prisma.profileMealLikes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileMealLikesCreateManyArgs>(args?: SelectSubset<T, ProfileMealLikesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfileMealLikes and returns the data saved in the database.
     * @param {ProfileMealLikesCreateManyAndReturnArgs} args - Arguments to create many ProfileMealLikes.
     * @example
     * // Create many ProfileMealLikes
     * const profileMealLikes = await prisma.profileMealLikes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfileMealLikes and only return the `id`
     * const profileMealLikesWithIdOnly = await prisma.profileMealLikes.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileMealLikesCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileMealLikesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileMealLikesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProfileMealLikes.
     * @param {ProfileMealLikesDeleteArgs} args - Arguments to delete one ProfileMealLikes.
     * @example
     * // Delete one ProfileMealLikes
     * const ProfileMealLikes = await prisma.profileMealLikes.delete({
     *   where: {
     *     // ... filter to delete one ProfileMealLikes
     *   }
     * })
     * 
     */
    delete<T extends ProfileMealLikesDeleteArgs>(args: SelectSubset<T, ProfileMealLikesDeleteArgs<ExtArgs>>): Prisma__ProfileMealLikesClient<$Result.GetResult<Prisma.$ProfileMealLikesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProfileMealLikes.
     * @param {ProfileMealLikesUpdateArgs} args - Arguments to update one ProfileMealLikes.
     * @example
     * // Update one ProfileMealLikes
     * const profileMealLikes = await prisma.profileMealLikes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileMealLikesUpdateArgs>(args: SelectSubset<T, ProfileMealLikesUpdateArgs<ExtArgs>>): Prisma__ProfileMealLikesClient<$Result.GetResult<Prisma.$ProfileMealLikesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProfileMealLikes.
     * @param {ProfileMealLikesDeleteManyArgs} args - Arguments to filter ProfileMealLikes to delete.
     * @example
     * // Delete a few ProfileMealLikes
     * const { count } = await prisma.profileMealLikes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileMealLikesDeleteManyArgs>(args?: SelectSubset<T, ProfileMealLikesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileMealLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileMealLikesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileMealLikes
     * const profileMealLikes = await prisma.profileMealLikes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileMealLikesUpdateManyArgs>(args: SelectSubset<T, ProfileMealLikesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProfileMealLikes.
     * @param {ProfileMealLikesUpsertArgs} args - Arguments to update or create a ProfileMealLikes.
     * @example
     * // Update or create a ProfileMealLikes
     * const profileMealLikes = await prisma.profileMealLikes.upsert({
     *   create: {
     *     // ... data to create a ProfileMealLikes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileMealLikes we want to update
     *   }
     * })
     */
    upsert<T extends ProfileMealLikesUpsertArgs>(args: SelectSubset<T, ProfileMealLikesUpsertArgs<ExtArgs>>): Prisma__ProfileMealLikesClient<$Result.GetResult<Prisma.$ProfileMealLikesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProfileMealLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileMealLikesCountArgs} args - Arguments to filter ProfileMealLikes to count.
     * @example
     * // Count the number of ProfileMealLikes
     * const count = await prisma.profileMealLikes.count({
     *   where: {
     *     // ... the filter for the ProfileMealLikes we want to count
     *   }
     * })
    **/
    count<T extends ProfileMealLikesCountArgs>(
      args?: Subset<T, ProfileMealLikesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileMealLikesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileMealLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileMealLikesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileMealLikesAggregateArgs>(args: Subset<T, ProfileMealLikesAggregateArgs>): Prisma.PrismaPromise<GetProfileMealLikesAggregateType<T>>

    /**
     * Group by ProfileMealLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileMealLikesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileMealLikesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileMealLikesGroupByArgs['orderBy'] }
        : { orderBy?: ProfileMealLikesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileMealLikesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileMealLikesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileMealLikes model
   */
  readonly fields: ProfileMealLikesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileMealLikes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileMealLikesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileMealLikes$profileArgs<ExtArgs> = {}>(args?: Subset<T, ProfileMealLikes$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    meal<T extends ProfileMealLikes$mealArgs<ExtArgs> = {}>(args?: Subset<T, ProfileMealLikes$mealArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileMealLikes model
   */ 
  interface ProfileMealLikesFieldRefs {
    readonly id: FieldRef<"ProfileMealLikes", 'Int'>
    readonly profileId: FieldRef<"ProfileMealLikes", 'Int'>
    readonly mealId: FieldRef<"ProfileMealLikes", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProfileMealLikes findUnique
   */
  export type ProfileMealLikesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealLikes
     */
    select?: ProfileMealLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealLikesInclude<ExtArgs> | null
    /**
     * Filter, which ProfileMealLikes to fetch.
     */
    where: ProfileMealLikesWhereUniqueInput
  }

  /**
   * ProfileMealLikes findUniqueOrThrow
   */
  export type ProfileMealLikesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealLikes
     */
    select?: ProfileMealLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealLikesInclude<ExtArgs> | null
    /**
     * Filter, which ProfileMealLikes to fetch.
     */
    where: ProfileMealLikesWhereUniqueInput
  }

  /**
   * ProfileMealLikes findFirst
   */
  export type ProfileMealLikesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealLikes
     */
    select?: ProfileMealLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealLikesInclude<ExtArgs> | null
    /**
     * Filter, which ProfileMealLikes to fetch.
     */
    where?: ProfileMealLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileMealLikes to fetch.
     */
    orderBy?: ProfileMealLikesOrderByWithRelationInput | ProfileMealLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileMealLikes.
     */
    cursor?: ProfileMealLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileMealLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileMealLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileMealLikes.
     */
    distinct?: ProfileMealLikesScalarFieldEnum | ProfileMealLikesScalarFieldEnum[]
  }

  /**
   * ProfileMealLikes findFirstOrThrow
   */
  export type ProfileMealLikesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealLikes
     */
    select?: ProfileMealLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealLikesInclude<ExtArgs> | null
    /**
     * Filter, which ProfileMealLikes to fetch.
     */
    where?: ProfileMealLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileMealLikes to fetch.
     */
    orderBy?: ProfileMealLikesOrderByWithRelationInput | ProfileMealLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileMealLikes.
     */
    cursor?: ProfileMealLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileMealLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileMealLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileMealLikes.
     */
    distinct?: ProfileMealLikesScalarFieldEnum | ProfileMealLikesScalarFieldEnum[]
  }

  /**
   * ProfileMealLikes findMany
   */
  export type ProfileMealLikesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealLikes
     */
    select?: ProfileMealLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealLikesInclude<ExtArgs> | null
    /**
     * Filter, which ProfileMealLikes to fetch.
     */
    where?: ProfileMealLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileMealLikes to fetch.
     */
    orderBy?: ProfileMealLikesOrderByWithRelationInput | ProfileMealLikesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileMealLikes.
     */
    cursor?: ProfileMealLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileMealLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileMealLikes.
     */
    skip?: number
    distinct?: ProfileMealLikesScalarFieldEnum | ProfileMealLikesScalarFieldEnum[]
  }

  /**
   * ProfileMealLikes create
   */
  export type ProfileMealLikesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealLikes
     */
    select?: ProfileMealLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealLikesInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileMealLikes.
     */
    data?: XOR<ProfileMealLikesCreateInput, ProfileMealLikesUncheckedCreateInput>
  }

  /**
   * ProfileMealLikes createMany
   */
  export type ProfileMealLikesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileMealLikes.
     */
    data: ProfileMealLikesCreateManyInput | ProfileMealLikesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileMealLikes createManyAndReturn
   */
  export type ProfileMealLikesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealLikes
     */
    select?: ProfileMealLikesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProfileMealLikes.
     */
    data: ProfileMealLikesCreateManyInput | ProfileMealLikesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealLikesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileMealLikes update
   */
  export type ProfileMealLikesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealLikes
     */
    select?: ProfileMealLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealLikesInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileMealLikes.
     */
    data: XOR<ProfileMealLikesUpdateInput, ProfileMealLikesUncheckedUpdateInput>
    /**
     * Choose, which ProfileMealLikes to update.
     */
    where: ProfileMealLikesWhereUniqueInput
  }

  /**
   * ProfileMealLikes updateMany
   */
  export type ProfileMealLikesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileMealLikes.
     */
    data: XOR<ProfileMealLikesUpdateManyMutationInput, ProfileMealLikesUncheckedUpdateManyInput>
    /**
     * Filter which ProfileMealLikes to update
     */
    where?: ProfileMealLikesWhereInput
  }

  /**
   * ProfileMealLikes upsert
   */
  export type ProfileMealLikesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealLikes
     */
    select?: ProfileMealLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealLikesInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileMealLikes to update in case it exists.
     */
    where: ProfileMealLikesWhereUniqueInput
    /**
     * In case the ProfileMealLikes found by the `where` argument doesn't exist, create a new ProfileMealLikes with this data.
     */
    create: XOR<ProfileMealLikesCreateInput, ProfileMealLikesUncheckedCreateInput>
    /**
     * In case the ProfileMealLikes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileMealLikesUpdateInput, ProfileMealLikesUncheckedUpdateInput>
  }

  /**
   * ProfileMealLikes delete
   */
  export type ProfileMealLikesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealLikes
     */
    select?: ProfileMealLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealLikesInclude<ExtArgs> | null
    /**
     * Filter which ProfileMealLikes to delete.
     */
    where: ProfileMealLikesWhereUniqueInput
  }

  /**
   * ProfileMealLikes deleteMany
   */
  export type ProfileMealLikesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileMealLikes to delete
     */
    where?: ProfileMealLikesWhereInput
  }

  /**
   * ProfileMealLikes.profile
   */
  export type ProfileMealLikes$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * ProfileMealLikes.meal
   */
  export type ProfileMealLikes$mealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    where?: MealWhereInput
  }

  /**
   * ProfileMealLikes without action
   */
  export type ProfileMealLikesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealLikes
     */
    select?: ProfileMealLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealLikesInclude<ExtArgs> | null
  }


  /**
   * Model ProfileMealTouched
   */

  export type AggregateProfileMealTouched = {
    _count: ProfileMealTouchedCountAggregateOutputType | null
    _avg: ProfileMealTouchedAvgAggregateOutputType | null
    _sum: ProfileMealTouchedSumAggregateOutputType | null
    _min: ProfileMealTouchedMinAggregateOutputType | null
    _max: ProfileMealTouchedMaxAggregateOutputType | null
  }

  export type ProfileMealTouchedAvgAggregateOutputType = {
    id: number | null
    profileId: number | null
    mealId: number | null
  }

  export type ProfileMealTouchedSumAggregateOutputType = {
    id: number | null
    profileId: number | null
    mealId: number | null
  }

  export type ProfileMealTouchedMinAggregateOutputType = {
    id: number | null
    profileId: number | null
    mealId: number | null
  }

  export type ProfileMealTouchedMaxAggregateOutputType = {
    id: number | null
    profileId: number | null
    mealId: number | null
  }

  export type ProfileMealTouchedCountAggregateOutputType = {
    id: number
    profileId: number
    mealId: number
    _all: number
  }


  export type ProfileMealTouchedAvgAggregateInputType = {
    id?: true
    profileId?: true
    mealId?: true
  }

  export type ProfileMealTouchedSumAggregateInputType = {
    id?: true
    profileId?: true
    mealId?: true
  }

  export type ProfileMealTouchedMinAggregateInputType = {
    id?: true
    profileId?: true
    mealId?: true
  }

  export type ProfileMealTouchedMaxAggregateInputType = {
    id?: true
    profileId?: true
    mealId?: true
  }

  export type ProfileMealTouchedCountAggregateInputType = {
    id?: true
    profileId?: true
    mealId?: true
    _all?: true
  }

  export type ProfileMealTouchedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileMealTouched to aggregate.
     */
    where?: ProfileMealTouchedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileMealToucheds to fetch.
     */
    orderBy?: ProfileMealTouchedOrderByWithRelationInput | ProfileMealTouchedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileMealTouchedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileMealToucheds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileMealToucheds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileMealToucheds
    **/
    _count?: true | ProfileMealTouchedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileMealTouchedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileMealTouchedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMealTouchedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMealTouchedMaxAggregateInputType
  }

  export type GetProfileMealTouchedAggregateType<T extends ProfileMealTouchedAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileMealTouched]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileMealTouched[P]>
      : GetScalarType<T[P], AggregateProfileMealTouched[P]>
  }




  export type ProfileMealTouchedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileMealTouchedWhereInput
    orderBy?: ProfileMealTouchedOrderByWithAggregationInput | ProfileMealTouchedOrderByWithAggregationInput[]
    by: ProfileMealTouchedScalarFieldEnum[] | ProfileMealTouchedScalarFieldEnum
    having?: ProfileMealTouchedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileMealTouchedCountAggregateInputType | true
    _avg?: ProfileMealTouchedAvgAggregateInputType
    _sum?: ProfileMealTouchedSumAggregateInputType
    _min?: ProfileMealTouchedMinAggregateInputType
    _max?: ProfileMealTouchedMaxAggregateInputType
  }

  export type ProfileMealTouchedGroupByOutputType = {
    id: number
    profileId: number | null
    mealId: number | null
    _count: ProfileMealTouchedCountAggregateOutputType | null
    _avg: ProfileMealTouchedAvgAggregateOutputType | null
    _sum: ProfileMealTouchedSumAggregateOutputType | null
    _min: ProfileMealTouchedMinAggregateOutputType | null
    _max: ProfileMealTouchedMaxAggregateOutputType | null
  }

  type GetProfileMealTouchedGroupByPayload<T extends ProfileMealTouchedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileMealTouchedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileMealTouchedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileMealTouchedGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileMealTouchedGroupByOutputType[P]>
        }
      >
    >


  export type ProfileMealTouchedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    mealId?: boolean
    profile?: boolean | ProfileMealTouched$profileArgs<ExtArgs>
    meal?: boolean | ProfileMealTouched$mealArgs<ExtArgs>
  }, ExtArgs["result"]["profileMealTouched"]>

  export type ProfileMealTouchedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    mealId?: boolean
    profile?: boolean | ProfileMealTouched$profileArgs<ExtArgs>
    meal?: boolean | ProfileMealTouched$mealArgs<ExtArgs>
  }, ExtArgs["result"]["profileMealTouched"]>

  export type ProfileMealTouchedSelectScalar = {
    id?: boolean
    profileId?: boolean
    mealId?: boolean
  }

  export type ProfileMealTouchedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileMealTouched$profileArgs<ExtArgs>
    meal?: boolean | ProfileMealTouched$mealArgs<ExtArgs>
  }
  export type ProfileMealTouchedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileMealTouched$profileArgs<ExtArgs>
    meal?: boolean | ProfileMealTouched$mealArgs<ExtArgs>
  }

  export type $ProfileMealTouchedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileMealTouched"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      meal: Prisma.$MealPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      profileId: number | null
      mealId: number | null
    }, ExtArgs["result"]["profileMealTouched"]>
    composites: {}
  }

  type ProfileMealTouchedGetPayload<S extends boolean | null | undefined | ProfileMealTouchedDefaultArgs> = $Result.GetResult<Prisma.$ProfileMealTouchedPayload, S>

  type ProfileMealTouchedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileMealTouchedFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileMealTouchedCountAggregateInputType | true
    }

  export interface ProfileMealTouchedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileMealTouched'], meta: { name: 'ProfileMealTouched' } }
    /**
     * Find zero or one ProfileMealTouched that matches the filter.
     * @param {ProfileMealTouchedFindUniqueArgs} args - Arguments to find a ProfileMealTouched
     * @example
     * // Get one ProfileMealTouched
     * const profileMealTouched = await prisma.profileMealTouched.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileMealTouchedFindUniqueArgs>(args: SelectSubset<T, ProfileMealTouchedFindUniqueArgs<ExtArgs>>): Prisma__ProfileMealTouchedClient<$Result.GetResult<Prisma.$ProfileMealTouchedPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProfileMealTouched that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileMealTouchedFindUniqueOrThrowArgs} args - Arguments to find a ProfileMealTouched
     * @example
     * // Get one ProfileMealTouched
     * const profileMealTouched = await prisma.profileMealTouched.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileMealTouchedFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileMealTouchedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileMealTouchedClient<$Result.GetResult<Prisma.$ProfileMealTouchedPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProfileMealTouched that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileMealTouchedFindFirstArgs} args - Arguments to find a ProfileMealTouched
     * @example
     * // Get one ProfileMealTouched
     * const profileMealTouched = await prisma.profileMealTouched.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileMealTouchedFindFirstArgs>(args?: SelectSubset<T, ProfileMealTouchedFindFirstArgs<ExtArgs>>): Prisma__ProfileMealTouchedClient<$Result.GetResult<Prisma.$ProfileMealTouchedPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProfileMealTouched that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileMealTouchedFindFirstOrThrowArgs} args - Arguments to find a ProfileMealTouched
     * @example
     * // Get one ProfileMealTouched
     * const profileMealTouched = await prisma.profileMealTouched.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileMealTouchedFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileMealTouchedFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileMealTouchedClient<$Result.GetResult<Prisma.$ProfileMealTouchedPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProfileMealToucheds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileMealTouchedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileMealToucheds
     * const profileMealToucheds = await prisma.profileMealTouched.findMany()
     * 
     * // Get first 10 ProfileMealToucheds
     * const profileMealToucheds = await prisma.profileMealTouched.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileMealTouchedWithIdOnly = await prisma.profileMealTouched.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileMealTouchedFindManyArgs>(args?: SelectSubset<T, ProfileMealTouchedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileMealTouchedPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProfileMealTouched.
     * @param {ProfileMealTouchedCreateArgs} args - Arguments to create a ProfileMealTouched.
     * @example
     * // Create one ProfileMealTouched
     * const ProfileMealTouched = await prisma.profileMealTouched.create({
     *   data: {
     *     // ... data to create a ProfileMealTouched
     *   }
     * })
     * 
     */
    create<T extends ProfileMealTouchedCreateArgs>(args: SelectSubset<T, ProfileMealTouchedCreateArgs<ExtArgs>>): Prisma__ProfileMealTouchedClient<$Result.GetResult<Prisma.$ProfileMealTouchedPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProfileMealToucheds.
     * @param {ProfileMealTouchedCreateManyArgs} args - Arguments to create many ProfileMealToucheds.
     * @example
     * // Create many ProfileMealToucheds
     * const profileMealTouched = await prisma.profileMealTouched.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileMealTouchedCreateManyArgs>(args?: SelectSubset<T, ProfileMealTouchedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfileMealToucheds and returns the data saved in the database.
     * @param {ProfileMealTouchedCreateManyAndReturnArgs} args - Arguments to create many ProfileMealToucheds.
     * @example
     * // Create many ProfileMealToucheds
     * const profileMealTouched = await prisma.profileMealTouched.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfileMealToucheds and only return the `id`
     * const profileMealTouchedWithIdOnly = await prisma.profileMealTouched.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileMealTouchedCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileMealTouchedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileMealTouchedPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProfileMealTouched.
     * @param {ProfileMealTouchedDeleteArgs} args - Arguments to delete one ProfileMealTouched.
     * @example
     * // Delete one ProfileMealTouched
     * const ProfileMealTouched = await prisma.profileMealTouched.delete({
     *   where: {
     *     // ... filter to delete one ProfileMealTouched
     *   }
     * })
     * 
     */
    delete<T extends ProfileMealTouchedDeleteArgs>(args: SelectSubset<T, ProfileMealTouchedDeleteArgs<ExtArgs>>): Prisma__ProfileMealTouchedClient<$Result.GetResult<Prisma.$ProfileMealTouchedPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProfileMealTouched.
     * @param {ProfileMealTouchedUpdateArgs} args - Arguments to update one ProfileMealTouched.
     * @example
     * // Update one ProfileMealTouched
     * const profileMealTouched = await prisma.profileMealTouched.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileMealTouchedUpdateArgs>(args: SelectSubset<T, ProfileMealTouchedUpdateArgs<ExtArgs>>): Prisma__ProfileMealTouchedClient<$Result.GetResult<Prisma.$ProfileMealTouchedPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProfileMealToucheds.
     * @param {ProfileMealTouchedDeleteManyArgs} args - Arguments to filter ProfileMealToucheds to delete.
     * @example
     * // Delete a few ProfileMealToucheds
     * const { count } = await prisma.profileMealTouched.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileMealTouchedDeleteManyArgs>(args?: SelectSubset<T, ProfileMealTouchedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileMealToucheds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileMealTouchedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileMealToucheds
     * const profileMealTouched = await prisma.profileMealTouched.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileMealTouchedUpdateManyArgs>(args: SelectSubset<T, ProfileMealTouchedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProfileMealTouched.
     * @param {ProfileMealTouchedUpsertArgs} args - Arguments to update or create a ProfileMealTouched.
     * @example
     * // Update or create a ProfileMealTouched
     * const profileMealTouched = await prisma.profileMealTouched.upsert({
     *   create: {
     *     // ... data to create a ProfileMealTouched
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileMealTouched we want to update
     *   }
     * })
     */
    upsert<T extends ProfileMealTouchedUpsertArgs>(args: SelectSubset<T, ProfileMealTouchedUpsertArgs<ExtArgs>>): Prisma__ProfileMealTouchedClient<$Result.GetResult<Prisma.$ProfileMealTouchedPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProfileMealToucheds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileMealTouchedCountArgs} args - Arguments to filter ProfileMealToucheds to count.
     * @example
     * // Count the number of ProfileMealToucheds
     * const count = await prisma.profileMealTouched.count({
     *   where: {
     *     // ... the filter for the ProfileMealToucheds we want to count
     *   }
     * })
    **/
    count<T extends ProfileMealTouchedCountArgs>(
      args?: Subset<T, ProfileMealTouchedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileMealTouchedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileMealTouched.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileMealTouchedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileMealTouchedAggregateArgs>(args: Subset<T, ProfileMealTouchedAggregateArgs>): Prisma.PrismaPromise<GetProfileMealTouchedAggregateType<T>>

    /**
     * Group by ProfileMealTouched.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileMealTouchedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileMealTouchedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileMealTouchedGroupByArgs['orderBy'] }
        : { orderBy?: ProfileMealTouchedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileMealTouchedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileMealTouchedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileMealTouched model
   */
  readonly fields: ProfileMealTouchedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileMealTouched.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileMealTouchedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileMealTouched$profileArgs<ExtArgs> = {}>(args?: Subset<T, ProfileMealTouched$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    meal<T extends ProfileMealTouched$mealArgs<ExtArgs> = {}>(args?: Subset<T, ProfileMealTouched$mealArgs<ExtArgs>>): Prisma__MealClient<$Result.GetResult<Prisma.$MealPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileMealTouched model
   */ 
  interface ProfileMealTouchedFieldRefs {
    readonly id: FieldRef<"ProfileMealTouched", 'Int'>
    readonly profileId: FieldRef<"ProfileMealTouched", 'Int'>
    readonly mealId: FieldRef<"ProfileMealTouched", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProfileMealTouched findUnique
   */
  export type ProfileMealTouchedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealTouched
     */
    select?: ProfileMealTouchedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealTouchedInclude<ExtArgs> | null
    /**
     * Filter, which ProfileMealTouched to fetch.
     */
    where: ProfileMealTouchedWhereUniqueInput
  }

  /**
   * ProfileMealTouched findUniqueOrThrow
   */
  export type ProfileMealTouchedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealTouched
     */
    select?: ProfileMealTouchedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealTouchedInclude<ExtArgs> | null
    /**
     * Filter, which ProfileMealTouched to fetch.
     */
    where: ProfileMealTouchedWhereUniqueInput
  }

  /**
   * ProfileMealTouched findFirst
   */
  export type ProfileMealTouchedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealTouched
     */
    select?: ProfileMealTouchedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealTouchedInclude<ExtArgs> | null
    /**
     * Filter, which ProfileMealTouched to fetch.
     */
    where?: ProfileMealTouchedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileMealToucheds to fetch.
     */
    orderBy?: ProfileMealTouchedOrderByWithRelationInput | ProfileMealTouchedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileMealToucheds.
     */
    cursor?: ProfileMealTouchedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileMealToucheds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileMealToucheds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileMealToucheds.
     */
    distinct?: ProfileMealTouchedScalarFieldEnum | ProfileMealTouchedScalarFieldEnum[]
  }

  /**
   * ProfileMealTouched findFirstOrThrow
   */
  export type ProfileMealTouchedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealTouched
     */
    select?: ProfileMealTouchedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealTouchedInclude<ExtArgs> | null
    /**
     * Filter, which ProfileMealTouched to fetch.
     */
    where?: ProfileMealTouchedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileMealToucheds to fetch.
     */
    orderBy?: ProfileMealTouchedOrderByWithRelationInput | ProfileMealTouchedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileMealToucheds.
     */
    cursor?: ProfileMealTouchedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileMealToucheds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileMealToucheds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileMealToucheds.
     */
    distinct?: ProfileMealTouchedScalarFieldEnum | ProfileMealTouchedScalarFieldEnum[]
  }

  /**
   * ProfileMealTouched findMany
   */
  export type ProfileMealTouchedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealTouched
     */
    select?: ProfileMealTouchedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealTouchedInclude<ExtArgs> | null
    /**
     * Filter, which ProfileMealToucheds to fetch.
     */
    where?: ProfileMealTouchedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileMealToucheds to fetch.
     */
    orderBy?: ProfileMealTouchedOrderByWithRelationInput | ProfileMealTouchedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileMealToucheds.
     */
    cursor?: ProfileMealTouchedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileMealToucheds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileMealToucheds.
     */
    skip?: number
    distinct?: ProfileMealTouchedScalarFieldEnum | ProfileMealTouchedScalarFieldEnum[]
  }

  /**
   * ProfileMealTouched create
   */
  export type ProfileMealTouchedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealTouched
     */
    select?: ProfileMealTouchedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealTouchedInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileMealTouched.
     */
    data?: XOR<ProfileMealTouchedCreateInput, ProfileMealTouchedUncheckedCreateInput>
  }

  /**
   * ProfileMealTouched createMany
   */
  export type ProfileMealTouchedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileMealToucheds.
     */
    data: ProfileMealTouchedCreateManyInput | ProfileMealTouchedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileMealTouched createManyAndReturn
   */
  export type ProfileMealTouchedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealTouched
     */
    select?: ProfileMealTouchedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProfileMealToucheds.
     */
    data: ProfileMealTouchedCreateManyInput | ProfileMealTouchedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealTouchedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileMealTouched update
   */
  export type ProfileMealTouchedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealTouched
     */
    select?: ProfileMealTouchedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealTouchedInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileMealTouched.
     */
    data: XOR<ProfileMealTouchedUpdateInput, ProfileMealTouchedUncheckedUpdateInput>
    /**
     * Choose, which ProfileMealTouched to update.
     */
    where: ProfileMealTouchedWhereUniqueInput
  }

  /**
   * ProfileMealTouched updateMany
   */
  export type ProfileMealTouchedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileMealToucheds.
     */
    data: XOR<ProfileMealTouchedUpdateManyMutationInput, ProfileMealTouchedUncheckedUpdateManyInput>
    /**
     * Filter which ProfileMealToucheds to update
     */
    where?: ProfileMealTouchedWhereInput
  }

  /**
   * ProfileMealTouched upsert
   */
  export type ProfileMealTouchedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealTouched
     */
    select?: ProfileMealTouchedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealTouchedInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileMealTouched to update in case it exists.
     */
    where: ProfileMealTouchedWhereUniqueInput
    /**
     * In case the ProfileMealTouched found by the `where` argument doesn't exist, create a new ProfileMealTouched with this data.
     */
    create: XOR<ProfileMealTouchedCreateInput, ProfileMealTouchedUncheckedCreateInput>
    /**
     * In case the ProfileMealTouched was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileMealTouchedUpdateInput, ProfileMealTouchedUncheckedUpdateInput>
  }

  /**
   * ProfileMealTouched delete
   */
  export type ProfileMealTouchedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealTouched
     */
    select?: ProfileMealTouchedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealTouchedInclude<ExtArgs> | null
    /**
     * Filter which ProfileMealTouched to delete.
     */
    where: ProfileMealTouchedWhereUniqueInput
  }

  /**
   * ProfileMealTouched deleteMany
   */
  export type ProfileMealTouchedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileMealToucheds to delete
     */
    where?: ProfileMealTouchedWhereInput
  }

  /**
   * ProfileMealTouched.profile
   */
  export type ProfileMealTouched$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * ProfileMealTouched.meal
   */
  export type ProfileMealTouched$mealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MealInclude<ExtArgs> | null
    where?: MealWhereInput
  }

  /**
   * ProfileMealTouched without action
   */
  export type ProfileMealTouchedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileMealTouched
     */
    select?: ProfileMealTouchedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileMealTouchedInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    uid: 'uid',
    email: 'email',
    name: 'name',
    sex: 'sex',
    age: 'age',
    bio: 'bio'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const WorkoutScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    notes: 'notes',
    private: 'private'
  };

  export type WorkoutScalarFieldEnum = (typeof WorkoutScalarFieldEnum)[keyof typeof WorkoutScalarFieldEnum]


  export const ExerciseScalarFieldEnum: {
    id: 'id',
    workoutId: 'workoutId',
    name: 'name'
  };

  export type ExerciseScalarFieldEnum = (typeof ExerciseScalarFieldEnum)[keyof typeof ExerciseScalarFieldEnum]


  export const SetScalarFieldEnum: {
    id: 'id',
    exerciseId: 'exerciseId',
    weight: 'weight',
    reps: 'reps'
  };

  export type SetScalarFieldEnum = (typeof SetScalarFieldEnum)[keyof typeof SetScalarFieldEnum]


  export const MealScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    notes: 'notes',
    totalCalories: 'totalCalories',
    totalCarbs: 'totalCarbs',
    totalFats: 'totalFats',
    totalProteins: 'totalProteins',
    totalGrams: 'totalGrams',
    private: 'private'
  };

  export type MealScalarFieldEnum = (typeof MealScalarFieldEnum)[keyof typeof MealScalarFieldEnum]


  export const FoodScalarFieldEnum: {
    id: 'id',
    mealId: 'mealId',
    name: 'name',
    calories: 'calories',
    carbs: 'carbs',
    fats: 'fats',
    proteins: 'proteins',
    grams: 'grams'
  };

  export type FoodScalarFieldEnum = (typeof FoodScalarFieldEnum)[keyof typeof FoodScalarFieldEnum]


  export const ProfileWorkoutLikesScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    workoutId: 'workoutId'
  };

  export type ProfileWorkoutLikesScalarFieldEnum = (typeof ProfileWorkoutLikesScalarFieldEnum)[keyof typeof ProfileWorkoutLikesScalarFieldEnum]


  export const ProfileWorkoutTouchedScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    workoutId: 'workoutId'
  };

  export type ProfileWorkoutTouchedScalarFieldEnum = (typeof ProfileWorkoutTouchedScalarFieldEnum)[keyof typeof ProfileWorkoutTouchedScalarFieldEnum]


  export const ProfileMealLikesScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    mealId: 'mealId'
  };

  export type ProfileMealLikesScalarFieldEnum = (typeof ProfileMealLikesScalarFieldEnum)[keyof typeof ProfileMealLikesScalarFieldEnum]


  export const ProfileMealTouchedScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    mealId: 'mealId'
  };

  export type ProfileMealTouchedScalarFieldEnum = (typeof ProfileMealTouchedScalarFieldEnum)[keyof typeof ProfileMealTouchedScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: IntFilter<"Profile"> | number
    uid?: StringFilter<"Profile"> | string
    email?: StringFilter<"Profile"> | string
    name?: StringFilter<"Profile"> | string
    sex?: StringFilter<"Profile"> | string
    age?: IntFilter<"Profile"> | number
    bio?: StringFilter<"Profile"> | string
    workouts?: WorkoutListRelationFilter
    meals?: MealListRelationFilter
    likedWorkouts?: ProfileWorkoutLikesListRelationFilter
    touchWorkouts?: ProfileWorkoutTouchedListRelationFilter
    likedMeals?: ProfileMealLikesListRelationFilter
    touchMeals?: ProfileMealTouchedListRelationFilter
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    uid?: SortOrder
    email?: SortOrder
    name?: SortOrder
    sex?: SortOrder
    age?: SortOrder
    bio?: SortOrder
    workouts?: WorkoutOrderByRelationAggregateInput
    meals?: MealOrderByRelationAggregateInput
    likedWorkouts?: ProfileWorkoutLikesOrderByRelationAggregateInput
    touchWorkouts?: ProfileWorkoutTouchedOrderByRelationAggregateInput
    likedMeals?: ProfileMealLikesOrderByRelationAggregateInput
    touchMeals?: ProfileMealTouchedOrderByRelationAggregateInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    uid?: StringFilter<"Profile"> | string
    email?: StringFilter<"Profile"> | string
    name?: StringFilter<"Profile"> | string
    sex?: StringFilter<"Profile"> | string
    age?: IntFilter<"Profile"> | number
    bio?: StringFilter<"Profile"> | string
    workouts?: WorkoutListRelationFilter
    meals?: MealListRelationFilter
    likedWorkouts?: ProfileWorkoutLikesListRelationFilter
    touchWorkouts?: ProfileWorkoutTouchedListRelationFilter
    likedMeals?: ProfileMealLikesListRelationFilter
    touchMeals?: ProfileMealTouchedListRelationFilter
  }, "id">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    uid?: SortOrder
    email?: SortOrder
    name?: SortOrder
    sex?: SortOrder
    age?: SortOrder
    bio?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _avg?: ProfileAvgOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
    _sum?: ProfileSumOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Profile"> | number
    uid?: StringWithAggregatesFilter<"Profile"> | string
    email?: StringWithAggregatesFilter<"Profile"> | string
    name?: StringWithAggregatesFilter<"Profile"> | string
    sex?: StringWithAggregatesFilter<"Profile"> | string
    age?: IntWithAggregatesFilter<"Profile"> | number
    bio?: StringWithAggregatesFilter<"Profile"> | string
  }

  export type WorkoutWhereInput = {
    AND?: WorkoutWhereInput | WorkoutWhereInput[]
    OR?: WorkoutWhereInput[]
    NOT?: WorkoutWhereInput | WorkoutWhereInput[]
    id?: IntFilter<"Workout"> | number
    profileId?: IntFilter<"Workout"> | number
    notes?: StringFilter<"Workout"> | string
    private?: BoolFilter<"Workout"> | boolean
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    exercises?: ExerciseListRelationFilter
    profileLikes?: ProfileWorkoutLikesListRelationFilter
    profileTouch?: ProfileWorkoutTouchedListRelationFilter
  }

  export type WorkoutOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    notes?: SortOrder
    private?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    exercises?: ExerciseOrderByRelationAggregateInput
    profileLikes?: ProfileWorkoutLikesOrderByRelationAggregateInput
    profileTouch?: ProfileWorkoutTouchedOrderByRelationAggregateInput
  }

  export type WorkoutWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WorkoutWhereInput | WorkoutWhereInput[]
    OR?: WorkoutWhereInput[]
    NOT?: WorkoutWhereInput | WorkoutWhereInput[]
    profileId?: IntFilter<"Workout"> | number
    notes?: StringFilter<"Workout"> | string
    private?: BoolFilter<"Workout"> | boolean
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    exercises?: ExerciseListRelationFilter
    profileLikes?: ProfileWorkoutLikesListRelationFilter
    profileTouch?: ProfileWorkoutTouchedListRelationFilter
  }, "id">

  export type WorkoutOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    notes?: SortOrder
    private?: SortOrder
    _count?: WorkoutCountOrderByAggregateInput
    _avg?: WorkoutAvgOrderByAggregateInput
    _max?: WorkoutMaxOrderByAggregateInput
    _min?: WorkoutMinOrderByAggregateInput
    _sum?: WorkoutSumOrderByAggregateInput
  }

  export type WorkoutScalarWhereWithAggregatesInput = {
    AND?: WorkoutScalarWhereWithAggregatesInput | WorkoutScalarWhereWithAggregatesInput[]
    OR?: WorkoutScalarWhereWithAggregatesInput[]
    NOT?: WorkoutScalarWhereWithAggregatesInput | WorkoutScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Workout"> | number
    profileId?: IntWithAggregatesFilter<"Workout"> | number
    notes?: StringWithAggregatesFilter<"Workout"> | string
    private?: BoolWithAggregatesFilter<"Workout"> | boolean
  }

  export type ExerciseWhereInput = {
    AND?: ExerciseWhereInput | ExerciseWhereInput[]
    OR?: ExerciseWhereInput[]
    NOT?: ExerciseWhereInput | ExerciseWhereInput[]
    id?: IntFilter<"Exercise"> | number
    workoutId?: IntFilter<"Exercise"> | number
    name?: StringFilter<"Exercise"> | string
    workout?: XOR<WorkoutRelationFilter, WorkoutWhereInput>
    sets?: SetListRelationFilter
  }

  export type ExerciseOrderByWithRelationInput = {
    id?: SortOrder
    workoutId?: SortOrder
    name?: SortOrder
    workout?: WorkoutOrderByWithRelationInput
    sets?: SetOrderByRelationAggregateInput
  }

  export type ExerciseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExerciseWhereInput | ExerciseWhereInput[]
    OR?: ExerciseWhereInput[]
    NOT?: ExerciseWhereInput | ExerciseWhereInput[]
    workoutId?: IntFilter<"Exercise"> | number
    name?: StringFilter<"Exercise"> | string
    workout?: XOR<WorkoutRelationFilter, WorkoutWhereInput>
    sets?: SetListRelationFilter
  }, "id">

  export type ExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    workoutId?: SortOrder
    name?: SortOrder
    _count?: ExerciseCountOrderByAggregateInput
    _avg?: ExerciseAvgOrderByAggregateInput
    _max?: ExerciseMaxOrderByAggregateInput
    _min?: ExerciseMinOrderByAggregateInput
    _sum?: ExerciseSumOrderByAggregateInput
  }

  export type ExerciseScalarWhereWithAggregatesInput = {
    AND?: ExerciseScalarWhereWithAggregatesInput | ExerciseScalarWhereWithAggregatesInput[]
    OR?: ExerciseScalarWhereWithAggregatesInput[]
    NOT?: ExerciseScalarWhereWithAggregatesInput | ExerciseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Exercise"> | number
    workoutId?: IntWithAggregatesFilter<"Exercise"> | number
    name?: StringWithAggregatesFilter<"Exercise"> | string
  }

  export type SetWhereInput = {
    AND?: SetWhereInput | SetWhereInput[]
    OR?: SetWhereInput[]
    NOT?: SetWhereInput | SetWhereInput[]
    id?: IntFilter<"Set"> | number
    exerciseId?: IntFilter<"Set"> | number
    weight?: FloatFilter<"Set"> | number
    reps?: IntFilter<"Set"> | number
    exercise?: XOR<ExerciseRelationFilter, ExerciseWhereInput>
  }

  export type SetOrderByWithRelationInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    weight?: SortOrder
    reps?: SortOrder
    exercise?: ExerciseOrderByWithRelationInput
  }

  export type SetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SetWhereInput | SetWhereInput[]
    OR?: SetWhereInput[]
    NOT?: SetWhereInput | SetWhereInput[]
    exerciseId?: IntFilter<"Set"> | number
    weight?: FloatFilter<"Set"> | number
    reps?: IntFilter<"Set"> | number
    exercise?: XOR<ExerciseRelationFilter, ExerciseWhereInput>
  }, "id">

  export type SetOrderByWithAggregationInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    weight?: SortOrder
    reps?: SortOrder
    _count?: SetCountOrderByAggregateInput
    _avg?: SetAvgOrderByAggregateInput
    _max?: SetMaxOrderByAggregateInput
    _min?: SetMinOrderByAggregateInput
    _sum?: SetSumOrderByAggregateInput
  }

  export type SetScalarWhereWithAggregatesInput = {
    AND?: SetScalarWhereWithAggregatesInput | SetScalarWhereWithAggregatesInput[]
    OR?: SetScalarWhereWithAggregatesInput[]
    NOT?: SetScalarWhereWithAggregatesInput | SetScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Set"> | number
    exerciseId?: IntWithAggregatesFilter<"Set"> | number
    weight?: FloatWithAggregatesFilter<"Set"> | number
    reps?: IntWithAggregatesFilter<"Set"> | number
  }

  export type MealWhereInput = {
    AND?: MealWhereInput | MealWhereInput[]
    OR?: MealWhereInput[]
    NOT?: MealWhereInput | MealWhereInput[]
    id?: IntFilter<"Meal"> | number
    profileId?: IntFilter<"Meal"> | number
    notes?: StringFilter<"Meal"> | string
    totalCalories?: FloatFilter<"Meal"> | number
    totalCarbs?: FloatFilter<"Meal"> | number
    totalFats?: FloatFilter<"Meal"> | number
    totalProteins?: FloatFilter<"Meal"> | number
    totalGrams?: FloatFilter<"Meal"> | number
    private?: BoolFilter<"Meal"> | boolean
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    foods?: FoodListRelationFilter
    profileLikes?: ProfileMealLikesListRelationFilter
    profileTouch?: ProfileMealTouchedListRelationFilter
  }

  export type MealOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    notes?: SortOrder
    totalCalories?: SortOrder
    totalCarbs?: SortOrder
    totalFats?: SortOrder
    totalProteins?: SortOrder
    totalGrams?: SortOrder
    private?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    foods?: FoodOrderByRelationAggregateInput
    profileLikes?: ProfileMealLikesOrderByRelationAggregateInput
    profileTouch?: ProfileMealTouchedOrderByRelationAggregateInput
  }

  export type MealWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MealWhereInput | MealWhereInput[]
    OR?: MealWhereInput[]
    NOT?: MealWhereInput | MealWhereInput[]
    profileId?: IntFilter<"Meal"> | number
    notes?: StringFilter<"Meal"> | string
    totalCalories?: FloatFilter<"Meal"> | number
    totalCarbs?: FloatFilter<"Meal"> | number
    totalFats?: FloatFilter<"Meal"> | number
    totalProteins?: FloatFilter<"Meal"> | number
    totalGrams?: FloatFilter<"Meal"> | number
    private?: BoolFilter<"Meal"> | boolean
    profile?: XOR<ProfileRelationFilter, ProfileWhereInput>
    foods?: FoodListRelationFilter
    profileLikes?: ProfileMealLikesListRelationFilter
    profileTouch?: ProfileMealTouchedListRelationFilter
  }, "id">

  export type MealOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    notes?: SortOrder
    totalCalories?: SortOrder
    totalCarbs?: SortOrder
    totalFats?: SortOrder
    totalProteins?: SortOrder
    totalGrams?: SortOrder
    private?: SortOrder
    _count?: MealCountOrderByAggregateInput
    _avg?: MealAvgOrderByAggregateInput
    _max?: MealMaxOrderByAggregateInput
    _min?: MealMinOrderByAggregateInput
    _sum?: MealSumOrderByAggregateInput
  }

  export type MealScalarWhereWithAggregatesInput = {
    AND?: MealScalarWhereWithAggregatesInput | MealScalarWhereWithAggregatesInput[]
    OR?: MealScalarWhereWithAggregatesInput[]
    NOT?: MealScalarWhereWithAggregatesInput | MealScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Meal"> | number
    profileId?: IntWithAggregatesFilter<"Meal"> | number
    notes?: StringWithAggregatesFilter<"Meal"> | string
    totalCalories?: FloatWithAggregatesFilter<"Meal"> | number
    totalCarbs?: FloatWithAggregatesFilter<"Meal"> | number
    totalFats?: FloatWithAggregatesFilter<"Meal"> | number
    totalProteins?: FloatWithAggregatesFilter<"Meal"> | number
    totalGrams?: FloatWithAggregatesFilter<"Meal"> | number
    private?: BoolWithAggregatesFilter<"Meal"> | boolean
  }

  export type FoodWhereInput = {
    AND?: FoodWhereInput | FoodWhereInput[]
    OR?: FoodWhereInput[]
    NOT?: FoodWhereInput | FoodWhereInput[]
    id?: IntFilter<"Food"> | number
    mealId?: IntFilter<"Food"> | number
    name?: StringFilter<"Food"> | string
    calories?: FloatFilter<"Food"> | number
    carbs?: FloatFilter<"Food"> | number
    fats?: FloatFilter<"Food"> | number
    proteins?: FloatFilter<"Food"> | number
    grams?: FloatFilter<"Food"> | number
    meal?: XOR<MealRelationFilter, MealWhereInput>
  }

  export type FoodOrderByWithRelationInput = {
    id?: SortOrder
    mealId?: SortOrder
    name?: SortOrder
    calories?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    proteins?: SortOrder
    grams?: SortOrder
    meal?: MealOrderByWithRelationInput
  }

  export type FoodWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FoodWhereInput | FoodWhereInput[]
    OR?: FoodWhereInput[]
    NOT?: FoodWhereInput | FoodWhereInput[]
    mealId?: IntFilter<"Food"> | number
    name?: StringFilter<"Food"> | string
    calories?: FloatFilter<"Food"> | number
    carbs?: FloatFilter<"Food"> | number
    fats?: FloatFilter<"Food"> | number
    proteins?: FloatFilter<"Food"> | number
    grams?: FloatFilter<"Food"> | number
    meal?: XOR<MealRelationFilter, MealWhereInput>
  }, "id">

  export type FoodOrderByWithAggregationInput = {
    id?: SortOrder
    mealId?: SortOrder
    name?: SortOrder
    calories?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    proteins?: SortOrder
    grams?: SortOrder
    _count?: FoodCountOrderByAggregateInput
    _avg?: FoodAvgOrderByAggregateInput
    _max?: FoodMaxOrderByAggregateInput
    _min?: FoodMinOrderByAggregateInput
    _sum?: FoodSumOrderByAggregateInput
  }

  export type FoodScalarWhereWithAggregatesInput = {
    AND?: FoodScalarWhereWithAggregatesInput | FoodScalarWhereWithAggregatesInput[]
    OR?: FoodScalarWhereWithAggregatesInput[]
    NOT?: FoodScalarWhereWithAggregatesInput | FoodScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Food"> | number
    mealId?: IntWithAggregatesFilter<"Food"> | number
    name?: StringWithAggregatesFilter<"Food"> | string
    calories?: FloatWithAggregatesFilter<"Food"> | number
    carbs?: FloatWithAggregatesFilter<"Food"> | number
    fats?: FloatWithAggregatesFilter<"Food"> | number
    proteins?: FloatWithAggregatesFilter<"Food"> | number
    grams?: FloatWithAggregatesFilter<"Food"> | number
  }

  export type ProfileWorkoutLikesWhereInput = {
    AND?: ProfileWorkoutLikesWhereInput | ProfileWorkoutLikesWhereInput[]
    OR?: ProfileWorkoutLikesWhereInput[]
    NOT?: ProfileWorkoutLikesWhereInput | ProfileWorkoutLikesWhereInput[]
    id?: IntFilter<"ProfileWorkoutLikes"> | number
    profileId?: IntNullableFilter<"ProfileWorkoutLikes"> | number | null
    workoutId?: IntNullableFilter<"ProfileWorkoutLikes"> | number | null
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    workout?: XOR<WorkoutNullableRelationFilter, WorkoutWhereInput> | null
  }

  export type ProfileWorkoutLikesOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrderInput | SortOrder
    workoutId?: SortOrderInput | SortOrder
    profile?: ProfileOrderByWithRelationInput
    workout?: WorkoutOrderByWithRelationInput
  }

  export type ProfileWorkoutLikesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProfileWorkoutLikesWhereInput | ProfileWorkoutLikesWhereInput[]
    OR?: ProfileWorkoutLikesWhereInput[]
    NOT?: ProfileWorkoutLikesWhereInput | ProfileWorkoutLikesWhereInput[]
    profileId?: IntNullableFilter<"ProfileWorkoutLikes"> | number | null
    workoutId?: IntNullableFilter<"ProfileWorkoutLikes"> | number | null
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    workout?: XOR<WorkoutNullableRelationFilter, WorkoutWhereInput> | null
  }, "id">

  export type ProfileWorkoutLikesOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrderInput | SortOrder
    workoutId?: SortOrderInput | SortOrder
    _count?: ProfileWorkoutLikesCountOrderByAggregateInput
    _avg?: ProfileWorkoutLikesAvgOrderByAggregateInput
    _max?: ProfileWorkoutLikesMaxOrderByAggregateInput
    _min?: ProfileWorkoutLikesMinOrderByAggregateInput
    _sum?: ProfileWorkoutLikesSumOrderByAggregateInput
  }

  export type ProfileWorkoutLikesScalarWhereWithAggregatesInput = {
    AND?: ProfileWorkoutLikesScalarWhereWithAggregatesInput | ProfileWorkoutLikesScalarWhereWithAggregatesInput[]
    OR?: ProfileWorkoutLikesScalarWhereWithAggregatesInput[]
    NOT?: ProfileWorkoutLikesScalarWhereWithAggregatesInput | ProfileWorkoutLikesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProfileWorkoutLikes"> | number
    profileId?: IntNullableWithAggregatesFilter<"ProfileWorkoutLikes"> | number | null
    workoutId?: IntNullableWithAggregatesFilter<"ProfileWorkoutLikes"> | number | null
  }

  export type ProfileWorkoutTouchedWhereInput = {
    AND?: ProfileWorkoutTouchedWhereInput | ProfileWorkoutTouchedWhereInput[]
    OR?: ProfileWorkoutTouchedWhereInput[]
    NOT?: ProfileWorkoutTouchedWhereInput | ProfileWorkoutTouchedWhereInput[]
    id?: IntFilter<"ProfileWorkoutTouched"> | number
    profileId?: IntNullableFilter<"ProfileWorkoutTouched"> | number | null
    workoutId?: IntNullableFilter<"ProfileWorkoutTouched"> | number | null
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    workout?: XOR<WorkoutNullableRelationFilter, WorkoutWhereInput> | null
  }

  export type ProfileWorkoutTouchedOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrderInput | SortOrder
    workoutId?: SortOrderInput | SortOrder
    profile?: ProfileOrderByWithRelationInput
    workout?: WorkoutOrderByWithRelationInput
  }

  export type ProfileWorkoutTouchedWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProfileWorkoutTouchedWhereInput | ProfileWorkoutTouchedWhereInput[]
    OR?: ProfileWorkoutTouchedWhereInput[]
    NOT?: ProfileWorkoutTouchedWhereInput | ProfileWorkoutTouchedWhereInput[]
    profileId?: IntNullableFilter<"ProfileWorkoutTouched"> | number | null
    workoutId?: IntNullableFilter<"ProfileWorkoutTouched"> | number | null
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    workout?: XOR<WorkoutNullableRelationFilter, WorkoutWhereInput> | null
  }, "id">

  export type ProfileWorkoutTouchedOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrderInput | SortOrder
    workoutId?: SortOrderInput | SortOrder
    _count?: ProfileWorkoutTouchedCountOrderByAggregateInput
    _avg?: ProfileWorkoutTouchedAvgOrderByAggregateInput
    _max?: ProfileWorkoutTouchedMaxOrderByAggregateInput
    _min?: ProfileWorkoutTouchedMinOrderByAggregateInput
    _sum?: ProfileWorkoutTouchedSumOrderByAggregateInput
  }

  export type ProfileWorkoutTouchedScalarWhereWithAggregatesInput = {
    AND?: ProfileWorkoutTouchedScalarWhereWithAggregatesInput | ProfileWorkoutTouchedScalarWhereWithAggregatesInput[]
    OR?: ProfileWorkoutTouchedScalarWhereWithAggregatesInput[]
    NOT?: ProfileWorkoutTouchedScalarWhereWithAggregatesInput | ProfileWorkoutTouchedScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProfileWorkoutTouched"> | number
    profileId?: IntNullableWithAggregatesFilter<"ProfileWorkoutTouched"> | number | null
    workoutId?: IntNullableWithAggregatesFilter<"ProfileWorkoutTouched"> | number | null
  }

  export type ProfileMealLikesWhereInput = {
    AND?: ProfileMealLikesWhereInput | ProfileMealLikesWhereInput[]
    OR?: ProfileMealLikesWhereInput[]
    NOT?: ProfileMealLikesWhereInput | ProfileMealLikesWhereInput[]
    id?: IntFilter<"ProfileMealLikes"> | number
    profileId?: IntNullableFilter<"ProfileMealLikes"> | number | null
    mealId?: IntNullableFilter<"ProfileMealLikes"> | number | null
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    meal?: XOR<MealNullableRelationFilter, MealWhereInput> | null
  }

  export type ProfileMealLikesOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrderInput | SortOrder
    mealId?: SortOrderInput | SortOrder
    profile?: ProfileOrderByWithRelationInput
    meal?: MealOrderByWithRelationInput
  }

  export type ProfileMealLikesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProfileMealLikesWhereInput | ProfileMealLikesWhereInput[]
    OR?: ProfileMealLikesWhereInput[]
    NOT?: ProfileMealLikesWhereInput | ProfileMealLikesWhereInput[]
    profileId?: IntNullableFilter<"ProfileMealLikes"> | number | null
    mealId?: IntNullableFilter<"ProfileMealLikes"> | number | null
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    meal?: XOR<MealNullableRelationFilter, MealWhereInput> | null
  }, "id">

  export type ProfileMealLikesOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrderInput | SortOrder
    mealId?: SortOrderInput | SortOrder
    _count?: ProfileMealLikesCountOrderByAggregateInput
    _avg?: ProfileMealLikesAvgOrderByAggregateInput
    _max?: ProfileMealLikesMaxOrderByAggregateInput
    _min?: ProfileMealLikesMinOrderByAggregateInput
    _sum?: ProfileMealLikesSumOrderByAggregateInput
  }

  export type ProfileMealLikesScalarWhereWithAggregatesInput = {
    AND?: ProfileMealLikesScalarWhereWithAggregatesInput | ProfileMealLikesScalarWhereWithAggregatesInput[]
    OR?: ProfileMealLikesScalarWhereWithAggregatesInput[]
    NOT?: ProfileMealLikesScalarWhereWithAggregatesInput | ProfileMealLikesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProfileMealLikes"> | number
    profileId?: IntNullableWithAggregatesFilter<"ProfileMealLikes"> | number | null
    mealId?: IntNullableWithAggregatesFilter<"ProfileMealLikes"> | number | null
  }

  export type ProfileMealTouchedWhereInput = {
    AND?: ProfileMealTouchedWhereInput | ProfileMealTouchedWhereInput[]
    OR?: ProfileMealTouchedWhereInput[]
    NOT?: ProfileMealTouchedWhereInput | ProfileMealTouchedWhereInput[]
    id?: IntFilter<"ProfileMealTouched"> | number
    profileId?: IntNullableFilter<"ProfileMealTouched"> | number | null
    mealId?: IntNullableFilter<"ProfileMealTouched"> | number | null
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    meal?: XOR<MealNullableRelationFilter, MealWhereInput> | null
  }

  export type ProfileMealTouchedOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrderInput | SortOrder
    mealId?: SortOrderInput | SortOrder
    profile?: ProfileOrderByWithRelationInput
    meal?: MealOrderByWithRelationInput
  }

  export type ProfileMealTouchedWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProfileMealTouchedWhereInput | ProfileMealTouchedWhereInput[]
    OR?: ProfileMealTouchedWhereInput[]
    NOT?: ProfileMealTouchedWhereInput | ProfileMealTouchedWhereInput[]
    profileId?: IntNullableFilter<"ProfileMealTouched"> | number | null
    mealId?: IntNullableFilter<"ProfileMealTouched"> | number | null
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    meal?: XOR<MealNullableRelationFilter, MealWhereInput> | null
  }, "id">

  export type ProfileMealTouchedOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrderInput | SortOrder
    mealId?: SortOrderInput | SortOrder
    _count?: ProfileMealTouchedCountOrderByAggregateInput
    _avg?: ProfileMealTouchedAvgOrderByAggregateInput
    _max?: ProfileMealTouchedMaxOrderByAggregateInput
    _min?: ProfileMealTouchedMinOrderByAggregateInput
    _sum?: ProfileMealTouchedSumOrderByAggregateInput
  }

  export type ProfileMealTouchedScalarWhereWithAggregatesInput = {
    AND?: ProfileMealTouchedScalarWhereWithAggregatesInput | ProfileMealTouchedScalarWhereWithAggregatesInput[]
    OR?: ProfileMealTouchedScalarWhereWithAggregatesInput[]
    NOT?: ProfileMealTouchedScalarWhereWithAggregatesInput | ProfileMealTouchedScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProfileMealTouched"> | number
    profileId?: IntNullableWithAggregatesFilter<"ProfileMealTouched"> | number | null
    mealId?: IntNullableWithAggregatesFilter<"ProfileMealTouched"> | number | null
  }

  export type ProfileCreateInput = {
    uid: string
    email: string
    name?: string
    sex?: string
    age?: number
    bio?: string
    workouts?: WorkoutCreateNestedManyWithoutProfileInput
    meals?: MealCreateNestedManyWithoutProfileInput
    likedWorkouts?: ProfileWorkoutLikesCreateNestedManyWithoutProfileInput
    touchWorkouts?: ProfileWorkoutTouchedCreateNestedManyWithoutProfileInput
    likedMeals?: ProfileMealLikesCreateNestedManyWithoutProfileInput
    touchMeals?: ProfileMealTouchedCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: number
    uid: string
    email: string
    name?: string
    sex?: string
    age?: number
    bio?: string
    workouts?: WorkoutUncheckedCreateNestedManyWithoutProfileInput
    meals?: MealUncheckedCreateNestedManyWithoutProfileInput
    likedWorkouts?: ProfileWorkoutLikesUncheckedCreateNestedManyWithoutProfileInput
    touchWorkouts?: ProfileWorkoutTouchedUncheckedCreateNestedManyWithoutProfileInput
    likedMeals?: ProfileMealLikesUncheckedCreateNestedManyWithoutProfileInput
    touchMeals?: ProfileMealTouchedUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileUpdateInput = {
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    bio?: StringFieldUpdateOperationsInput | string
    workouts?: WorkoutUpdateManyWithoutProfileNestedInput
    meals?: MealUpdateManyWithoutProfileNestedInput
    likedWorkouts?: ProfileWorkoutLikesUpdateManyWithoutProfileNestedInput
    touchWorkouts?: ProfileWorkoutTouchedUpdateManyWithoutProfileNestedInput
    likedMeals?: ProfileMealLikesUpdateManyWithoutProfileNestedInput
    touchMeals?: ProfileMealTouchedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    bio?: StringFieldUpdateOperationsInput | string
    workouts?: WorkoutUncheckedUpdateManyWithoutProfileNestedInput
    meals?: MealUncheckedUpdateManyWithoutProfileNestedInput
    likedWorkouts?: ProfileWorkoutLikesUncheckedUpdateManyWithoutProfileNestedInput
    touchWorkouts?: ProfileWorkoutTouchedUncheckedUpdateManyWithoutProfileNestedInput
    likedMeals?: ProfileMealLikesUncheckedUpdateManyWithoutProfileNestedInput
    touchMeals?: ProfileMealTouchedUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileCreateManyInput = {
    id?: number
    uid: string
    email: string
    name?: string
    sex?: string
    age?: number
    bio?: string
  }

  export type ProfileUpdateManyMutationInput = {
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    bio?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    bio?: StringFieldUpdateOperationsInput | string
  }

  export type WorkoutCreateInput = {
    notes: string
    private?: boolean
    profile: ProfileCreateNestedOneWithoutWorkoutsInput
    exercises?: ExerciseCreateNestedManyWithoutWorkoutInput
    profileLikes?: ProfileWorkoutLikesCreateNestedManyWithoutWorkoutInput
    profileTouch?: ProfileWorkoutTouchedCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutUncheckedCreateInput = {
    id?: number
    profileId: number
    notes: string
    private?: boolean
    exercises?: ExerciseUncheckedCreateNestedManyWithoutWorkoutInput
    profileLikes?: ProfileWorkoutLikesUncheckedCreateNestedManyWithoutWorkoutInput
    profileTouch?: ProfileWorkoutTouchedUncheckedCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutUpdateInput = {
    notes?: StringFieldUpdateOperationsInput | string
    private?: BoolFieldUpdateOperationsInput | boolean
    profile?: ProfileUpdateOneRequiredWithoutWorkoutsNestedInput
    exercises?: ExerciseUpdateManyWithoutWorkoutNestedInput
    profileLikes?: ProfileWorkoutLikesUpdateManyWithoutWorkoutNestedInput
    profileTouch?: ProfileWorkoutTouchedUpdateManyWithoutWorkoutNestedInput
  }

  export type WorkoutUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    private?: BoolFieldUpdateOperationsInput | boolean
    exercises?: ExerciseUncheckedUpdateManyWithoutWorkoutNestedInput
    profileLikes?: ProfileWorkoutLikesUncheckedUpdateManyWithoutWorkoutNestedInput
    profileTouch?: ProfileWorkoutTouchedUncheckedUpdateManyWithoutWorkoutNestedInput
  }

  export type WorkoutCreateManyInput = {
    id?: number
    profileId: number
    notes: string
    private?: boolean
  }

  export type WorkoutUpdateManyMutationInput = {
    notes?: StringFieldUpdateOperationsInput | string
    private?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkoutUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    private?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExerciseCreateInput = {
    name: string
    workout: WorkoutCreateNestedOneWithoutExercisesInput
    sets?: SetCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateInput = {
    id?: number
    workoutId: number
    name: string
    sets?: SetUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    workout?: WorkoutUpdateOneRequiredWithoutExercisesNestedInput
    sets?: SetUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    workoutId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    sets?: SetUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseCreateManyInput = {
    id?: number
    workoutId: number
    name: string
  }

  export type ExerciseUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ExerciseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    workoutId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SetCreateInput = {
    weight: number
    reps: number
    exercise: ExerciseCreateNestedOneWithoutSetsInput
  }

  export type SetUncheckedCreateInput = {
    id?: number
    exerciseId: number
    weight: number
    reps: number
  }

  export type SetUpdateInput = {
    weight?: FloatFieldUpdateOperationsInput | number
    reps?: IntFieldUpdateOperationsInput | number
    exercise?: ExerciseUpdateOneRequiredWithoutSetsNestedInput
  }

  export type SetUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    exerciseId?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    reps?: IntFieldUpdateOperationsInput | number
  }

  export type SetCreateManyInput = {
    id?: number
    exerciseId: number
    weight: number
    reps: number
  }

  export type SetUpdateManyMutationInput = {
    weight?: FloatFieldUpdateOperationsInput | number
    reps?: IntFieldUpdateOperationsInput | number
  }

  export type SetUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    exerciseId?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    reps?: IntFieldUpdateOperationsInput | number
  }

  export type MealCreateInput = {
    notes: string
    totalCalories: number
    totalCarbs: number
    totalFats: number
    totalProteins: number
    totalGrams: number
    private?: boolean
    profile: ProfileCreateNestedOneWithoutMealsInput
    foods?: FoodCreateNestedManyWithoutMealInput
    profileLikes?: ProfileMealLikesCreateNestedManyWithoutMealInput
    profileTouch?: ProfileMealTouchedCreateNestedManyWithoutMealInput
  }

  export type MealUncheckedCreateInput = {
    id?: number
    profileId: number
    notes: string
    totalCalories: number
    totalCarbs: number
    totalFats: number
    totalProteins: number
    totalGrams: number
    private?: boolean
    foods?: FoodUncheckedCreateNestedManyWithoutMealInput
    profileLikes?: ProfileMealLikesUncheckedCreateNestedManyWithoutMealInput
    profileTouch?: ProfileMealTouchedUncheckedCreateNestedManyWithoutMealInput
  }

  export type MealUpdateInput = {
    notes?: StringFieldUpdateOperationsInput | string
    totalCalories?: FloatFieldUpdateOperationsInput | number
    totalCarbs?: FloatFieldUpdateOperationsInput | number
    totalFats?: FloatFieldUpdateOperationsInput | number
    totalProteins?: FloatFieldUpdateOperationsInput | number
    totalGrams?: FloatFieldUpdateOperationsInput | number
    private?: BoolFieldUpdateOperationsInput | boolean
    profile?: ProfileUpdateOneRequiredWithoutMealsNestedInput
    foods?: FoodUpdateManyWithoutMealNestedInput
    profileLikes?: ProfileMealLikesUpdateManyWithoutMealNestedInput
    profileTouch?: ProfileMealTouchedUpdateManyWithoutMealNestedInput
  }

  export type MealUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    totalCalories?: FloatFieldUpdateOperationsInput | number
    totalCarbs?: FloatFieldUpdateOperationsInput | number
    totalFats?: FloatFieldUpdateOperationsInput | number
    totalProteins?: FloatFieldUpdateOperationsInput | number
    totalGrams?: FloatFieldUpdateOperationsInput | number
    private?: BoolFieldUpdateOperationsInput | boolean
    foods?: FoodUncheckedUpdateManyWithoutMealNestedInput
    profileLikes?: ProfileMealLikesUncheckedUpdateManyWithoutMealNestedInput
    profileTouch?: ProfileMealTouchedUncheckedUpdateManyWithoutMealNestedInput
  }

  export type MealCreateManyInput = {
    id?: number
    profileId: number
    notes: string
    totalCalories: number
    totalCarbs: number
    totalFats: number
    totalProteins: number
    totalGrams: number
    private?: boolean
  }

  export type MealUpdateManyMutationInput = {
    notes?: StringFieldUpdateOperationsInput | string
    totalCalories?: FloatFieldUpdateOperationsInput | number
    totalCarbs?: FloatFieldUpdateOperationsInput | number
    totalFats?: FloatFieldUpdateOperationsInput | number
    totalProteins?: FloatFieldUpdateOperationsInput | number
    totalGrams?: FloatFieldUpdateOperationsInput | number
    private?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MealUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    totalCalories?: FloatFieldUpdateOperationsInput | number
    totalCarbs?: FloatFieldUpdateOperationsInput | number
    totalFats?: FloatFieldUpdateOperationsInput | number
    totalProteins?: FloatFieldUpdateOperationsInput | number
    totalGrams?: FloatFieldUpdateOperationsInput | number
    private?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FoodCreateInput = {
    name: string
    calories: number
    carbs: number
    fats: number
    proteins: number
    grams: number
    meal: MealCreateNestedOneWithoutFoodsInput
  }

  export type FoodUncheckedCreateInput = {
    id?: number
    mealId: number
    name: string
    calories: number
    carbs: number
    fats: number
    proteins: number
    grams: number
  }

  export type FoodUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    calories?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    proteins?: FloatFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
    meal?: MealUpdateOneRequiredWithoutFoodsNestedInput
  }

  export type FoodUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    mealId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    calories?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    proteins?: FloatFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
  }

  export type FoodCreateManyInput = {
    id?: number
    mealId: number
    name: string
    calories: number
    carbs: number
    fats: number
    proteins: number
    grams: number
  }

  export type FoodUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    calories?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    proteins?: FloatFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
  }

  export type FoodUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    mealId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    calories?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    proteins?: FloatFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
  }

  export type ProfileWorkoutLikesCreateInput = {
    profile?: ProfileCreateNestedOneWithoutLikedWorkoutsInput
    workout?: WorkoutCreateNestedOneWithoutProfileLikesInput
  }

  export type ProfileWorkoutLikesUncheckedCreateInput = {
    id?: number
    profileId?: number | null
    workoutId?: number | null
  }

  export type ProfileWorkoutLikesUpdateInput = {
    profile?: ProfileUpdateOneWithoutLikedWorkoutsNestedInput
    workout?: WorkoutUpdateOneWithoutProfileLikesNestedInput
  }

  export type ProfileWorkoutLikesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: NullableIntFieldUpdateOperationsInput | number | null
    workoutId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfileWorkoutLikesCreateManyInput = {
    id?: number
    profileId?: number | null
    workoutId?: number | null
  }

  export type ProfileWorkoutLikesUpdateManyMutationInput = {

  }

  export type ProfileWorkoutLikesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: NullableIntFieldUpdateOperationsInput | number | null
    workoutId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfileWorkoutTouchedCreateInput = {
    profile?: ProfileCreateNestedOneWithoutTouchWorkoutsInput
    workout?: WorkoutCreateNestedOneWithoutProfileTouchInput
  }

  export type ProfileWorkoutTouchedUncheckedCreateInput = {
    id?: number
    profileId?: number | null
    workoutId?: number | null
  }

  export type ProfileWorkoutTouchedUpdateInput = {
    profile?: ProfileUpdateOneWithoutTouchWorkoutsNestedInput
    workout?: WorkoutUpdateOneWithoutProfileTouchNestedInput
  }

  export type ProfileWorkoutTouchedUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: NullableIntFieldUpdateOperationsInput | number | null
    workoutId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfileWorkoutTouchedCreateManyInput = {
    id?: number
    profileId?: number | null
    workoutId?: number | null
  }

  export type ProfileWorkoutTouchedUpdateManyMutationInput = {

  }

  export type ProfileWorkoutTouchedUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: NullableIntFieldUpdateOperationsInput | number | null
    workoutId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfileMealLikesCreateInput = {
    profile?: ProfileCreateNestedOneWithoutLikedMealsInput
    meal?: MealCreateNestedOneWithoutProfileLikesInput
  }

  export type ProfileMealLikesUncheckedCreateInput = {
    id?: number
    profileId?: number | null
    mealId?: number | null
  }

  export type ProfileMealLikesUpdateInput = {
    profile?: ProfileUpdateOneWithoutLikedMealsNestedInput
    meal?: MealUpdateOneWithoutProfileLikesNestedInput
  }

  export type ProfileMealLikesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: NullableIntFieldUpdateOperationsInput | number | null
    mealId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfileMealLikesCreateManyInput = {
    id?: number
    profileId?: number | null
    mealId?: number | null
  }

  export type ProfileMealLikesUpdateManyMutationInput = {

  }

  export type ProfileMealLikesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: NullableIntFieldUpdateOperationsInput | number | null
    mealId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfileMealTouchedCreateInput = {
    profile?: ProfileCreateNestedOneWithoutTouchMealsInput
    meal?: MealCreateNestedOneWithoutProfileTouchInput
  }

  export type ProfileMealTouchedUncheckedCreateInput = {
    id?: number
    profileId?: number | null
    mealId?: number | null
  }

  export type ProfileMealTouchedUpdateInput = {
    profile?: ProfileUpdateOneWithoutTouchMealsNestedInput
    meal?: MealUpdateOneWithoutProfileTouchNestedInput
  }

  export type ProfileMealTouchedUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: NullableIntFieldUpdateOperationsInput | number | null
    mealId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfileMealTouchedCreateManyInput = {
    id?: number
    profileId?: number | null
    mealId?: number | null
  }

  export type ProfileMealTouchedUpdateManyMutationInput = {

  }

  export type ProfileMealTouchedUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: NullableIntFieldUpdateOperationsInput | number | null
    mealId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type WorkoutListRelationFilter = {
    every?: WorkoutWhereInput
    some?: WorkoutWhereInput
    none?: WorkoutWhereInput
  }

  export type MealListRelationFilter = {
    every?: MealWhereInput
    some?: MealWhereInput
    none?: MealWhereInput
  }

  export type ProfileWorkoutLikesListRelationFilter = {
    every?: ProfileWorkoutLikesWhereInput
    some?: ProfileWorkoutLikesWhereInput
    none?: ProfileWorkoutLikesWhereInput
  }

  export type ProfileWorkoutTouchedListRelationFilter = {
    every?: ProfileWorkoutTouchedWhereInput
    some?: ProfileWorkoutTouchedWhereInput
    none?: ProfileWorkoutTouchedWhereInput
  }

  export type ProfileMealLikesListRelationFilter = {
    every?: ProfileMealLikesWhereInput
    some?: ProfileMealLikesWhereInput
    none?: ProfileMealLikesWhereInput
  }

  export type ProfileMealTouchedListRelationFilter = {
    every?: ProfileMealTouchedWhereInput
    some?: ProfileMealTouchedWhereInput
    none?: ProfileMealTouchedWhereInput
  }

  export type WorkoutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MealOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileWorkoutLikesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileWorkoutTouchedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileMealLikesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileMealTouchedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    uid?: SortOrder
    email?: SortOrder
    name?: SortOrder
    sex?: SortOrder
    age?: SortOrder
    bio?: SortOrder
  }

  export type ProfileAvgOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    uid?: SortOrder
    email?: SortOrder
    name?: SortOrder
    sex?: SortOrder
    age?: SortOrder
    bio?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    uid?: SortOrder
    email?: SortOrder
    name?: SortOrder
    sex?: SortOrder
    age?: SortOrder
    bio?: SortOrder
  }

  export type ProfileSumOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ProfileRelationFilter = {
    is?: ProfileWhereInput
    isNot?: ProfileWhereInput
  }

  export type ExerciseListRelationFilter = {
    every?: ExerciseWhereInput
    some?: ExerciseWhereInput
    none?: ExerciseWhereInput
  }

  export type ExerciseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkoutCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    notes?: SortOrder
    private?: SortOrder
  }

  export type WorkoutAvgOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
  }

  export type WorkoutMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    notes?: SortOrder
    private?: SortOrder
  }

  export type WorkoutMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    notes?: SortOrder
    private?: SortOrder
  }

  export type WorkoutSumOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type WorkoutRelationFilter = {
    is?: WorkoutWhereInput
    isNot?: WorkoutWhereInput
  }

  export type SetListRelationFilter = {
    every?: SetWhereInput
    some?: SetWhereInput
    none?: SetWhereInput
  }

  export type SetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    workoutId?: SortOrder
    name?: SortOrder
  }

  export type ExerciseAvgOrderByAggregateInput = {
    id?: SortOrder
    workoutId?: SortOrder
  }

  export type ExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    workoutId?: SortOrder
    name?: SortOrder
  }

  export type ExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    workoutId?: SortOrder
    name?: SortOrder
  }

  export type ExerciseSumOrderByAggregateInput = {
    id?: SortOrder
    workoutId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ExerciseRelationFilter = {
    is?: ExerciseWhereInput
    isNot?: ExerciseWhereInput
  }

  export type SetCountOrderByAggregateInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    weight?: SortOrder
    reps?: SortOrder
  }

  export type SetAvgOrderByAggregateInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    weight?: SortOrder
    reps?: SortOrder
  }

  export type SetMaxOrderByAggregateInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    weight?: SortOrder
    reps?: SortOrder
  }

  export type SetMinOrderByAggregateInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    weight?: SortOrder
    reps?: SortOrder
  }

  export type SetSumOrderByAggregateInput = {
    id?: SortOrder
    exerciseId?: SortOrder
    weight?: SortOrder
    reps?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FoodListRelationFilter = {
    every?: FoodWhereInput
    some?: FoodWhereInput
    none?: FoodWhereInput
  }

  export type FoodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MealCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    notes?: SortOrder
    totalCalories?: SortOrder
    totalCarbs?: SortOrder
    totalFats?: SortOrder
    totalProteins?: SortOrder
    totalGrams?: SortOrder
    private?: SortOrder
  }

  export type MealAvgOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    totalCalories?: SortOrder
    totalCarbs?: SortOrder
    totalFats?: SortOrder
    totalProteins?: SortOrder
    totalGrams?: SortOrder
  }

  export type MealMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    notes?: SortOrder
    totalCalories?: SortOrder
    totalCarbs?: SortOrder
    totalFats?: SortOrder
    totalProteins?: SortOrder
    totalGrams?: SortOrder
    private?: SortOrder
  }

  export type MealMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    notes?: SortOrder
    totalCalories?: SortOrder
    totalCarbs?: SortOrder
    totalFats?: SortOrder
    totalProteins?: SortOrder
    totalGrams?: SortOrder
    private?: SortOrder
  }

  export type MealSumOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    totalCalories?: SortOrder
    totalCarbs?: SortOrder
    totalFats?: SortOrder
    totalProteins?: SortOrder
    totalGrams?: SortOrder
  }

  export type MealRelationFilter = {
    is?: MealWhereInput
    isNot?: MealWhereInput
  }

  export type FoodCountOrderByAggregateInput = {
    id?: SortOrder
    mealId?: SortOrder
    name?: SortOrder
    calories?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    proteins?: SortOrder
    grams?: SortOrder
  }

  export type FoodAvgOrderByAggregateInput = {
    id?: SortOrder
    mealId?: SortOrder
    calories?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    proteins?: SortOrder
    grams?: SortOrder
  }

  export type FoodMaxOrderByAggregateInput = {
    id?: SortOrder
    mealId?: SortOrder
    name?: SortOrder
    calories?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    proteins?: SortOrder
    grams?: SortOrder
  }

  export type FoodMinOrderByAggregateInput = {
    id?: SortOrder
    mealId?: SortOrder
    name?: SortOrder
    calories?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    proteins?: SortOrder
    grams?: SortOrder
  }

  export type FoodSumOrderByAggregateInput = {
    id?: SortOrder
    mealId?: SortOrder
    calories?: SortOrder
    carbs?: SortOrder
    fats?: SortOrder
    proteins?: SortOrder
    grams?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ProfileNullableRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type WorkoutNullableRelationFilter = {
    is?: WorkoutWhereInput | null
    isNot?: WorkoutWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProfileWorkoutLikesCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    workoutId?: SortOrder
  }

  export type ProfileWorkoutLikesAvgOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    workoutId?: SortOrder
  }

  export type ProfileWorkoutLikesMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    workoutId?: SortOrder
  }

  export type ProfileWorkoutLikesMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    workoutId?: SortOrder
  }

  export type ProfileWorkoutLikesSumOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    workoutId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ProfileWorkoutTouchedCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    workoutId?: SortOrder
  }

  export type ProfileWorkoutTouchedAvgOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    workoutId?: SortOrder
  }

  export type ProfileWorkoutTouchedMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    workoutId?: SortOrder
  }

  export type ProfileWorkoutTouchedMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    workoutId?: SortOrder
  }

  export type ProfileWorkoutTouchedSumOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    workoutId?: SortOrder
  }

  export type MealNullableRelationFilter = {
    is?: MealWhereInput | null
    isNot?: MealWhereInput | null
  }

  export type ProfileMealLikesCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    mealId?: SortOrder
  }

  export type ProfileMealLikesAvgOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    mealId?: SortOrder
  }

  export type ProfileMealLikesMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    mealId?: SortOrder
  }

  export type ProfileMealLikesMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    mealId?: SortOrder
  }

  export type ProfileMealLikesSumOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    mealId?: SortOrder
  }

  export type ProfileMealTouchedCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    mealId?: SortOrder
  }

  export type ProfileMealTouchedAvgOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    mealId?: SortOrder
  }

  export type ProfileMealTouchedMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    mealId?: SortOrder
  }

  export type ProfileMealTouchedMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    mealId?: SortOrder
  }

  export type ProfileMealTouchedSumOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    mealId?: SortOrder
  }

  export type WorkoutCreateNestedManyWithoutProfileInput = {
    create?: XOR<WorkoutCreateWithoutProfileInput, WorkoutUncheckedCreateWithoutProfileInput> | WorkoutCreateWithoutProfileInput[] | WorkoutUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: WorkoutCreateOrConnectWithoutProfileInput | WorkoutCreateOrConnectWithoutProfileInput[]
    createMany?: WorkoutCreateManyProfileInputEnvelope
    connect?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
  }

  export type MealCreateNestedManyWithoutProfileInput = {
    create?: XOR<MealCreateWithoutProfileInput, MealUncheckedCreateWithoutProfileInput> | MealCreateWithoutProfileInput[] | MealUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: MealCreateOrConnectWithoutProfileInput | MealCreateOrConnectWithoutProfileInput[]
    createMany?: MealCreateManyProfileInputEnvelope
    connect?: MealWhereUniqueInput | MealWhereUniqueInput[]
  }

  export type ProfileWorkoutLikesCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProfileWorkoutLikesCreateWithoutProfileInput, ProfileWorkoutLikesUncheckedCreateWithoutProfileInput> | ProfileWorkoutLikesCreateWithoutProfileInput[] | ProfileWorkoutLikesUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileWorkoutLikesCreateOrConnectWithoutProfileInput | ProfileWorkoutLikesCreateOrConnectWithoutProfileInput[]
    createMany?: ProfileWorkoutLikesCreateManyProfileInputEnvelope
    connect?: ProfileWorkoutLikesWhereUniqueInput | ProfileWorkoutLikesWhereUniqueInput[]
  }

  export type ProfileWorkoutTouchedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProfileWorkoutTouchedCreateWithoutProfileInput, ProfileWorkoutTouchedUncheckedCreateWithoutProfileInput> | ProfileWorkoutTouchedCreateWithoutProfileInput[] | ProfileWorkoutTouchedUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileWorkoutTouchedCreateOrConnectWithoutProfileInput | ProfileWorkoutTouchedCreateOrConnectWithoutProfileInput[]
    createMany?: ProfileWorkoutTouchedCreateManyProfileInputEnvelope
    connect?: ProfileWorkoutTouchedWhereUniqueInput | ProfileWorkoutTouchedWhereUniqueInput[]
  }

  export type ProfileMealLikesCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProfileMealLikesCreateWithoutProfileInput, ProfileMealLikesUncheckedCreateWithoutProfileInput> | ProfileMealLikesCreateWithoutProfileInput[] | ProfileMealLikesUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileMealLikesCreateOrConnectWithoutProfileInput | ProfileMealLikesCreateOrConnectWithoutProfileInput[]
    createMany?: ProfileMealLikesCreateManyProfileInputEnvelope
    connect?: ProfileMealLikesWhereUniqueInput | ProfileMealLikesWhereUniqueInput[]
  }

  export type ProfileMealTouchedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProfileMealTouchedCreateWithoutProfileInput, ProfileMealTouchedUncheckedCreateWithoutProfileInput> | ProfileMealTouchedCreateWithoutProfileInput[] | ProfileMealTouchedUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileMealTouchedCreateOrConnectWithoutProfileInput | ProfileMealTouchedCreateOrConnectWithoutProfileInput[]
    createMany?: ProfileMealTouchedCreateManyProfileInputEnvelope
    connect?: ProfileMealTouchedWhereUniqueInput | ProfileMealTouchedWhereUniqueInput[]
  }

  export type WorkoutUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<WorkoutCreateWithoutProfileInput, WorkoutUncheckedCreateWithoutProfileInput> | WorkoutCreateWithoutProfileInput[] | WorkoutUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: WorkoutCreateOrConnectWithoutProfileInput | WorkoutCreateOrConnectWithoutProfileInput[]
    createMany?: WorkoutCreateManyProfileInputEnvelope
    connect?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
  }

  export type MealUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<MealCreateWithoutProfileInput, MealUncheckedCreateWithoutProfileInput> | MealCreateWithoutProfileInput[] | MealUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: MealCreateOrConnectWithoutProfileInput | MealCreateOrConnectWithoutProfileInput[]
    createMany?: MealCreateManyProfileInputEnvelope
    connect?: MealWhereUniqueInput | MealWhereUniqueInput[]
  }

  export type ProfileWorkoutLikesUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProfileWorkoutLikesCreateWithoutProfileInput, ProfileWorkoutLikesUncheckedCreateWithoutProfileInput> | ProfileWorkoutLikesCreateWithoutProfileInput[] | ProfileWorkoutLikesUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileWorkoutLikesCreateOrConnectWithoutProfileInput | ProfileWorkoutLikesCreateOrConnectWithoutProfileInput[]
    createMany?: ProfileWorkoutLikesCreateManyProfileInputEnvelope
    connect?: ProfileWorkoutLikesWhereUniqueInput | ProfileWorkoutLikesWhereUniqueInput[]
  }

  export type ProfileWorkoutTouchedUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProfileWorkoutTouchedCreateWithoutProfileInput, ProfileWorkoutTouchedUncheckedCreateWithoutProfileInput> | ProfileWorkoutTouchedCreateWithoutProfileInput[] | ProfileWorkoutTouchedUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileWorkoutTouchedCreateOrConnectWithoutProfileInput | ProfileWorkoutTouchedCreateOrConnectWithoutProfileInput[]
    createMany?: ProfileWorkoutTouchedCreateManyProfileInputEnvelope
    connect?: ProfileWorkoutTouchedWhereUniqueInput | ProfileWorkoutTouchedWhereUniqueInput[]
  }

  export type ProfileMealLikesUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProfileMealLikesCreateWithoutProfileInput, ProfileMealLikesUncheckedCreateWithoutProfileInput> | ProfileMealLikesCreateWithoutProfileInput[] | ProfileMealLikesUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileMealLikesCreateOrConnectWithoutProfileInput | ProfileMealLikesCreateOrConnectWithoutProfileInput[]
    createMany?: ProfileMealLikesCreateManyProfileInputEnvelope
    connect?: ProfileMealLikesWhereUniqueInput | ProfileMealLikesWhereUniqueInput[]
  }

  export type ProfileMealTouchedUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProfileMealTouchedCreateWithoutProfileInput, ProfileMealTouchedUncheckedCreateWithoutProfileInput> | ProfileMealTouchedCreateWithoutProfileInput[] | ProfileMealTouchedUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileMealTouchedCreateOrConnectWithoutProfileInput | ProfileMealTouchedCreateOrConnectWithoutProfileInput[]
    createMany?: ProfileMealTouchedCreateManyProfileInputEnvelope
    connect?: ProfileMealTouchedWhereUniqueInput | ProfileMealTouchedWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WorkoutUpdateManyWithoutProfileNestedInput = {
    create?: XOR<WorkoutCreateWithoutProfileInput, WorkoutUncheckedCreateWithoutProfileInput> | WorkoutCreateWithoutProfileInput[] | WorkoutUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: WorkoutCreateOrConnectWithoutProfileInput | WorkoutCreateOrConnectWithoutProfileInput[]
    upsert?: WorkoutUpsertWithWhereUniqueWithoutProfileInput | WorkoutUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: WorkoutCreateManyProfileInputEnvelope
    set?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
    disconnect?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
    delete?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
    connect?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
    update?: WorkoutUpdateWithWhereUniqueWithoutProfileInput | WorkoutUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: WorkoutUpdateManyWithWhereWithoutProfileInput | WorkoutUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: WorkoutScalarWhereInput | WorkoutScalarWhereInput[]
  }

  export type MealUpdateManyWithoutProfileNestedInput = {
    create?: XOR<MealCreateWithoutProfileInput, MealUncheckedCreateWithoutProfileInput> | MealCreateWithoutProfileInput[] | MealUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: MealCreateOrConnectWithoutProfileInput | MealCreateOrConnectWithoutProfileInput[]
    upsert?: MealUpsertWithWhereUniqueWithoutProfileInput | MealUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: MealCreateManyProfileInputEnvelope
    set?: MealWhereUniqueInput | MealWhereUniqueInput[]
    disconnect?: MealWhereUniqueInput | MealWhereUniqueInput[]
    delete?: MealWhereUniqueInput | MealWhereUniqueInput[]
    connect?: MealWhereUniqueInput | MealWhereUniqueInput[]
    update?: MealUpdateWithWhereUniqueWithoutProfileInput | MealUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: MealUpdateManyWithWhereWithoutProfileInput | MealUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: MealScalarWhereInput | MealScalarWhereInput[]
  }

  export type ProfileWorkoutLikesUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProfileWorkoutLikesCreateWithoutProfileInput, ProfileWorkoutLikesUncheckedCreateWithoutProfileInput> | ProfileWorkoutLikesCreateWithoutProfileInput[] | ProfileWorkoutLikesUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileWorkoutLikesCreateOrConnectWithoutProfileInput | ProfileWorkoutLikesCreateOrConnectWithoutProfileInput[]
    upsert?: ProfileWorkoutLikesUpsertWithWhereUniqueWithoutProfileInput | ProfileWorkoutLikesUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProfileWorkoutLikesCreateManyProfileInputEnvelope
    set?: ProfileWorkoutLikesWhereUniqueInput | ProfileWorkoutLikesWhereUniqueInput[]
    disconnect?: ProfileWorkoutLikesWhereUniqueInput | ProfileWorkoutLikesWhereUniqueInput[]
    delete?: ProfileWorkoutLikesWhereUniqueInput | ProfileWorkoutLikesWhereUniqueInput[]
    connect?: ProfileWorkoutLikesWhereUniqueInput | ProfileWorkoutLikesWhereUniqueInput[]
    update?: ProfileWorkoutLikesUpdateWithWhereUniqueWithoutProfileInput | ProfileWorkoutLikesUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProfileWorkoutLikesUpdateManyWithWhereWithoutProfileInput | ProfileWorkoutLikesUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProfileWorkoutLikesScalarWhereInput | ProfileWorkoutLikesScalarWhereInput[]
  }

  export type ProfileWorkoutTouchedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProfileWorkoutTouchedCreateWithoutProfileInput, ProfileWorkoutTouchedUncheckedCreateWithoutProfileInput> | ProfileWorkoutTouchedCreateWithoutProfileInput[] | ProfileWorkoutTouchedUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileWorkoutTouchedCreateOrConnectWithoutProfileInput | ProfileWorkoutTouchedCreateOrConnectWithoutProfileInput[]
    upsert?: ProfileWorkoutTouchedUpsertWithWhereUniqueWithoutProfileInput | ProfileWorkoutTouchedUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProfileWorkoutTouchedCreateManyProfileInputEnvelope
    set?: ProfileWorkoutTouchedWhereUniqueInput | ProfileWorkoutTouchedWhereUniqueInput[]
    disconnect?: ProfileWorkoutTouchedWhereUniqueInput | ProfileWorkoutTouchedWhereUniqueInput[]
    delete?: ProfileWorkoutTouchedWhereUniqueInput | ProfileWorkoutTouchedWhereUniqueInput[]
    connect?: ProfileWorkoutTouchedWhereUniqueInput | ProfileWorkoutTouchedWhereUniqueInput[]
    update?: ProfileWorkoutTouchedUpdateWithWhereUniqueWithoutProfileInput | ProfileWorkoutTouchedUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProfileWorkoutTouchedUpdateManyWithWhereWithoutProfileInput | ProfileWorkoutTouchedUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProfileWorkoutTouchedScalarWhereInput | ProfileWorkoutTouchedScalarWhereInput[]
  }

  export type ProfileMealLikesUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProfileMealLikesCreateWithoutProfileInput, ProfileMealLikesUncheckedCreateWithoutProfileInput> | ProfileMealLikesCreateWithoutProfileInput[] | ProfileMealLikesUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileMealLikesCreateOrConnectWithoutProfileInput | ProfileMealLikesCreateOrConnectWithoutProfileInput[]
    upsert?: ProfileMealLikesUpsertWithWhereUniqueWithoutProfileInput | ProfileMealLikesUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProfileMealLikesCreateManyProfileInputEnvelope
    set?: ProfileMealLikesWhereUniqueInput | ProfileMealLikesWhereUniqueInput[]
    disconnect?: ProfileMealLikesWhereUniqueInput | ProfileMealLikesWhereUniqueInput[]
    delete?: ProfileMealLikesWhereUniqueInput | ProfileMealLikesWhereUniqueInput[]
    connect?: ProfileMealLikesWhereUniqueInput | ProfileMealLikesWhereUniqueInput[]
    update?: ProfileMealLikesUpdateWithWhereUniqueWithoutProfileInput | ProfileMealLikesUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProfileMealLikesUpdateManyWithWhereWithoutProfileInput | ProfileMealLikesUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProfileMealLikesScalarWhereInput | ProfileMealLikesScalarWhereInput[]
  }

  export type ProfileMealTouchedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProfileMealTouchedCreateWithoutProfileInput, ProfileMealTouchedUncheckedCreateWithoutProfileInput> | ProfileMealTouchedCreateWithoutProfileInput[] | ProfileMealTouchedUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileMealTouchedCreateOrConnectWithoutProfileInput | ProfileMealTouchedCreateOrConnectWithoutProfileInput[]
    upsert?: ProfileMealTouchedUpsertWithWhereUniqueWithoutProfileInput | ProfileMealTouchedUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProfileMealTouchedCreateManyProfileInputEnvelope
    set?: ProfileMealTouchedWhereUniqueInput | ProfileMealTouchedWhereUniqueInput[]
    disconnect?: ProfileMealTouchedWhereUniqueInput | ProfileMealTouchedWhereUniqueInput[]
    delete?: ProfileMealTouchedWhereUniqueInput | ProfileMealTouchedWhereUniqueInput[]
    connect?: ProfileMealTouchedWhereUniqueInput | ProfileMealTouchedWhereUniqueInput[]
    update?: ProfileMealTouchedUpdateWithWhereUniqueWithoutProfileInput | ProfileMealTouchedUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProfileMealTouchedUpdateManyWithWhereWithoutProfileInput | ProfileMealTouchedUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProfileMealTouchedScalarWhereInput | ProfileMealTouchedScalarWhereInput[]
  }

  export type WorkoutUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<WorkoutCreateWithoutProfileInput, WorkoutUncheckedCreateWithoutProfileInput> | WorkoutCreateWithoutProfileInput[] | WorkoutUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: WorkoutCreateOrConnectWithoutProfileInput | WorkoutCreateOrConnectWithoutProfileInput[]
    upsert?: WorkoutUpsertWithWhereUniqueWithoutProfileInput | WorkoutUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: WorkoutCreateManyProfileInputEnvelope
    set?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
    disconnect?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
    delete?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
    connect?: WorkoutWhereUniqueInput | WorkoutWhereUniqueInput[]
    update?: WorkoutUpdateWithWhereUniqueWithoutProfileInput | WorkoutUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: WorkoutUpdateManyWithWhereWithoutProfileInput | WorkoutUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: WorkoutScalarWhereInput | WorkoutScalarWhereInput[]
  }

  export type MealUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<MealCreateWithoutProfileInput, MealUncheckedCreateWithoutProfileInput> | MealCreateWithoutProfileInput[] | MealUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: MealCreateOrConnectWithoutProfileInput | MealCreateOrConnectWithoutProfileInput[]
    upsert?: MealUpsertWithWhereUniqueWithoutProfileInput | MealUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: MealCreateManyProfileInputEnvelope
    set?: MealWhereUniqueInput | MealWhereUniqueInput[]
    disconnect?: MealWhereUniqueInput | MealWhereUniqueInput[]
    delete?: MealWhereUniqueInput | MealWhereUniqueInput[]
    connect?: MealWhereUniqueInput | MealWhereUniqueInput[]
    update?: MealUpdateWithWhereUniqueWithoutProfileInput | MealUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: MealUpdateManyWithWhereWithoutProfileInput | MealUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: MealScalarWhereInput | MealScalarWhereInput[]
  }

  export type ProfileWorkoutLikesUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProfileWorkoutLikesCreateWithoutProfileInput, ProfileWorkoutLikesUncheckedCreateWithoutProfileInput> | ProfileWorkoutLikesCreateWithoutProfileInput[] | ProfileWorkoutLikesUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileWorkoutLikesCreateOrConnectWithoutProfileInput | ProfileWorkoutLikesCreateOrConnectWithoutProfileInput[]
    upsert?: ProfileWorkoutLikesUpsertWithWhereUniqueWithoutProfileInput | ProfileWorkoutLikesUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProfileWorkoutLikesCreateManyProfileInputEnvelope
    set?: ProfileWorkoutLikesWhereUniqueInput | ProfileWorkoutLikesWhereUniqueInput[]
    disconnect?: ProfileWorkoutLikesWhereUniqueInput | ProfileWorkoutLikesWhereUniqueInput[]
    delete?: ProfileWorkoutLikesWhereUniqueInput | ProfileWorkoutLikesWhereUniqueInput[]
    connect?: ProfileWorkoutLikesWhereUniqueInput | ProfileWorkoutLikesWhereUniqueInput[]
    update?: ProfileWorkoutLikesUpdateWithWhereUniqueWithoutProfileInput | ProfileWorkoutLikesUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProfileWorkoutLikesUpdateManyWithWhereWithoutProfileInput | ProfileWorkoutLikesUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProfileWorkoutLikesScalarWhereInput | ProfileWorkoutLikesScalarWhereInput[]
  }

  export type ProfileWorkoutTouchedUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProfileWorkoutTouchedCreateWithoutProfileInput, ProfileWorkoutTouchedUncheckedCreateWithoutProfileInput> | ProfileWorkoutTouchedCreateWithoutProfileInput[] | ProfileWorkoutTouchedUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileWorkoutTouchedCreateOrConnectWithoutProfileInput | ProfileWorkoutTouchedCreateOrConnectWithoutProfileInput[]
    upsert?: ProfileWorkoutTouchedUpsertWithWhereUniqueWithoutProfileInput | ProfileWorkoutTouchedUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProfileWorkoutTouchedCreateManyProfileInputEnvelope
    set?: ProfileWorkoutTouchedWhereUniqueInput | ProfileWorkoutTouchedWhereUniqueInput[]
    disconnect?: ProfileWorkoutTouchedWhereUniqueInput | ProfileWorkoutTouchedWhereUniqueInput[]
    delete?: ProfileWorkoutTouchedWhereUniqueInput | ProfileWorkoutTouchedWhereUniqueInput[]
    connect?: ProfileWorkoutTouchedWhereUniqueInput | ProfileWorkoutTouchedWhereUniqueInput[]
    update?: ProfileWorkoutTouchedUpdateWithWhereUniqueWithoutProfileInput | ProfileWorkoutTouchedUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProfileWorkoutTouchedUpdateManyWithWhereWithoutProfileInput | ProfileWorkoutTouchedUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProfileWorkoutTouchedScalarWhereInput | ProfileWorkoutTouchedScalarWhereInput[]
  }

  export type ProfileMealLikesUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProfileMealLikesCreateWithoutProfileInput, ProfileMealLikesUncheckedCreateWithoutProfileInput> | ProfileMealLikesCreateWithoutProfileInput[] | ProfileMealLikesUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileMealLikesCreateOrConnectWithoutProfileInput | ProfileMealLikesCreateOrConnectWithoutProfileInput[]
    upsert?: ProfileMealLikesUpsertWithWhereUniqueWithoutProfileInput | ProfileMealLikesUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProfileMealLikesCreateManyProfileInputEnvelope
    set?: ProfileMealLikesWhereUniqueInput | ProfileMealLikesWhereUniqueInput[]
    disconnect?: ProfileMealLikesWhereUniqueInput | ProfileMealLikesWhereUniqueInput[]
    delete?: ProfileMealLikesWhereUniqueInput | ProfileMealLikesWhereUniqueInput[]
    connect?: ProfileMealLikesWhereUniqueInput | ProfileMealLikesWhereUniqueInput[]
    update?: ProfileMealLikesUpdateWithWhereUniqueWithoutProfileInput | ProfileMealLikesUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProfileMealLikesUpdateManyWithWhereWithoutProfileInput | ProfileMealLikesUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProfileMealLikesScalarWhereInput | ProfileMealLikesScalarWhereInput[]
  }

  export type ProfileMealTouchedUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProfileMealTouchedCreateWithoutProfileInput, ProfileMealTouchedUncheckedCreateWithoutProfileInput> | ProfileMealTouchedCreateWithoutProfileInput[] | ProfileMealTouchedUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileMealTouchedCreateOrConnectWithoutProfileInput | ProfileMealTouchedCreateOrConnectWithoutProfileInput[]
    upsert?: ProfileMealTouchedUpsertWithWhereUniqueWithoutProfileInput | ProfileMealTouchedUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProfileMealTouchedCreateManyProfileInputEnvelope
    set?: ProfileMealTouchedWhereUniqueInput | ProfileMealTouchedWhereUniqueInput[]
    disconnect?: ProfileMealTouchedWhereUniqueInput | ProfileMealTouchedWhereUniqueInput[]
    delete?: ProfileMealTouchedWhereUniqueInput | ProfileMealTouchedWhereUniqueInput[]
    connect?: ProfileMealTouchedWhereUniqueInput | ProfileMealTouchedWhereUniqueInput[]
    update?: ProfileMealTouchedUpdateWithWhereUniqueWithoutProfileInput | ProfileMealTouchedUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProfileMealTouchedUpdateManyWithWhereWithoutProfileInput | ProfileMealTouchedUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProfileMealTouchedScalarWhereInput | ProfileMealTouchedScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutWorkoutsInput = {
    create?: XOR<ProfileCreateWithoutWorkoutsInput, ProfileUncheckedCreateWithoutWorkoutsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutWorkoutsInput
    connect?: ProfileWhereUniqueInput
  }

  export type ExerciseCreateNestedManyWithoutWorkoutInput = {
    create?: XOR<ExerciseCreateWithoutWorkoutInput, ExerciseUncheckedCreateWithoutWorkoutInput> | ExerciseCreateWithoutWorkoutInput[] | ExerciseUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutWorkoutInput | ExerciseCreateOrConnectWithoutWorkoutInput[]
    createMany?: ExerciseCreateManyWorkoutInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type ProfileWorkoutLikesCreateNestedManyWithoutWorkoutInput = {
    create?: XOR<ProfileWorkoutLikesCreateWithoutWorkoutInput, ProfileWorkoutLikesUncheckedCreateWithoutWorkoutInput> | ProfileWorkoutLikesCreateWithoutWorkoutInput[] | ProfileWorkoutLikesUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: ProfileWorkoutLikesCreateOrConnectWithoutWorkoutInput | ProfileWorkoutLikesCreateOrConnectWithoutWorkoutInput[]
    createMany?: ProfileWorkoutLikesCreateManyWorkoutInputEnvelope
    connect?: ProfileWorkoutLikesWhereUniqueInput | ProfileWorkoutLikesWhereUniqueInput[]
  }

  export type ProfileWorkoutTouchedCreateNestedManyWithoutWorkoutInput = {
    create?: XOR<ProfileWorkoutTouchedCreateWithoutWorkoutInput, ProfileWorkoutTouchedUncheckedCreateWithoutWorkoutInput> | ProfileWorkoutTouchedCreateWithoutWorkoutInput[] | ProfileWorkoutTouchedUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: ProfileWorkoutTouchedCreateOrConnectWithoutWorkoutInput | ProfileWorkoutTouchedCreateOrConnectWithoutWorkoutInput[]
    createMany?: ProfileWorkoutTouchedCreateManyWorkoutInputEnvelope
    connect?: ProfileWorkoutTouchedWhereUniqueInput | ProfileWorkoutTouchedWhereUniqueInput[]
  }

  export type ExerciseUncheckedCreateNestedManyWithoutWorkoutInput = {
    create?: XOR<ExerciseCreateWithoutWorkoutInput, ExerciseUncheckedCreateWithoutWorkoutInput> | ExerciseCreateWithoutWorkoutInput[] | ExerciseUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutWorkoutInput | ExerciseCreateOrConnectWithoutWorkoutInput[]
    createMany?: ExerciseCreateManyWorkoutInputEnvelope
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
  }

  export type ProfileWorkoutLikesUncheckedCreateNestedManyWithoutWorkoutInput = {
    create?: XOR<ProfileWorkoutLikesCreateWithoutWorkoutInput, ProfileWorkoutLikesUncheckedCreateWithoutWorkoutInput> | ProfileWorkoutLikesCreateWithoutWorkoutInput[] | ProfileWorkoutLikesUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: ProfileWorkoutLikesCreateOrConnectWithoutWorkoutInput | ProfileWorkoutLikesCreateOrConnectWithoutWorkoutInput[]
    createMany?: ProfileWorkoutLikesCreateManyWorkoutInputEnvelope
    connect?: ProfileWorkoutLikesWhereUniqueInput | ProfileWorkoutLikesWhereUniqueInput[]
  }

  export type ProfileWorkoutTouchedUncheckedCreateNestedManyWithoutWorkoutInput = {
    create?: XOR<ProfileWorkoutTouchedCreateWithoutWorkoutInput, ProfileWorkoutTouchedUncheckedCreateWithoutWorkoutInput> | ProfileWorkoutTouchedCreateWithoutWorkoutInput[] | ProfileWorkoutTouchedUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: ProfileWorkoutTouchedCreateOrConnectWithoutWorkoutInput | ProfileWorkoutTouchedCreateOrConnectWithoutWorkoutInput[]
    createMany?: ProfileWorkoutTouchedCreateManyWorkoutInputEnvelope
    connect?: ProfileWorkoutTouchedWhereUniqueInput | ProfileWorkoutTouchedWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProfileUpdateOneRequiredWithoutWorkoutsNestedInput = {
    create?: XOR<ProfileCreateWithoutWorkoutsInput, ProfileUncheckedCreateWithoutWorkoutsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutWorkoutsInput
    upsert?: ProfileUpsertWithoutWorkoutsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutWorkoutsInput, ProfileUpdateWithoutWorkoutsInput>, ProfileUncheckedUpdateWithoutWorkoutsInput>
  }

  export type ExerciseUpdateManyWithoutWorkoutNestedInput = {
    create?: XOR<ExerciseCreateWithoutWorkoutInput, ExerciseUncheckedCreateWithoutWorkoutInput> | ExerciseCreateWithoutWorkoutInput[] | ExerciseUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutWorkoutInput | ExerciseCreateOrConnectWithoutWorkoutInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutWorkoutInput | ExerciseUpsertWithWhereUniqueWithoutWorkoutInput[]
    createMany?: ExerciseCreateManyWorkoutInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutWorkoutInput | ExerciseUpdateWithWhereUniqueWithoutWorkoutInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutWorkoutInput | ExerciseUpdateManyWithWhereWithoutWorkoutInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type ProfileWorkoutLikesUpdateManyWithoutWorkoutNestedInput = {
    create?: XOR<ProfileWorkoutLikesCreateWithoutWorkoutInput, ProfileWorkoutLikesUncheckedCreateWithoutWorkoutInput> | ProfileWorkoutLikesCreateWithoutWorkoutInput[] | ProfileWorkoutLikesUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: ProfileWorkoutLikesCreateOrConnectWithoutWorkoutInput | ProfileWorkoutLikesCreateOrConnectWithoutWorkoutInput[]
    upsert?: ProfileWorkoutLikesUpsertWithWhereUniqueWithoutWorkoutInput | ProfileWorkoutLikesUpsertWithWhereUniqueWithoutWorkoutInput[]
    createMany?: ProfileWorkoutLikesCreateManyWorkoutInputEnvelope
    set?: ProfileWorkoutLikesWhereUniqueInput | ProfileWorkoutLikesWhereUniqueInput[]
    disconnect?: ProfileWorkoutLikesWhereUniqueInput | ProfileWorkoutLikesWhereUniqueInput[]
    delete?: ProfileWorkoutLikesWhereUniqueInput | ProfileWorkoutLikesWhereUniqueInput[]
    connect?: ProfileWorkoutLikesWhereUniqueInput | ProfileWorkoutLikesWhereUniqueInput[]
    update?: ProfileWorkoutLikesUpdateWithWhereUniqueWithoutWorkoutInput | ProfileWorkoutLikesUpdateWithWhereUniqueWithoutWorkoutInput[]
    updateMany?: ProfileWorkoutLikesUpdateManyWithWhereWithoutWorkoutInput | ProfileWorkoutLikesUpdateManyWithWhereWithoutWorkoutInput[]
    deleteMany?: ProfileWorkoutLikesScalarWhereInput | ProfileWorkoutLikesScalarWhereInput[]
  }

  export type ProfileWorkoutTouchedUpdateManyWithoutWorkoutNestedInput = {
    create?: XOR<ProfileWorkoutTouchedCreateWithoutWorkoutInput, ProfileWorkoutTouchedUncheckedCreateWithoutWorkoutInput> | ProfileWorkoutTouchedCreateWithoutWorkoutInput[] | ProfileWorkoutTouchedUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: ProfileWorkoutTouchedCreateOrConnectWithoutWorkoutInput | ProfileWorkoutTouchedCreateOrConnectWithoutWorkoutInput[]
    upsert?: ProfileWorkoutTouchedUpsertWithWhereUniqueWithoutWorkoutInput | ProfileWorkoutTouchedUpsertWithWhereUniqueWithoutWorkoutInput[]
    createMany?: ProfileWorkoutTouchedCreateManyWorkoutInputEnvelope
    set?: ProfileWorkoutTouchedWhereUniqueInput | ProfileWorkoutTouchedWhereUniqueInput[]
    disconnect?: ProfileWorkoutTouchedWhereUniqueInput | ProfileWorkoutTouchedWhereUniqueInput[]
    delete?: ProfileWorkoutTouchedWhereUniqueInput | ProfileWorkoutTouchedWhereUniqueInput[]
    connect?: ProfileWorkoutTouchedWhereUniqueInput | ProfileWorkoutTouchedWhereUniqueInput[]
    update?: ProfileWorkoutTouchedUpdateWithWhereUniqueWithoutWorkoutInput | ProfileWorkoutTouchedUpdateWithWhereUniqueWithoutWorkoutInput[]
    updateMany?: ProfileWorkoutTouchedUpdateManyWithWhereWithoutWorkoutInput | ProfileWorkoutTouchedUpdateManyWithWhereWithoutWorkoutInput[]
    deleteMany?: ProfileWorkoutTouchedScalarWhereInput | ProfileWorkoutTouchedScalarWhereInput[]
  }

  export type ExerciseUncheckedUpdateManyWithoutWorkoutNestedInput = {
    create?: XOR<ExerciseCreateWithoutWorkoutInput, ExerciseUncheckedCreateWithoutWorkoutInput> | ExerciseCreateWithoutWorkoutInput[] | ExerciseUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: ExerciseCreateOrConnectWithoutWorkoutInput | ExerciseCreateOrConnectWithoutWorkoutInput[]
    upsert?: ExerciseUpsertWithWhereUniqueWithoutWorkoutInput | ExerciseUpsertWithWhereUniqueWithoutWorkoutInput[]
    createMany?: ExerciseCreateManyWorkoutInputEnvelope
    set?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    disconnect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    delete?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    connect?: ExerciseWhereUniqueInput | ExerciseWhereUniqueInput[]
    update?: ExerciseUpdateWithWhereUniqueWithoutWorkoutInput | ExerciseUpdateWithWhereUniqueWithoutWorkoutInput[]
    updateMany?: ExerciseUpdateManyWithWhereWithoutWorkoutInput | ExerciseUpdateManyWithWhereWithoutWorkoutInput[]
    deleteMany?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
  }

  export type ProfileWorkoutLikesUncheckedUpdateManyWithoutWorkoutNestedInput = {
    create?: XOR<ProfileWorkoutLikesCreateWithoutWorkoutInput, ProfileWorkoutLikesUncheckedCreateWithoutWorkoutInput> | ProfileWorkoutLikesCreateWithoutWorkoutInput[] | ProfileWorkoutLikesUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: ProfileWorkoutLikesCreateOrConnectWithoutWorkoutInput | ProfileWorkoutLikesCreateOrConnectWithoutWorkoutInput[]
    upsert?: ProfileWorkoutLikesUpsertWithWhereUniqueWithoutWorkoutInput | ProfileWorkoutLikesUpsertWithWhereUniqueWithoutWorkoutInput[]
    createMany?: ProfileWorkoutLikesCreateManyWorkoutInputEnvelope
    set?: ProfileWorkoutLikesWhereUniqueInput | ProfileWorkoutLikesWhereUniqueInput[]
    disconnect?: ProfileWorkoutLikesWhereUniqueInput | ProfileWorkoutLikesWhereUniqueInput[]
    delete?: ProfileWorkoutLikesWhereUniqueInput | ProfileWorkoutLikesWhereUniqueInput[]
    connect?: ProfileWorkoutLikesWhereUniqueInput | ProfileWorkoutLikesWhereUniqueInput[]
    update?: ProfileWorkoutLikesUpdateWithWhereUniqueWithoutWorkoutInput | ProfileWorkoutLikesUpdateWithWhereUniqueWithoutWorkoutInput[]
    updateMany?: ProfileWorkoutLikesUpdateManyWithWhereWithoutWorkoutInput | ProfileWorkoutLikesUpdateManyWithWhereWithoutWorkoutInput[]
    deleteMany?: ProfileWorkoutLikesScalarWhereInput | ProfileWorkoutLikesScalarWhereInput[]
  }

  export type ProfileWorkoutTouchedUncheckedUpdateManyWithoutWorkoutNestedInput = {
    create?: XOR<ProfileWorkoutTouchedCreateWithoutWorkoutInput, ProfileWorkoutTouchedUncheckedCreateWithoutWorkoutInput> | ProfileWorkoutTouchedCreateWithoutWorkoutInput[] | ProfileWorkoutTouchedUncheckedCreateWithoutWorkoutInput[]
    connectOrCreate?: ProfileWorkoutTouchedCreateOrConnectWithoutWorkoutInput | ProfileWorkoutTouchedCreateOrConnectWithoutWorkoutInput[]
    upsert?: ProfileWorkoutTouchedUpsertWithWhereUniqueWithoutWorkoutInput | ProfileWorkoutTouchedUpsertWithWhereUniqueWithoutWorkoutInput[]
    createMany?: ProfileWorkoutTouchedCreateManyWorkoutInputEnvelope
    set?: ProfileWorkoutTouchedWhereUniqueInput | ProfileWorkoutTouchedWhereUniqueInput[]
    disconnect?: ProfileWorkoutTouchedWhereUniqueInput | ProfileWorkoutTouchedWhereUniqueInput[]
    delete?: ProfileWorkoutTouchedWhereUniqueInput | ProfileWorkoutTouchedWhereUniqueInput[]
    connect?: ProfileWorkoutTouchedWhereUniqueInput | ProfileWorkoutTouchedWhereUniqueInput[]
    update?: ProfileWorkoutTouchedUpdateWithWhereUniqueWithoutWorkoutInput | ProfileWorkoutTouchedUpdateWithWhereUniqueWithoutWorkoutInput[]
    updateMany?: ProfileWorkoutTouchedUpdateManyWithWhereWithoutWorkoutInput | ProfileWorkoutTouchedUpdateManyWithWhereWithoutWorkoutInput[]
    deleteMany?: ProfileWorkoutTouchedScalarWhereInput | ProfileWorkoutTouchedScalarWhereInput[]
  }

  export type WorkoutCreateNestedOneWithoutExercisesInput = {
    create?: XOR<WorkoutCreateWithoutExercisesInput, WorkoutUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: WorkoutCreateOrConnectWithoutExercisesInput
    connect?: WorkoutWhereUniqueInput
  }

  export type SetCreateNestedManyWithoutExerciseInput = {
    create?: XOR<SetCreateWithoutExerciseInput, SetUncheckedCreateWithoutExerciseInput> | SetCreateWithoutExerciseInput[] | SetUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: SetCreateOrConnectWithoutExerciseInput | SetCreateOrConnectWithoutExerciseInput[]
    createMany?: SetCreateManyExerciseInputEnvelope
    connect?: SetWhereUniqueInput | SetWhereUniqueInput[]
  }

  export type SetUncheckedCreateNestedManyWithoutExerciseInput = {
    create?: XOR<SetCreateWithoutExerciseInput, SetUncheckedCreateWithoutExerciseInput> | SetCreateWithoutExerciseInput[] | SetUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: SetCreateOrConnectWithoutExerciseInput | SetCreateOrConnectWithoutExerciseInput[]
    createMany?: SetCreateManyExerciseInputEnvelope
    connect?: SetWhereUniqueInput | SetWhereUniqueInput[]
  }

  export type WorkoutUpdateOneRequiredWithoutExercisesNestedInput = {
    create?: XOR<WorkoutCreateWithoutExercisesInput, WorkoutUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: WorkoutCreateOrConnectWithoutExercisesInput
    upsert?: WorkoutUpsertWithoutExercisesInput
    connect?: WorkoutWhereUniqueInput
    update?: XOR<XOR<WorkoutUpdateToOneWithWhereWithoutExercisesInput, WorkoutUpdateWithoutExercisesInput>, WorkoutUncheckedUpdateWithoutExercisesInput>
  }

  export type SetUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<SetCreateWithoutExerciseInput, SetUncheckedCreateWithoutExerciseInput> | SetCreateWithoutExerciseInput[] | SetUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: SetCreateOrConnectWithoutExerciseInput | SetCreateOrConnectWithoutExerciseInput[]
    upsert?: SetUpsertWithWhereUniqueWithoutExerciseInput | SetUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: SetCreateManyExerciseInputEnvelope
    set?: SetWhereUniqueInput | SetWhereUniqueInput[]
    disconnect?: SetWhereUniqueInput | SetWhereUniqueInput[]
    delete?: SetWhereUniqueInput | SetWhereUniqueInput[]
    connect?: SetWhereUniqueInput | SetWhereUniqueInput[]
    update?: SetUpdateWithWhereUniqueWithoutExerciseInput | SetUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: SetUpdateManyWithWhereWithoutExerciseInput | SetUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: SetScalarWhereInput | SetScalarWhereInput[]
  }

  export type SetUncheckedUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<SetCreateWithoutExerciseInput, SetUncheckedCreateWithoutExerciseInput> | SetCreateWithoutExerciseInput[] | SetUncheckedCreateWithoutExerciseInput[]
    connectOrCreate?: SetCreateOrConnectWithoutExerciseInput | SetCreateOrConnectWithoutExerciseInput[]
    upsert?: SetUpsertWithWhereUniqueWithoutExerciseInput | SetUpsertWithWhereUniqueWithoutExerciseInput[]
    createMany?: SetCreateManyExerciseInputEnvelope
    set?: SetWhereUniqueInput | SetWhereUniqueInput[]
    disconnect?: SetWhereUniqueInput | SetWhereUniqueInput[]
    delete?: SetWhereUniqueInput | SetWhereUniqueInput[]
    connect?: SetWhereUniqueInput | SetWhereUniqueInput[]
    update?: SetUpdateWithWhereUniqueWithoutExerciseInput | SetUpdateWithWhereUniqueWithoutExerciseInput[]
    updateMany?: SetUpdateManyWithWhereWithoutExerciseInput | SetUpdateManyWithWhereWithoutExerciseInput[]
    deleteMany?: SetScalarWhereInput | SetScalarWhereInput[]
  }

  export type ExerciseCreateNestedOneWithoutSetsInput = {
    create?: XOR<ExerciseCreateWithoutSetsInput, ExerciseUncheckedCreateWithoutSetsInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutSetsInput
    connect?: ExerciseWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ExerciseUpdateOneRequiredWithoutSetsNestedInput = {
    create?: XOR<ExerciseCreateWithoutSetsInput, ExerciseUncheckedCreateWithoutSetsInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutSetsInput
    upsert?: ExerciseUpsertWithoutSetsInput
    connect?: ExerciseWhereUniqueInput
    update?: XOR<XOR<ExerciseUpdateToOneWithWhereWithoutSetsInput, ExerciseUpdateWithoutSetsInput>, ExerciseUncheckedUpdateWithoutSetsInput>
  }

  export type ProfileCreateNestedOneWithoutMealsInput = {
    create?: XOR<ProfileCreateWithoutMealsInput, ProfileUncheckedCreateWithoutMealsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutMealsInput
    connect?: ProfileWhereUniqueInput
  }

  export type FoodCreateNestedManyWithoutMealInput = {
    create?: XOR<FoodCreateWithoutMealInput, FoodUncheckedCreateWithoutMealInput> | FoodCreateWithoutMealInput[] | FoodUncheckedCreateWithoutMealInput[]
    connectOrCreate?: FoodCreateOrConnectWithoutMealInput | FoodCreateOrConnectWithoutMealInput[]
    createMany?: FoodCreateManyMealInputEnvelope
    connect?: FoodWhereUniqueInput | FoodWhereUniqueInput[]
  }

  export type ProfileMealLikesCreateNestedManyWithoutMealInput = {
    create?: XOR<ProfileMealLikesCreateWithoutMealInput, ProfileMealLikesUncheckedCreateWithoutMealInput> | ProfileMealLikesCreateWithoutMealInput[] | ProfileMealLikesUncheckedCreateWithoutMealInput[]
    connectOrCreate?: ProfileMealLikesCreateOrConnectWithoutMealInput | ProfileMealLikesCreateOrConnectWithoutMealInput[]
    createMany?: ProfileMealLikesCreateManyMealInputEnvelope
    connect?: ProfileMealLikesWhereUniqueInput | ProfileMealLikesWhereUniqueInput[]
  }

  export type ProfileMealTouchedCreateNestedManyWithoutMealInput = {
    create?: XOR<ProfileMealTouchedCreateWithoutMealInput, ProfileMealTouchedUncheckedCreateWithoutMealInput> | ProfileMealTouchedCreateWithoutMealInput[] | ProfileMealTouchedUncheckedCreateWithoutMealInput[]
    connectOrCreate?: ProfileMealTouchedCreateOrConnectWithoutMealInput | ProfileMealTouchedCreateOrConnectWithoutMealInput[]
    createMany?: ProfileMealTouchedCreateManyMealInputEnvelope
    connect?: ProfileMealTouchedWhereUniqueInput | ProfileMealTouchedWhereUniqueInput[]
  }

  export type FoodUncheckedCreateNestedManyWithoutMealInput = {
    create?: XOR<FoodCreateWithoutMealInput, FoodUncheckedCreateWithoutMealInput> | FoodCreateWithoutMealInput[] | FoodUncheckedCreateWithoutMealInput[]
    connectOrCreate?: FoodCreateOrConnectWithoutMealInput | FoodCreateOrConnectWithoutMealInput[]
    createMany?: FoodCreateManyMealInputEnvelope
    connect?: FoodWhereUniqueInput | FoodWhereUniqueInput[]
  }

  export type ProfileMealLikesUncheckedCreateNestedManyWithoutMealInput = {
    create?: XOR<ProfileMealLikesCreateWithoutMealInput, ProfileMealLikesUncheckedCreateWithoutMealInput> | ProfileMealLikesCreateWithoutMealInput[] | ProfileMealLikesUncheckedCreateWithoutMealInput[]
    connectOrCreate?: ProfileMealLikesCreateOrConnectWithoutMealInput | ProfileMealLikesCreateOrConnectWithoutMealInput[]
    createMany?: ProfileMealLikesCreateManyMealInputEnvelope
    connect?: ProfileMealLikesWhereUniqueInput | ProfileMealLikesWhereUniqueInput[]
  }

  export type ProfileMealTouchedUncheckedCreateNestedManyWithoutMealInput = {
    create?: XOR<ProfileMealTouchedCreateWithoutMealInput, ProfileMealTouchedUncheckedCreateWithoutMealInput> | ProfileMealTouchedCreateWithoutMealInput[] | ProfileMealTouchedUncheckedCreateWithoutMealInput[]
    connectOrCreate?: ProfileMealTouchedCreateOrConnectWithoutMealInput | ProfileMealTouchedCreateOrConnectWithoutMealInput[]
    createMany?: ProfileMealTouchedCreateManyMealInputEnvelope
    connect?: ProfileMealTouchedWhereUniqueInput | ProfileMealTouchedWhereUniqueInput[]
  }

  export type ProfileUpdateOneRequiredWithoutMealsNestedInput = {
    create?: XOR<ProfileCreateWithoutMealsInput, ProfileUncheckedCreateWithoutMealsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutMealsInput
    upsert?: ProfileUpsertWithoutMealsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutMealsInput, ProfileUpdateWithoutMealsInput>, ProfileUncheckedUpdateWithoutMealsInput>
  }

  export type FoodUpdateManyWithoutMealNestedInput = {
    create?: XOR<FoodCreateWithoutMealInput, FoodUncheckedCreateWithoutMealInput> | FoodCreateWithoutMealInput[] | FoodUncheckedCreateWithoutMealInput[]
    connectOrCreate?: FoodCreateOrConnectWithoutMealInput | FoodCreateOrConnectWithoutMealInput[]
    upsert?: FoodUpsertWithWhereUniqueWithoutMealInput | FoodUpsertWithWhereUniqueWithoutMealInput[]
    createMany?: FoodCreateManyMealInputEnvelope
    set?: FoodWhereUniqueInput | FoodWhereUniqueInput[]
    disconnect?: FoodWhereUniqueInput | FoodWhereUniqueInput[]
    delete?: FoodWhereUniqueInput | FoodWhereUniqueInput[]
    connect?: FoodWhereUniqueInput | FoodWhereUniqueInput[]
    update?: FoodUpdateWithWhereUniqueWithoutMealInput | FoodUpdateWithWhereUniqueWithoutMealInput[]
    updateMany?: FoodUpdateManyWithWhereWithoutMealInput | FoodUpdateManyWithWhereWithoutMealInput[]
    deleteMany?: FoodScalarWhereInput | FoodScalarWhereInput[]
  }

  export type ProfileMealLikesUpdateManyWithoutMealNestedInput = {
    create?: XOR<ProfileMealLikesCreateWithoutMealInput, ProfileMealLikesUncheckedCreateWithoutMealInput> | ProfileMealLikesCreateWithoutMealInput[] | ProfileMealLikesUncheckedCreateWithoutMealInput[]
    connectOrCreate?: ProfileMealLikesCreateOrConnectWithoutMealInput | ProfileMealLikesCreateOrConnectWithoutMealInput[]
    upsert?: ProfileMealLikesUpsertWithWhereUniqueWithoutMealInput | ProfileMealLikesUpsertWithWhereUniqueWithoutMealInput[]
    createMany?: ProfileMealLikesCreateManyMealInputEnvelope
    set?: ProfileMealLikesWhereUniqueInput | ProfileMealLikesWhereUniqueInput[]
    disconnect?: ProfileMealLikesWhereUniqueInput | ProfileMealLikesWhereUniqueInput[]
    delete?: ProfileMealLikesWhereUniqueInput | ProfileMealLikesWhereUniqueInput[]
    connect?: ProfileMealLikesWhereUniqueInput | ProfileMealLikesWhereUniqueInput[]
    update?: ProfileMealLikesUpdateWithWhereUniqueWithoutMealInput | ProfileMealLikesUpdateWithWhereUniqueWithoutMealInput[]
    updateMany?: ProfileMealLikesUpdateManyWithWhereWithoutMealInput | ProfileMealLikesUpdateManyWithWhereWithoutMealInput[]
    deleteMany?: ProfileMealLikesScalarWhereInput | ProfileMealLikesScalarWhereInput[]
  }

  export type ProfileMealTouchedUpdateManyWithoutMealNestedInput = {
    create?: XOR<ProfileMealTouchedCreateWithoutMealInput, ProfileMealTouchedUncheckedCreateWithoutMealInput> | ProfileMealTouchedCreateWithoutMealInput[] | ProfileMealTouchedUncheckedCreateWithoutMealInput[]
    connectOrCreate?: ProfileMealTouchedCreateOrConnectWithoutMealInput | ProfileMealTouchedCreateOrConnectWithoutMealInput[]
    upsert?: ProfileMealTouchedUpsertWithWhereUniqueWithoutMealInput | ProfileMealTouchedUpsertWithWhereUniqueWithoutMealInput[]
    createMany?: ProfileMealTouchedCreateManyMealInputEnvelope
    set?: ProfileMealTouchedWhereUniqueInput | ProfileMealTouchedWhereUniqueInput[]
    disconnect?: ProfileMealTouchedWhereUniqueInput | ProfileMealTouchedWhereUniqueInput[]
    delete?: ProfileMealTouchedWhereUniqueInput | ProfileMealTouchedWhereUniqueInput[]
    connect?: ProfileMealTouchedWhereUniqueInput | ProfileMealTouchedWhereUniqueInput[]
    update?: ProfileMealTouchedUpdateWithWhereUniqueWithoutMealInput | ProfileMealTouchedUpdateWithWhereUniqueWithoutMealInput[]
    updateMany?: ProfileMealTouchedUpdateManyWithWhereWithoutMealInput | ProfileMealTouchedUpdateManyWithWhereWithoutMealInput[]
    deleteMany?: ProfileMealTouchedScalarWhereInput | ProfileMealTouchedScalarWhereInput[]
  }

  export type FoodUncheckedUpdateManyWithoutMealNestedInput = {
    create?: XOR<FoodCreateWithoutMealInput, FoodUncheckedCreateWithoutMealInput> | FoodCreateWithoutMealInput[] | FoodUncheckedCreateWithoutMealInput[]
    connectOrCreate?: FoodCreateOrConnectWithoutMealInput | FoodCreateOrConnectWithoutMealInput[]
    upsert?: FoodUpsertWithWhereUniqueWithoutMealInput | FoodUpsertWithWhereUniqueWithoutMealInput[]
    createMany?: FoodCreateManyMealInputEnvelope
    set?: FoodWhereUniqueInput | FoodWhereUniqueInput[]
    disconnect?: FoodWhereUniqueInput | FoodWhereUniqueInput[]
    delete?: FoodWhereUniqueInput | FoodWhereUniqueInput[]
    connect?: FoodWhereUniqueInput | FoodWhereUniqueInput[]
    update?: FoodUpdateWithWhereUniqueWithoutMealInput | FoodUpdateWithWhereUniqueWithoutMealInput[]
    updateMany?: FoodUpdateManyWithWhereWithoutMealInput | FoodUpdateManyWithWhereWithoutMealInput[]
    deleteMany?: FoodScalarWhereInput | FoodScalarWhereInput[]
  }

  export type ProfileMealLikesUncheckedUpdateManyWithoutMealNestedInput = {
    create?: XOR<ProfileMealLikesCreateWithoutMealInput, ProfileMealLikesUncheckedCreateWithoutMealInput> | ProfileMealLikesCreateWithoutMealInput[] | ProfileMealLikesUncheckedCreateWithoutMealInput[]
    connectOrCreate?: ProfileMealLikesCreateOrConnectWithoutMealInput | ProfileMealLikesCreateOrConnectWithoutMealInput[]
    upsert?: ProfileMealLikesUpsertWithWhereUniqueWithoutMealInput | ProfileMealLikesUpsertWithWhereUniqueWithoutMealInput[]
    createMany?: ProfileMealLikesCreateManyMealInputEnvelope
    set?: ProfileMealLikesWhereUniqueInput | ProfileMealLikesWhereUniqueInput[]
    disconnect?: ProfileMealLikesWhereUniqueInput | ProfileMealLikesWhereUniqueInput[]
    delete?: ProfileMealLikesWhereUniqueInput | ProfileMealLikesWhereUniqueInput[]
    connect?: ProfileMealLikesWhereUniqueInput | ProfileMealLikesWhereUniqueInput[]
    update?: ProfileMealLikesUpdateWithWhereUniqueWithoutMealInput | ProfileMealLikesUpdateWithWhereUniqueWithoutMealInput[]
    updateMany?: ProfileMealLikesUpdateManyWithWhereWithoutMealInput | ProfileMealLikesUpdateManyWithWhereWithoutMealInput[]
    deleteMany?: ProfileMealLikesScalarWhereInput | ProfileMealLikesScalarWhereInput[]
  }

  export type ProfileMealTouchedUncheckedUpdateManyWithoutMealNestedInput = {
    create?: XOR<ProfileMealTouchedCreateWithoutMealInput, ProfileMealTouchedUncheckedCreateWithoutMealInput> | ProfileMealTouchedCreateWithoutMealInput[] | ProfileMealTouchedUncheckedCreateWithoutMealInput[]
    connectOrCreate?: ProfileMealTouchedCreateOrConnectWithoutMealInput | ProfileMealTouchedCreateOrConnectWithoutMealInput[]
    upsert?: ProfileMealTouchedUpsertWithWhereUniqueWithoutMealInput | ProfileMealTouchedUpsertWithWhereUniqueWithoutMealInput[]
    createMany?: ProfileMealTouchedCreateManyMealInputEnvelope
    set?: ProfileMealTouchedWhereUniqueInput | ProfileMealTouchedWhereUniqueInput[]
    disconnect?: ProfileMealTouchedWhereUniqueInput | ProfileMealTouchedWhereUniqueInput[]
    delete?: ProfileMealTouchedWhereUniqueInput | ProfileMealTouchedWhereUniqueInput[]
    connect?: ProfileMealTouchedWhereUniqueInput | ProfileMealTouchedWhereUniqueInput[]
    update?: ProfileMealTouchedUpdateWithWhereUniqueWithoutMealInput | ProfileMealTouchedUpdateWithWhereUniqueWithoutMealInput[]
    updateMany?: ProfileMealTouchedUpdateManyWithWhereWithoutMealInput | ProfileMealTouchedUpdateManyWithWhereWithoutMealInput[]
    deleteMany?: ProfileMealTouchedScalarWhereInput | ProfileMealTouchedScalarWhereInput[]
  }

  export type MealCreateNestedOneWithoutFoodsInput = {
    create?: XOR<MealCreateWithoutFoodsInput, MealUncheckedCreateWithoutFoodsInput>
    connectOrCreate?: MealCreateOrConnectWithoutFoodsInput
    connect?: MealWhereUniqueInput
  }

  export type MealUpdateOneRequiredWithoutFoodsNestedInput = {
    create?: XOR<MealCreateWithoutFoodsInput, MealUncheckedCreateWithoutFoodsInput>
    connectOrCreate?: MealCreateOrConnectWithoutFoodsInput
    upsert?: MealUpsertWithoutFoodsInput
    connect?: MealWhereUniqueInput
    update?: XOR<XOR<MealUpdateToOneWithWhereWithoutFoodsInput, MealUpdateWithoutFoodsInput>, MealUncheckedUpdateWithoutFoodsInput>
  }

  export type ProfileCreateNestedOneWithoutLikedWorkoutsInput = {
    create?: XOR<ProfileCreateWithoutLikedWorkoutsInput, ProfileUncheckedCreateWithoutLikedWorkoutsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutLikedWorkoutsInput
    connect?: ProfileWhereUniqueInput
  }

  export type WorkoutCreateNestedOneWithoutProfileLikesInput = {
    create?: XOR<WorkoutCreateWithoutProfileLikesInput, WorkoutUncheckedCreateWithoutProfileLikesInput>
    connectOrCreate?: WorkoutCreateOrConnectWithoutProfileLikesInput
    connect?: WorkoutWhereUniqueInput
  }

  export type ProfileUpdateOneWithoutLikedWorkoutsNestedInput = {
    create?: XOR<ProfileCreateWithoutLikedWorkoutsInput, ProfileUncheckedCreateWithoutLikedWorkoutsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutLikedWorkoutsInput
    upsert?: ProfileUpsertWithoutLikedWorkoutsInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutLikedWorkoutsInput, ProfileUpdateWithoutLikedWorkoutsInput>, ProfileUncheckedUpdateWithoutLikedWorkoutsInput>
  }

  export type WorkoutUpdateOneWithoutProfileLikesNestedInput = {
    create?: XOR<WorkoutCreateWithoutProfileLikesInput, WorkoutUncheckedCreateWithoutProfileLikesInput>
    connectOrCreate?: WorkoutCreateOrConnectWithoutProfileLikesInput
    upsert?: WorkoutUpsertWithoutProfileLikesInput
    disconnect?: WorkoutWhereInput | boolean
    delete?: WorkoutWhereInput | boolean
    connect?: WorkoutWhereUniqueInput
    update?: XOR<XOR<WorkoutUpdateToOneWithWhereWithoutProfileLikesInput, WorkoutUpdateWithoutProfileLikesInput>, WorkoutUncheckedUpdateWithoutProfileLikesInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProfileCreateNestedOneWithoutTouchWorkoutsInput = {
    create?: XOR<ProfileCreateWithoutTouchWorkoutsInput, ProfileUncheckedCreateWithoutTouchWorkoutsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutTouchWorkoutsInput
    connect?: ProfileWhereUniqueInput
  }

  export type WorkoutCreateNestedOneWithoutProfileTouchInput = {
    create?: XOR<WorkoutCreateWithoutProfileTouchInput, WorkoutUncheckedCreateWithoutProfileTouchInput>
    connectOrCreate?: WorkoutCreateOrConnectWithoutProfileTouchInput
    connect?: WorkoutWhereUniqueInput
  }

  export type ProfileUpdateOneWithoutTouchWorkoutsNestedInput = {
    create?: XOR<ProfileCreateWithoutTouchWorkoutsInput, ProfileUncheckedCreateWithoutTouchWorkoutsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutTouchWorkoutsInput
    upsert?: ProfileUpsertWithoutTouchWorkoutsInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutTouchWorkoutsInput, ProfileUpdateWithoutTouchWorkoutsInput>, ProfileUncheckedUpdateWithoutTouchWorkoutsInput>
  }

  export type WorkoutUpdateOneWithoutProfileTouchNestedInput = {
    create?: XOR<WorkoutCreateWithoutProfileTouchInput, WorkoutUncheckedCreateWithoutProfileTouchInput>
    connectOrCreate?: WorkoutCreateOrConnectWithoutProfileTouchInput
    upsert?: WorkoutUpsertWithoutProfileTouchInput
    disconnect?: WorkoutWhereInput | boolean
    delete?: WorkoutWhereInput | boolean
    connect?: WorkoutWhereUniqueInput
    update?: XOR<XOR<WorkoutUpdateToOneWithWhereWithoutProfileTouchInput, WorkoutUpdateWithoutProfileTouchInput>, WorkoutUncheckedUpdateWithoutProfileTouchInput>
  }

  export type ProfileCreateNestedOneWithoutLikedMealsInput = {
    create?: XOR<ProfileCreateWithoutLikedMealsInput, ProfileUncheckedCreateWithoutLikedMealsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutLikedMealsInput
    connect?: ProfileWhereUniqueInput
  }

  export type MealCreateNestedOneWithoutProfileLikesInput = {
    create?: XOR<MealCreateWithoutProfileLikesInput, MealUncheckedCreateWithoutProfileLikesInput>
    connectOrCreate?: MealCreateOrConnectWithoutProfileLikesInput
    connect?: MealWhereUniqueInput
  }

  export type ProfileUpdateOneWithoutLikedMealsNestedInput = {
    create?: XOR<ProfileCreateWithoutLikedMealsInput, ProfileUncheckedCreateWithoutLikedMealsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutLikedMealsInput
    upsert?: ProfileUpsertWithoutLikedMealsInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutLikedMealsInput, ProfileUpdateWithoutLikedMealsInput>, ProfileUncheckedUpdateWithoutLikedMealsInput>
  }

  export type MealUpdateOneWithoutProfileLikesNestedInput = {
    create?: XOR<MealCreateWithoutProfileLikesInput, MealUncheckedCreateWithoutProfileLikesInput>
    connectOrCreate?: MealCreateOrConnectWithoutProfileLikesInput
    upsert?: MealUpsertWithoutProfileLikesInput
    disconnect?: MealWhereInput | boolean
    delete?: MealWhereInput | boolean
    connect?: MealWhereUniqueInput
    update?: XOR<XOR<MealUpdateToOneWithWhereWithoutProfileLikesInput, MealUpdateWithoutProfileLikesInput>, MealUncheckedUpdateWithoutProfileLikesInput>
  }

  export type ProfileCreateNestedOneWithoutTouchMealsInput = {
    create?: XOR<ProfileCreateWithoutTouchMealsInput, ProfileUncheckedCreateWithoutTouchMealsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutTouchMealsInput
    connect?: ProfileWhereUniqueInput
  }

  export type MealCreateNestedOneWithoutProfileTouchInput = {
    create?: XOR<MealCreateWithoutProfileTouchInput, MealUncheckedCreateWithoutProfileTouchInput>
    connectOrCreate?: MealCreateOrConnectWithoutProfileTouchInput
    connect?: MealWhereUniqueInput
  }

  export type ProfileUpdateOneWithoutTouchMealsNestedInput = {
    create?: XOR<ProfileCreateWithoutTouchMealsInput, ProfileUncheckedCreateWithoutTouchMealsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutTouchMealsInput
    upsert?: ProfileUpsertWithoutTouchMealsInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutTouchMealsInput, ProfileUpdateWithoutTouchMealsInput>, ProfileUncheckedUpdateWithoutTouchMealsInput>
  }

  export type MealUpdateOneWithoutProfileTouchNestedInput = {
    create?: XOR<MealCreateWithoutProfileTouchInput, MealUncheckedCreateWithoutProfileTouchInput>
    connectOrCreate?: MealCreateOrConnectWithoutProfileTouchInput
    upsert?: MealUpsertWithoutProfileTouchInput
    disconnect?: MealWhereInput | boolean
    delete?: MealWhereInput | boolean
    connect?: MealWhereUniqueInput
    update?: XOR<XOR<MealUpdateToOneWithWhereWithoutProfileTouchInput, MealUpdateWithoutProfileTouchInput>, MealUncheckedUpdateWithoutProfileTouchInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type WorkoutCreateWithoutProfileInput = {
    notes: string
    private?: boolean
    exercises?: ExerciseCreateNestedManyWithoutWorkoutInput
    profileLikes?: ProfileWorkoutLikesCreateNestedManyWithoutWorkoutInput
    profileTouch?: ProfileWorkoutTouchedCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutUncheckedCreateWithoutProfileInput = {
    id?: number
    notes: string
    private?: boolean
    exercises?: ExerciseUncheckedCreateNestedManyWithoutWorkoutInput
    profileLikes?: ProfileWorkoutLikesUncheckedCreateNestedManyWithoutWorkoutInput
    profileTouch?: ProfileWorkoutTouchedUncheckedCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutCreateOrConnectWithoutProfileInput = {
    where: WorkoutWhereUniqueInput
    create: XOR<WorkoutCreateWithoutProfileInput, WorkoutUncheckedCreateWithoutProfileInput>
  }

  export type WorkoutCreateManyProfileInputEnvelope = {
    data: WorkoutCreateManyProfileInput | WorkoutCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type MealCreateWithoutProfileInput = {
    notes: string
    totalCalories: number
    totalCarbs: number
    totalFats: number
    totalProteins: number
    totalGrams: number
    private?: boolean
    foods?: FoodCreateNestedManyWithoutMealInput
    profileLikes?: ProfileMealLikesCreateNestedManyWithoutMealInput
    profileTouch?: ProfileMealTouchedCreateNestedManyWithoutMealInput
  }

  export type MealUncheckedCreateWithoutProfileInput = {
    id?: number
    notes: string
    totalCalories: number
    totalCarbs: number
    totalFats: number
    totalProteins: number
    totalGrams: number
    private?: boolean
    foods?: FoodUncheckedCreateNestedManyWithoutMealInput
    profileLikes?: ProfileMealLikesUncheckedCreateNestedManyWithoutMealInput
    profileTouch?: ProfileMealTouchedUncheckedCreateNestedManyWithoutMealInput
  }

  export type MealCreateOrConnectWithoutProfileInput = {
    where: MealWhereUniqueInput
    create: XOR<MealCreateWithoutProfileInput, MealUncheckedCreateWithoutProfileInput>
  }

  export type MealCreateManyProfileInputEnvelope = {
    data: MealCreateManyProfileInput | MealCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type ProfileWorkoutLikesCreateWithoutProfileInput = {
    workout?: WorkoutCreateNestedOneWithoutProfileLikesInput
  }

  export type ProfileWorkoutLikesUncheckedCreateWithoutProfileInput = {
    id?: number
    workoutId?: number | null
  }

  export type ProfileWorkoutLikesCreateOrConnectWithoutProfileInput = {
    where: ProfileWorkoutLikesWhereUniqueInput
    create: XOR<ProfileWorkoutLikesCreateWithoutProfileInput, ProfileWorkoutLikesUncheckedCreateWithoutProfileInput>
  }

  export type ProfileWorkoutLikesCreateManyProfileInputEnvelope = {
    data: ProfileWorkoutLikesCreateManyProfileInput | ProfileWorkoutLikesCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type ProfileWorkoutTouchedCreateWithoutProfileInput = {
    workout?: WorkoutCreateNestedOneWithoutProfileTouchInput
  }

  export type ProfileWorkoutTouchedUncheckedCreateWithoutProfileInput = {
    id?: number
    workoutId?: number | null
  }

  export type ProfileWorkoutTouchedCreateOrConnectWithoutProfileInput = {
    where: ProfileWorkoutTouchedWhereUniqueInput
    create: XOR<ProfileWorkoutTouchedCreateWithoutProfileInput, ProfileWorkoutTouchedUncheckedCreateWithoutProfileInput>
  }

  export type ProfileWorkoutTouchedCreateManyProfileInputEnvelope = {
    data: ProfileWorkoutTouchedCreateManyProfileInput | ProfileWorkoutTouchedCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type ProfileMealLikesCreateWithoutProfileInput = {
    meal?: MealCreateNestedOneWithoutProfileLikesInput
  }

  export type ProfileMealLikesUncheckedCreateWithoutProfileInput = {
    id?: number
    mealId?: number | null
  }

  export type ProfileMealLikesCreateOrConnectWithoutProfileInput = {
    where: ProfileMealLikesWhereUniqueInput
    create: XOR<ProfileMealLikesCreateWithoutProfileInput, ProfileMealLikesUncheckedCreateWithoutProfileInput>
  }

  export type ProfileMealLikesCreateManyProfileInputEnvelope = {
    data: ProfileMealLikesCreateManyProfileInput | ProfileMealLikesCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type ProfileMealTouchedCreateWithoutProfileInput = {
    meal?: MealCreateNestedOneWithoutProfileTouchInput
  }

  export type ProfileMealTouchedUncheckedCreateWithoutProfileInput = {
    id?: number
    mealId?: number | null
  }

  export type ProfileMealTouchedCreateOrConnectWithoutProfileInput = {
    where: ProfileMealTouchedWhereUniqueInput
    create: XOR<ProfileMealTouchedCreateWithoutProfileInput, ProfileMealTouchedUncheckedCreateWithoutProfileInput>
  }

  export type ProfileMealTouchedCreateManyProfileInputEnvelope = {
    data: ProfileMealTouchedCreateManyProfileInput | ProfileMealTouchedCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type WorkoutUpsertWithWhereUniqueWithoutProfileInput = {
    where: WorkoutWhereUniqueInput
    update: XOR<WorkoutUpdateWithoutProfileInput, WorkoutUncheckedUpdateWithoutProfileInput>
    create: XOR<WorkoutCreateWithoutProfileInput, WorkoutUncheckedCreateWithoutProfileInput>
  }

  export type WorkoutUpdateWithWhereUniqueWithoutProfileInput = {
    where: WorkoutWhereUniqueInput
    data: XOR<WorkoutUpdateWithoutProfileInput, WorkoutUncheckedUpdateWithoutProfileInput>
  }

  export type WorkoutUpdateManyWithWhereWithoutProfileInput = {
    where: WorkoutScalarWhereInput
    data: XOR<WorkoutUpdateManyMutationInput, WorkoutUncheckedUpdateManyWithoutProfileInput>
  }

  export type WorkoutScalarWhereInput = {
    AND?: WorkoutScalarWhereInput | WorkoutScalarWhereInput[]
    OR?: WorkoutScalarWhereInput[]
    NOT?: WorkoutScalarWhereInput | WorkoutScalarWhereInput[]
    id?: IntFilter<"Workout"> | number
    profileId?: IntFilter<"Workout"> | number
    notes?: StringFilter<"Workout"> | string
    private?: BoolFilter<"Workout"> | boolean
  }

  export type MealUpsertWithWhereUniqueWithoutProfileInput = {
    where: MealWhereUniqueInput
    update: XOR<MealUpdateWithoutProfileInput, MealUncheckedUpdateWithoutProfileInput>
    create: XOR<MealCreateWithoutProfileInput, MealUncheckedCreateWithoutProfileInput>
  }

  export type MealUpdateWithWhereUniqueWithoutProfileInput = {
    where: MealWhereUniqueInput
    data: XOR<MealUpdateWithoutProfileInput, MealUncheckedUpdateWithoutProfileInput>
  }

  export type MealUpdateManyWithWhereWithoutProfileInput = {
    where: MealScalarWhereInput
    data: XOR<MealUpdateManyMutationInput, MealUncheckedUpdateManyWithoutProfileInput>
  }

  export type MealScalarWhereInput = {
    AND?: MealScalarWhereInput | MealScalarWhereInput[]
    OR?: MealScalarWhereInput[]
    NOT?: MealScalarWhereInput | MealScalarWhereInput[]
    id?: IntFilter<"Meal"> | number
    profileId?: IntFilter<"Meal"> | number
    notes?: StringFilter<"Meal"> | string
    totalCalories?: FloatFilter<"Meal"> | number
    totalCarbs?: FloatFilter<"Meal"> | number
    totalFats?: FloatFilter<"Meal"> | number
    totalProteins?: FloatFilter<"Meal"> | number
    totalGrams?: FloatFilter<"Meal"> | number
    private?: BoolFilter<"Meal"> | boolean
  }

  export type ProfileWorkoutLikesUpsertWithWhereUniqueWithoutProfileInput = {
    where: ProfileWorkoutLikesWhereUniqueInput
    update: XOR<ProfileWorkoutLikesUpdateWithoutProfileInput, ProfileWorkoutLikesUncheckedUpdateWithoutProfileInput>
    create: XOR<ProfileWorkoutLikesCreateWithoutProfileInput, ProfileWorkoutLikesUncheckedCreateWithoutProfileInput>
  }

  export type ProfileWorkoutLikesUpdateWithWhereUniqueWithoutProfileInput = {
    where: ProfileWorkoutLikesWhereUniqueInput
    data: XOR<ProfileWorkoutLikesUpdateWithoutProfileInput, ProfileWorkoutLikesUncheckedUpdateWithoutProfileInput>
  }

  export type ProfileWorkoutLikesUpdateManyWithWhereWithoutProfileInput = {
    where: ProfileWorkoutLikesScalarWhereInput
    data: XOR<ProfileWorkoutLikesUpdateManyMutationInput, ProfileWorkoutLikesUncheckedUpdateManyWithoutProfileInput>
  }

  export type ProfileWorkoutLikesScalarWhereInput = {
    AND?: ProfileWorkoutLikesScalarWhereInput | ProfileWorkoutLikesScalarWhereInput[]
    OR?: ProfileWorkoutLikesScalarWhereInput[]
    NOT?: ProfileWorkoutLikesScalarWhereInput | ProfileWorkoutLikesScalarWhereInput[]
    id?: IntFilter<"ProfileWorkoutLikes"> | number
    profileId?: IntNullableFilter<"ProfileWorkoutLikes"> | number | null
    workoutId?: IntNullableFilter<"ProfileWorkoutLikes"> | number | null
  }

  export type ProfileWorkoutTouchedUpsertWithWhereUniqueWithoutProfileInput = {
    where: ProfileWorkoutTouchedWhereUniqueInput
    update: XOR<ProfileWorkoutTouchedUpdateWithoutProfileInput, ProfileWorkoutTouchedUncheckedUpdateWithoutProfileInput>
    create: XOR<ProfileWorkoutTouchedCreateWithoutProfileInput, ProfileWorkoutTouchedUncheckedCreateWithoutProfileInput>
  }

  export type ProfileWorkoutTouchedUpdateWithWhereUniqueWithoutProfileInput = {
    where: ProfileWorkoutTouchedWhereUniqueInput
    data: XOR<ProfileWorkoutTouchedUpdateWithoutProfileInput, ProfileWorkoutTouchedUncheckedUpdateWithoutProfileInput>
  }

  export type ProfileWorkoutTouchedUpdateManyWithWhereWithoutProfileInput = {
    where: ProfileWorkoutTouchedScalarWhereInput
    data: XOR<ProfileWorkoutTouchedUpdateManyMutationInput, ProfileWorkoutTouchedUncheckedUpdateManyWithoutProfileInput>
  }

  export type ProfileWorkoutTouchedScalarWhereInput = {
    AND?: ProfileWorkoutTouchedScalarWhereInput | ProfileWorkoutTouchedScalarWhereInput[]
    OR?: ProfileWorkoutTouchedScalarWhereInput[]
    NOT?: ProfileWorkoutTouchedScalarWhereInput | ProfileWorkoutTouchedScalarWhereInput[]
    id?: IntFilter<"ProfileWorkoutTouched"> | number
    profileId?: IntNullableFilter<"ProfileWorkoutTouched"> | number | null
    workoutId?: IntNullableFilter<"ProfileWorkoutTouched"> | number | null
  }

  export type ProfileMealLikesUpsertWithWhereUniqueWithoutProfileInput = {
    where: ProfileMealLikesWhereUniqueInput
    update: XOR<ProfileMealLikesUpdateWithoutProfileInput, ProfileMealLikesUncheckedUpdateWithoutProfileInput>
    create: XOR<ProfileMealLikesCreateWithoutProfileInput, ProfileMealLikesUncheckedCreateWithoutProfileInput>
  }

  export type ProfileMealLikesUpdateWithWhereUniqueWithoutProfileInput = {
    where: ProfileMealLikesWhereUniqueInput
    data: XOR<ProfileMealLikesUpdateWithoutProfileInput, ProfileMealLikesUncheckedUpdateWithoutProfileInput>
  }

  export type ProfileMealLikesUpdateManyWithWhereWithoutProfileInput = {
    where: ProfileMealLikesScalarWhereInput
    data: XOR<ProfileMealLikesUpdateManyMutationInput, ProfileMealLikesUncheckedUpdateManyWithoutProfileInput>
  }

  export type ProfileMealLikesScalarWhereInput = {
    AND?: ProfileMealLikesScalarWhereInput | ProfileMealLikesScalarWhereInput[]
    OR?: ProfileMealLikesScalarWhereInput[]
    NOT?: ProfileMealLikesScalarWhereInput | ProfileMealLikesScalarWhereInput[]
    id?: IntFilter<"ProfileMealLikes"> | number
    profileId?: IntNullableFilter<"ProfileMealLikes"> | number | null
    mealId?: IntNullableFilter<"ProfileMealLikes"> | number | null
  }

  export type ProfileMealTouchedUpsertWithWhereUniqueWithoutProfileInput = {
    where: ProfileMealTouchedWhereUniqueInput
    update: XOR<ProfileMealTouchedUpdateWithoutProfileInput, ProfileMealTouchedUncheckedUpdateWithoutProfileInput>
    create: XOR<ProfileMealTouchedCreateWithoutProfileInput, ProfileMealTouchedUncheckedCreateWithoutProfileInput>
  }

  export type ProfileMealTouchedUpdateWithWhereUniqueWithoutProfileInput = {
    where: ProfileMealTouchedWhereUniqueInput
    data: XOR<ProfileMealTouchedUpdateWithoutProfileInput, ProfileMealTouchedUncheckedUpdateWithoutProfileInput>
  }

  export type ProfileMealTouchedUpdateManyWithWhereWithoutProfileInput = {
    where: ProfileMealTouchedScalarWhereInput
    data: XOR<ProfileMealTouchedUpdateManyMutationInput, ProfileMealTouchedUncheckedUpdateManyWithoutProfileInput>
  }

  export type ProfileMealTouchedScalarWhereInput = {
    AND?: ProfileMealTouchedScalarWhereInput | ProfileMealTouchedScalarWhereInput[]
    OR?: ProfileMealTouchedScalarWhereInput[]
    NOT?: ProfileMealTouchedScalarWhereInput | ProfileMealTouchedScalarWhereInput[]
    id?: IntFilter<"ProfileMealTouched"> | number
    profileId?: IntNullableFilter<"ProfileMealTouched"> | number | null
    mealId?: IntNullableFilter<"ProfileMealTouched"> | number | null
  }

  export type ProfileCreateWithoutWorkoutsInput = {
    uid: string
    email: string
    name?: string
    sex?: string
    age?: number
    bio?: string
    meals?: MealCreateNestedManyWithoutProfileInput
    likedWorkouts?: ProfileWorkoutLikesCreateNestedManyWithoutProfileInput
    touchWorkouts?: ProfileWorkoutTouchedCreateNestedManyWithoutProfileInput
    likedMeals?: ProfileMealLikesCreateNestedManyWithoutProfileInput
    touchMeals?: ProfileMealTouchedCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutWorkoutsInput = {
    id?: number
    uid: string
    email: string
    name?: string
    sex?: string
    age?: number
    bio?: string
    meals?: MealUncheckedCreateNestedManyWithoutProfileInput
    likedWorkouts?: ProfileWorkoutLikesUncheckedCreateNestedManyWithoutProfileInput
    touchWorkouts?: ProfileWorkoutTouchedUncheckedCreateNestedManyWithoutProfileInput
    likedMeals?: ProfileMealLikesUncheckedCreateNestedManyWithoutProfileInput
    touchMeals?: ProfileMealTouchedUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutWorkoutsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutWorkoutsInput, ProfileUncheckedCreateWithoutWorkoutsInput>
  }

  export type ExerciseCreateWithoutWorkoutInput = {
    name: string
    sets?: SetCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutWorkoutInput = {
    id?: number
    name: string
    sets?: SetUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutWorkoutInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutWorkoutInput, ExerciseUncheckedCreateWithoutWorkoutInput>
  }

  export type ExerciseCreateManyWorkoutInputEnvelope = {
    data: ExerciseCreateManyWorkoutInput | ExerciseCreateManyWorkoutInput[]
    skipDuplicates?: boolean
  }

  export type ProfileWorkoutLikesCreateWithoutWorkoutInput = {
    profile?: ProfileCreateNestedOneWithoutLikedWorkoutsInput
  }

  export type ProfileWorkoutLikesUncheckedCreateWithoutWorkoutInput = {
    id?: number
    profileId?: number | null
  }

  export type ProfileWorkoutLikesCreateOrConnectWithoutWorkoutInput = {
    where: ProfileWorkoutLikesWhereUniqueInput
    create: XOR<ProfileWorkoutLikesCreateWithoutWorkoutInput, ProfileWorkoutLikesUncheckedCreateWithoutWorkoutInput>
  }

  export type ProfileWorkoutLikesCreateManyWorkoutInputEnvelope = {
    data: ProfileWorkoutLikesCreateManyWorkoutInput | ProfileWorkoutLikesCreateManyWorkoutInput[]
    skipDuplicates?: boolean
  }

  export type ProfileWorkoutTouchedCreateWithoutWorkoutInput = {
    profile?: ProfileCreateNestedOneWithoutTouchWorkoutsInput
  }

  export type ProfileWorkoutTouchedUncheckedCreateWithoutWorkoutInput = {
    id?: number
    profileId?: number | null
  }

  export type ProfileWorkoutTouchedCreateOrConnectWithoutWorkoutInput = {
    where: ProfileWorkoutTouchedWhereUniqueInput
    create: XOR<ProfileWorkoutTouchedCreateWithoutWorkoutInput, ProfileWorkoutTouchedUncheckedCreateWithoutWorkoutInput>
  }

  export type ProfileWorkoutTouchedCreateManyWorkoutInputEnvelope = {
    data: ProfileWorkoutTouchedCreateManyWorkoutInput | ProfileWorkoutTouchedCreateManyWorkoutInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutWorkoutsInput = {
    update: XOR<ProfileUpdateWithoutWorkoutsInput, ProfileUncheckedUpdateWithoutWorkoutsInput>
    create: XOR<ProfileCreateWithoutWorkoutsInput, ProfileUncheckedCreateWithoutWorkoutsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutWorkoutsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutWorkoutsInput, ProfileUncheckedUpdateWithoutWorkoutsInput>
  }

  export type ProfileUpdateWithoutWorkoutsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    bio?: StringFieldUpdateOperationsInput | string
    meals?: MealUpdateManyWithoutProfileNestedInput
    likedWorkouts?: ProfileWorkoutLikesUpdateManyWithoutProfileNestedInput
    touchWorkouts?: ProfileWorkoutTouchedUpdateManyWithoutProfileNestedInput
    likedMeals?: ProfileMealLikesUpdateManyWithoutProfileNestedInput
    touchMeals?: ProfileMealTouchedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutWorkoutsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    bio?: StringFieldUpdateOperationsInput | string
    meals?: MealUncheckedUpdateManyWithoutProfileNestedInput
    likedWorkouts?: ProfileWorkoutLikesUncheckedUpdateManyWithoutProfileNestedInput
    touchWorkouts?: ProfileWorkoutTouchedUncheckedUpdateManyWithoutProfileNestedInput
    likedMeals?: ProfileMealLikesUncheckedUpdateManyWithoutProfileNestedInput
    touchMeals?: ProfileMealTouchedUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ExerciseUpsertWithWhereUniqueWithoutWorkoutInput = {
    where: ExerciseWhereUniqueInput
    update: XOR<ExerciseUpdateWithoutWorkoutInput, ExerciseUncheckedUpdateWithoutWorkoutInput>
    create: XOR<ExerciseCreateWithoutWorkoutInput, ExerciseUncheckedCreateWithoutWorkoutInput>
  }

  export type ExerciseUpdateWithWhereUniqueWithoutWorkoutInput = {
    where: ExerciseWhereUniqueInput
    data: XOR<ExerciseUpdateWithoutWorkoutInput, ExerciseUncheckedUpdateWithoutWorkoutInput>
  }

  export type ExerciseUpdateManyWithWhereWithoutWorkoutInput = {
    where: ExerciseScalarWhereInput
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyWithoutWorkoutInput>
  }

  export type ExerciseScalarWhereInput = {
    AND?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
    OR?: ExerciseScalarWhereInput[]
    NOT?: ExerciseScalarWhereInput | ExerciseScalarWhereInput[]
    id?: IntFilter<"Exercise"> | number
    workoutId?: IntFilter<"Exercise"> | number
    name?: StringFilter<"Exercise"> | string
  }

  export type ProfileWorkoutLikesUpsertWithWhereUniqueWithoutWorkoutInput = {
    where: ProfileWorkoutLikesWhereUniqueInput
    update: XOR<ProfileWorkoutLikesUpdateWithoutWorkoutInput, ProfileWorkoutLikesUncheckedUpdateWithoutWorkoutInput>
    create: XOR<ProfileWorkoutLikesCreateWithoutWorkoutInput, ProfileWorkoutLikesUncheckedCreateWithoutWorkoutInput>
  }

  export type ProfileWorkoutLikesUpdateWithWhereUniqueWithoutWorkoutInput = {
    where: ProfileWorkoutLikesWhereUniqueInput
    data: XOR<ProfileWorkoutLikesUpdateWithoutWorkoutInput, ProfileWorkoutLikesUncheckedUpdateWithoutWorkoutInput>
  }

  export type ProfileWorkoutLikesUpdateManyWithWhereWithoutWorkoutInput = {
    where: ProfileWorkoutLikesScalarWhereInput
    data: XOR<ProfileWorkoutLikesUpdateManyMutationInput, ProfileWorkoutLikesUncheckedUpdateManyWithoutWorkoutInput>
  }

  export type ProfileWorkoutTouchedUpsertWithWhereUniqueWithoutWorkoutInput = {
    where: ProfileWorkoutTouchedWhereUniqueInput
    update: XOR<ProfileWorkoutTouchedUpdateWithoutWorkoutInput, ProfileWorkoutTouchedUncheckedUpdateWithoutWorkoutInput>
    create: XOR<ProfileWorkoutTouchedCreateWithoutWorkoutInput, ProfileWorkoutTouchedUncheckedCreateWithoutWorkoutInput>
  }

  export type ProfileWorkoutTouchedUpdateWithWhereUniqueWithoutWorkoutInput = {
    where: ProfileWorkoutTouchedWhereUniqueInput
    data: XOR<ProfileWorkoutTouchedUpdateWithoutWorkoutInput, ProfileWorkoutTouchedUncheckedUpdateWithoutWorkoutInput>
  }

  export type ProfileWorkoutTouchedUpdateManyWithWhereWithoutWorkoutInput = {
    where: ProfileWorkoutTouchedScalarWhereInput
    data: XOR<ProfileWorkoutTouchedUpdateManyMutationInput, ProfileWorkoutTouchedUncheckedUpdateManyWithoutWorkoutInput>
  }

  export type WorkoutCreateWithoutExercisesInput = {
    notes: string
    private?: boolean
    profile: ProfileCreateNestedOneWithoutWorkoutsInput
    profileLikes?: ProfileWorkoutLikesCreateNestedManyWithoutWorkoutInput
    profileTouch?: ProfileWorkoutTouchedCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutUncheckedCreateWithoutExercisesInput = {
    id?: number
    profileId: number
    notes: string
    private?: boolean
    profileLikes?: ProfileWorkoutLikesUncheckedCreateNestedManyWithoutWorkoutInput
    profileTouch?: ProfileWorkoutTouchedUncheckedCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutCreateOrConnectWithoutExercisesInput = {
    where: WorkoutWhereUniqueInput
    create: XOR<WorkoutCreateWithoutExercisesInput, WorkoutUncheckedCreateWithoutExercisesInput>
  }

  export type SetCreateWithoutExerciseInput = {
    weight: number
    reps: number
  }

  export type SetUncheckedCreateWithoutExerciseInput = {
    id?: number
    weight: number
    reps: number
  }

  export type SetCreateOrConnectWithoutExerciseInput = {
    where: SetWhereUniqueInput
    create: XOR<SetCreateWithoutExerciseInput, SetUncheckedCreateWithoutExerciseInput>
  }

  export type SetCreateManyExerciseInputEnvelope = {
    data: SetCreateManyExerciseInput | SetCreateManyExerciseInput[]
    skipDuplicates?: boolean
  }

  export type WorkoutUpsertWithoutExercisesInput = {
    update: XOR<WorkoutUpdateWithoutExercisesInput, WorkoutUncheckedUpdateWithoutExercisesInput>
    create: XOR<WorkoutCreateWithoutExercisesInput, WorkoutUncheckedCreateWithoutExercisesInput>
    where?: WorkoutWhereInput
  }

  export type WorkoutUpdateToOneWithWhereWithoutExercisesInput = {
    where?: WorkoutWhereInput
    data: XOR<WorkoutUpdateWithoutExercisesInput, WorkoutUncheckedUpdateWithoutExercisesInput>
  }

  export type WorkoutUpdateWithoutExercisesInput = {
    notes?: StringFieldUpdateOperationsInput | string
    private?: BoolFieldUpdateOperationsInput | boolean
    profile?: ProfileUpdateOneRequiredWithoutWorkoutsNestedInput
    profileLikes?: ProfileWorkoutLikesUpdateManyWithoutWorkoutNestedInput
    profileTouch?: ProfileWorkoutTouchedUpdateManyWithoutWorkoutNestedInput
  }

  export type WorkoutUncheckedUpdateWithoutExercisesInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    private?: BoolFieldUpdateOperationsInput | boolean
    profileLikes?: ProfileWorkoutLikesUncheckedUpdateManyWithoutWorkoutNestedInput
    profileTouch?: ProfileWorkoutTouchedUncheckedUpdateManyWithoutWorkoutNestedInput
  }

  export type SetUpsertWithWhereUniqueWithoutExerciseInput = {
    where: SetWhereUniqueInput
    update: XOR<SetUpdateWithoutExerciseInput, SetUncheckedUpdateWithoutExerciseInput>
    create: XOR<SetCreateWithoutExerciseInput, SetUncheckedCreateWithoutExerciseInput>
  }

  export type SetUpdateWithWhereUniqueWithoutExerciseInput = {
    where: SetWhereUniqueInput
    data: XOR<SetUpdateWithoutExerciseInput, SetUncheckedUpdateWithoutExerciseInput>
  }

  export type SetUpdateManyWithWhereWithoutExerciseInput = {
    where: SetScalarWhereInput
    data: XOR<SetUpdateManyMutationInput, SetUncheckedUpdateManyWithoutExerciseInput>
  }

  export type SetScalarWhereInput = {
    AND?: SetScalarWhereInput | SetScalarWhereInput[]
    OR?: SetScalarWhereInput[]
    NOT?: SetScalarWhereInput | SetScalarWhereInput[]
    id?: IntFilter<"Set"> | number
    exerciseId?: IntFilter<"Set"> | number
    weight?: FloatFilter<"Set"> | number
    reps?: IntFilter<"Set"> | number
  }

  export type ExerciseCreateWithoutSetsInput = {
    name: string
    workout: WorkoutCreateNestedOneWithoutExercisesInput
  }

  export type ExerciseUncheckedCreateWithoutSetsInput = {
    id?: number
    workoutId: number
    name: string
  }

  export type ExerciseCreateOrConnectWithoutSetsInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutSetsInput, ExerciseUncheckedCreateWithoutSetsInput>
  }

  export type ExerciseUpsertWithoutSetsInput = {
    update: XOR<ExerciseUpdateWithoutSetsInput, ExerciseUncheckedUpdateWithoutSetsInput>
    create: XOR<ExerciseCreateWithoutSetsInput, ExerciseUncheckedCreateWithoutSetsInput>
    where?: ExerciseWhereInput
  }

  export type ExerciseUpdateToOneWithWhereWithoutSetsInput = {
    where?: ExerciseWhereInput
    data: XOR<ExerciseUpdateWithoutSetsInput, ExerciseUncheckedUpdateWithoutSetsInput>
  }

  export type ExerciseUpdateWithoutSetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    workout?: WorkoutUpdateOneRequiredWithoutExercisesNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutSetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    workoutId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileCreateWithoutMealsInput = {
    uid: string
    email: string
    name?: string
    sex?: string
    age?: number
    bio?: string
    workouts?: WorkoutCreateNestedManyWithoutProfileInput
    likedWorkouts?: ProfileWorkoutLikesCreateNestedManyWithoutProfileInput
    touchWorkouts?: ProfileWorkoutTouchedCreateNestedManyWithoutProfileInput
    likedMeals?: ProfileMealLikesCreateNestedManyWithoutProfileInput
    touchMeals?: ProfileMealTouchedCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutMealsInput = {
    id?: number
    uid: string
    email: string
    name?: string
    sex?: string
    age?: number
    bio?: string
    workouts?: WorkoutUncheckedCreateNestedManyWithoutProfileInput
    likedWorkouts?: ProfileWorkoutLikesUncheckedCreateNestedManyWithoutProfileInput
    touchWorkouts?: ProfileWorkoutTouchedUncheckedCreateNestedManyWithoutProfileInput
    likedMeals?: ProfileMealLikesUncheckedCreateNestedManyWithoutProfileInput
    touchMeals?: ProfileMealTouchedUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutMealsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutMealsInput, ProfileUncheckedCreateWithoutMealsInput>
  }

  export type FoodCreateWithoutMealInput = {
    name: string
    calories: number
    carbs: number
    fats: number
    proteins: number
    grams: number
  }

  export type FoodUncheckedCreateWithoutMealInput = {
    id?: number
    name: string
    calories: number
    carbs: number
    fats: number
    proteins: number
    grams: number
  }

  export type FoodCreateOrConnectWithoutMealInput = {
    where: FoodWhereUniqueInput
    create: XOR<FoodCreateWithoutMealInput, FoodUncheckedCreateWithoutMealInput>
  }

  export type FoodCreateManyMealInputEnvelope = {
    data: FoodCreateManyMealInput | FoodCreateManyMealInput[]
    skipDuplicates?: boolean
  }

  export type ProfileMealLikesCreateWithoutMealInput = {
    profile?: ProfileCreateNestedOneWithoutLikedMealsInput
  }

  export type ProfileMealLikesUncheckedCreateWithoutMealInput = {
    id?: number
    profileId?: number | null
  }

  export type ProfileMealLikesCreateOrConnectWithoutMealInput = {
    where: ProfileMealLikesWhereUniqueInput
    create: XOR<ProfileMealLikesCreateWithoutMealInput, ProfileMealLikesUncheckedCreateWithoutMealInput>
  }

  export type ProfileMealLikesCreateManyMealInputEnvelope = {
    data: ProfileMealLikesCreateManyMealInput | ProfileMealLikesCreateManyMealInput[]
    skipDuplicates?: boolean
  }

  export type ProfileMealTouchedCreateWithoutMealInput = {
    profile?: ProfileCreateNestedOneWithoutTouchMealsInput
  }

  export type ProfileMealTouchedUncheckedCreateWithoutMealInput = {
    id?: number
    profileId?: number | null
  }

  export type ProfileMealTouchedCreateOrConnectWithoutMealInput = {
    where: ProfileMealTouchedWhereUniqueInput
    create: XOR<ProfileMealTouchedCreateWithoutMealInput, ProfileMealTouchedUncheckedCreateWithoutMealInput>
  }

  export type ProfileMealTouchedCreateManyMealInputEnvelope = {
    data: ProfileMealTouchedCreateManyMealInput | ProfileMealTouchedCreateManyMealInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutMealsInput = {
    update: XOR<ProfileUpdateWithoutMealsInput, ProfileUncheckedUpdateWithoutMealsInput>
    create: XOR<ProfileCreateWithoutMealsInput, ProfileUncheckedCreateWithoutMealsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutMealsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutMealsInput, ProfileUncheckedUpdateWithoutMealsInput>
  }

  export type ProfileUpdateWithoutMealsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    bio?: StringFieldUpdateOperationsInput | string
    workouts?: WorkoutUpdateManyWithoutProfileNestedInput
    likedWorkouts?: ProfileWorkoutLikesUpdateManyWithoutProfileNestedInput
    touchWorkouts?: ProfileWorkoutTouchedUpdateManyWithoutProfileNestedInput
    likedMeals?: ProfileMealLikesUpdateManyWithoutProfileNestedInput
    touchMeals?: ProfileMealTouchedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutMealsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    bio?: StringFieldUpdateOperationsInput | string
    workouts?: WorkoutUncheckedUpdateManyWithoutProfileNestedInput
    likedWorkouts?: ProfileWorkoutLikesUncheckedUpdateManyWithoutProfileNestedInput
    touchWorkouts?: ProfileWorkoutTouchedUncheckedUpdateManyWithoutProfileNestedInput
    likedMeals?: ProfileMealLikesUncheckedUpdateManyWithoutProfileNestedInput
    touchMeals?: ProfileMealTouchedUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type FoodUpsertWithWhereUniqueWithoutMealInput = {
    where: FoodWhereUniqueInput
    update: XOR<FoodUpdateWithoutMealInput, FoodUncheckedUpdateWithoutMealInput>
    create: XOR<FoodCreateWithoutMealInput, FoodUncheckedCreateWithoutMealInput>
  }

  export type FoodUpdateWithWhereUniqueWithoutMealInput = {
    where: FoodWhereUniqueInput
    data: XOR<FoodUpdateWithoutMealInput, FoodUncheckedUpdateWithoutMealInput>
  }

  export type FoodUpdateManyWithWhereWithoutMealInput = {
    where: FoodScalarWhereInput
    data: XOR<FoodUpdateManyMutationInput, FoodUncheckedUpdateManyWithoutMealInput>
  }

  export type FoodScalarWhereInput = {
    AND?: FoodScalarWhereInput | FoodScalarWhereInput[]
    OR?: FoodScalarWhereInput[]
    NOT?: FoodScalarWhereInput | FoodScalarWhereInput[]
    id?: IntFilter<"Food"> | number
    mealId?: IntFilter<"Food"> | number
    name?: StringFilter<"Food"> | string
    calories?: FloatFilter<"Food"> | number
    carbs?: FloatFilter<"Food"> | number
    fats?: FloatFilter<"Food"> | number
    proteins?: FloatFilter<"Food"> | number
    grams?: FloatFilter<"Food"> | number
  }

  export type ProfileMealLikesUpsertWithWhereUniqueWithoutMealInput = {
    where: ProfileMealLikesWhereUniqueInput
    update: XOR<ProfileMealLikesUpdateWithoutMealInput, ProfileMealLikesUncheckedUpdateWithoutMealInput>
    create: XOR<ProfileMealLikesCreateWithoutMealInput, ProfileMealLikesUncheckedCreateWithoutMealInput>
  }

  export type ProfileMealLikesUpdateWithWhereUniqueWithoutMealInput = {
    where: ProfileMealLikesWhereUniqueInput
    data: XOR<ProfileMealLikesUpdateWithoutMealInput, ProfileMealLikesUncheckedUpdateWithoutMealInput>
  }

  export type ProfileMealLikesUpdateManyWithWhereWithoutMealInput = {
    where: ProfileMealLikesScalarWhereInput
    data: XOR<ProfileMealLikesUpdateManyMutationInput, ProfileMealLikesUncheckedUpdateManyWithoutMealInput>
  }

  export type ProfileMealTouchedUpsertWithWhereUniqueWithoutMealInput = {
    where: ProfileMealTouchedWhereUniqueInput
    update: XOR<ProfileMealTouchedUpdateWithoutMealInput, ProfileMealTouchedUncheckedUpdateWithoutMealInput>
    create: XOR<ProfileMealTouchedCreateWithoutMealInput, ProfileMealTouchedUncheckedCreateWithoutMealInput>
  }

  export type ProfileMealTouchedUpdateWithWhereUniqueWithoutMealInput = {
    where: ProfileMealTouchedWhereUniqueInput
    data: XOR<ProfileMealTouchedUpdateWithoutMealInput, ProfileMealTouchedUncheckedUpdateWithoutMealInput>
  }

  export type ProfileMealTouchedUpdateManyWithWhereWithoutMealInput = {
    where: ProfileMealTouchedScalarWhereInput
    data: XOR<ProfileMealTouchedUpdateManyMutationInput, ProfileMealTouchedUncheckedUpdateManyWithoutMealInput>
  }

  export type MealCreateWithoutFoodsInput = {
    notes: string
    totalCalories: number
    totalCarbs: number
    totalFats: number
    totalProteins: number
    totalGrams: number
    private?: boolean
    profile: ProfileCreateNestedOneWithoutMealsInput
    profileLikes?: ProfileMealLikesCreateNestedManyWithoutMealInput
    profileTouch?: ProfileMealTouchedCreateNestedManyWithoutMealInput
  }

  export type MealUncheckedCreateWithoutFoodsInput = {
    id?: number
    profileId: number
    notes: string
    totalCalories: number
    totalCarbs: number
    totalFats: number
    totalProteins: number
    totalGrams: number
    private?: boolean
    profileLikes?: ProfileMealLikesUncheckedCreateNestedManyWithoutMealInput
    profileTouch?: ProfileMealTouchedUncheckedCreateNestedManyWithoutMealInput
  }

  export type MealCreateOrConnectWithoutFoodsInput = {
    where: MealWhereUniqueInput
    create: XOR<MealCreateWithoutFoodsInput, MealUncheckedCreateWithoutFoodsInput>
  }

  export type MealUpsertWithoutFoodsInput = {
    update: XOR<MealUpdateWithoutFoodsInput, MealUncheckedUpdateWithoutFoodsInput>
    create: XOR<MealCreateWithoutFoodsInput, MealUncheckedCreateWithoutFoodsInput>
    where?: MealWhereInput
  }

  export type MealUpdateToOneWithWhereWithoutFoodsInput = {
    where?: MealWhereInput
    data: XOR<MealUpdateWithoutFoodsInput, MealUncheckedUpdateWithoutFoodsInput>
  }

  export type MealUpdateWithoutFoodsInput = {
    notes?: StringFieldUpdateOperationsInput | string
    totalCalories?: FloatFieldUpdateOperationsInput | number
    totalCarbs?: FloatFieldUpdateOperationsInput | number
    totalFats?: FloatFieldUpdateOperationsInput | number
    totalProteins?: FloatFieldUpdateOperationsInput | number
    totalGrams?: FloatFieldUpdateOperationsInput | number
    private?: BoolFieldUpdateOperationsInput | boolean
    profile?: ProfileUpdateOneRequiredWithoutMealsNestedInput
    profileLikes?: ProfileMealLikesUpdateManyWithoutMealNestedInput
    profileTouch?: ProfileMealTouchedUpdateManyWithoutMealNestedInput
  }

  export type MealUncheckedUpdateWithoutFoodsInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    totalCalories?: FloatFieldUpdateOperationsInput | number
    totalCarbs?: FloatFieldUpdateOperationsInput | number
    totalFats?: FloatFieldUpdateOperationsInput | number
    totalProteins?: FloatFieldUpdateOperationsInput | number
    totalGrams?: FloatFieldUpdateOperationsInput | number
    private?: BoolFieldUpdateOperationsInput | boolean
    profileLikes?: ProfileMealLikesUncheckedUpdateManyWithoutMealNestedInput
    profileTouch?: ProfileMealTouchedUncheckedUpdateManyWithoutMealNestedInput
  }

  export type ProfileCreateWithoutLikedWorkoutsInput = {
    uid: string
    email: string
    name?: string
    sex?: string
    age?: number
    bio?: string
    workouts?: WorkoutCreateNestedManyWithoutProfileInput
    meals?: MealCreateNestedManyWithoutProfileInput
    touchWorkouts?: ProfileWorkoutTouchedCreateNestedManyWithoutProfileInput
    likedMeals?: ProfileMealLikesCreateNestedManyWithoutProfileInput
    touchMeals?: ProfileMealTouchedCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutLikedWorkoutsInput = {
    id?: number
    uid: string
    email: string
    name?: string
    sex?: string
    age?: number
    bio?: string
    workouts?: WorkoutUncheckedCreateNestedManyWithoutProfileInput
    meals?: MealUncheckedCreateNestedManyWithoutProfileInput
    touchWorkouts?: ProfileWorkoutTouchedUncheckedCreateNestedManyWithoutProfileInput
    likedMeals?: ProfileMealLikesUncheckedCreateNestedManyWithoutProfileInput
    touchMeals?: ProfileMealTouchedUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutLikedWorkoutsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutLikedWorkoutsInput, ProfileUncheckedCreateWithoutLikedWorkoutsInput>
  }

  export type WorkoutCreateWithoutProfileLikesInput = {
    notes: string
    private?: boolean
    profile: ProfileCreateNestedOneWithoutWorkoutsInput
    exercises?: ExerciseCreateNestedManyWithoutWorkoutInput
    profileTouch?: ProfileWorkoutTouchedCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutUncheckedCreateWithoutProfileLikesInput = {
    id?: number
    profileId: number
    notes: string
    private?: boolean
    exercises?: ExerciseUncheckedCreateNestedManyWithoutWorkoutInput
    profileTouch?: ProfileWorkoutTouchedUncheckedCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutCreateOrConnectWithoutProfileLikesInput = {
    where: WorkoutWhereUniqueInput
    create: XOR<WorkoutCreateWithoutProfileLikesInput, WorkoutUncheckedCreateWithoutProfileLikesInput>
  }

  export type ProfileUpsertWithoutLikedWorkoutsInput = {
    update: XOR<ProfileUpdateWithoutLikedWorkoutsInput, ProfileUncheckedUpdateWithoutLikedWorkoutsInput>
    create: XOR<ProfileCreateWithoutLikedWorkoutsInput, ProfileUncheckedCreateWithoutLikedWorkoutsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutLikedWorkoutsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutLikedWorkoutsInput, ProfileUncheckedUpdateWithoutLikedWorkoutsInput>
  }

  export type ProfileUpdateWithoutLikedWorkoutsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    bio?: StringFieldUpdateOperationsInput | string
    workouts?: WorkoutUpdateManyWithoutProfileNestedInput
    meals?: MealUpdateManyWithoutProfileNestedInput
    touchWorkouts?: ProfileWorkoutTouchedUpdateManyWithoutProfileNestedInput
    likedMeals?: ProfileMealLikesUpdateManyWithoutProfileNestedInput
    touchMeals?: ProfileMealTouchedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutLikedWorkoutsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    bio?: StringFieldUpdateOperationsInput | string
    workouts?: WorkoutUncheckedUpdateManyWithoutProfileNestedInput
    meals?: MealUncheckedUpdateManyWithoutProfileNestedInput
    touchWorkouts?: ProfileWorkoutTouchedUncheckedUpdateManyWithoutProfileNestedInput
    likedMeals?: ProfileMealLikesUncheckedUpdateManyWithoutProfileNestedInput
    touchMeals?: ProfileMealTouchedUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type WorkoutUpsertWithoutProfileLikesInput = {
    update: XOR<WorkoutUpdateWithoutProfileLikesInput, WorkoutUncheckedUpdateWithoutProfileLikesInput>
    create: XOR<WorkoutCreateWithoutProfileLikesInput, WorkoutUncheckedCreateWithoutProfileLikesInput>
    where?: WorkoutWhereInput
  }

  export type WorkoutUpdateToOneWithWhereWithoutProfileLikesInput = {
    where?: WorkoutWhereInput
    data: XOR<WorkoutUpdateWithoutProfileLikesInput, WorkoutUncheckedUpdateWithoutProfileLikesInput>
  }

  export type WorkoutUpdateWithoutProfileLikesInput = {
    notes?: StringFieldUpdateOperationsInput | string
    private?: BoolFieldUpdateOperationsInput | boolean
    profile?: ProfileUpdateOneRequiredWithoutWorkoutsNestedInput
    exercises?: ExerciseUpdateManyWithoutWorkoutNestedInput
    profileTouch?: ProfileWorkoutTouchedUpdateManyWithoutWorkoutNestedInput
  }

  export type WorkoutUncheckedUpdateWithoutProfileLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    private?: BoolFieldUpdateOperationsInput | boolean
    exercises?: ExerciseUncheckedUpdateManyWithoutWorkoutNestedInput
    profileTouch?: ProfileWorkoutTouchedUncheckedUpdateManyWithoutWorkoutNestedInput
  }

  export type ProfileCreateWithoutTouchWorkoutsInput = {
    uid: string
    email: string
    name?: string
    sex?: string
    age?: number
    bio?: string
    workouts?: WorkoutCreateNestedManyWithoutProfileInput
    meals?: MealCreateNestedManyWithoutProfileInput
    likedWorkouts?: ProfileWorkoutLikesCreateNestedManyWithoutProfileInput
    likedMeals?: ProfileMealLikesCreateNestedManyWithoutProfileInput
    touchMeals?: ProfileMealTouchedCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutTouchWorkoutsInput = {
    id?: number
    uid: string
    email: string
    name?: string
    sex?: string
    age?: number
    bio?: string
    workouts?: WorkoutUncheckedCreateNestedManyWithoutProfileInput
    meals?: MealUncheckedCreateNestedManyWithoutProfileInput
    likedWorkouts?: ProfileWorkoutLikesUncheckedCreateNestedManyWithoutProfileInput
    likedMeals?: ProfileMealLikesUncheckedCreateNestedManyWithoutProfileInput
    touchMeals?: ProfileMealTouchedUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutTouchWorkoutsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutTouchWorkoutsInput, ProfileUncheckedCreateWithoutTouchWorkoutsInput>
  }

  export type WorkoutCreateWithoutProfileTouchInput = {
    notes: string
    private?: boolean
    profile: ProfileCreateNestedOneWithoutWorkoutsInput
    exercises?: ExerciseCreateNestedManyWithoutWorkoutInput
    profileLikes?: ProfileWorkoutLikesCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutUncheckedCreateWithoutProfileTouchInput = {
    id?: number
    profileId: number
    notes: string
    private?: boolean
    exercises?: ExerciseUncheckedCreateNestedManyWithoutWorkoutInput
    profileLikes?: ProfileWorkoutLikesUncheckedCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutCreateOrConnectWithoutProfileTouchInput = {
    where: WorkoutWhereUniqueInput
    create: XOR<WorkoutCreateWithoutProfileTouchInput, WorkoutUncheckedCreateWithoutProfileTouchInput>
  }

  export type ProfileUpsertWithoutTouchWorkoutsInput = {
    update: XOR<ProfileUpdateWithoutTouchWorkoutsInput, ProfileUncheckedUpdateWithoutTouchWorkoutsInput>
    create: XOR<ProfileCreateWithoutTouchWorkoutsInput, ProfileUncheckedCreateWithoutTouchWorkoutsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutTouchWorkoutsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutTouchWorkoutsInput, ProfileUncheckedUpdateWithoutTouchWorkoutsInput>
  }

  export type ProfileUpdateWithoutTouchWorkoutsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    bio?: StringFieldUpdateOperationsInput | string
    workouts?: WorkoutUpdateManyWithoutProfileNestedInput
    meals?: MealUpdateManyWithoutProfileNestedInput
    likedWorkouts?: ProfileWorkoutLikesUpdateManyWithoutProfileNestedInput
    likedMeals?: ProfileMealLikesUpdateManyWithoutProfileNestedInput
    touchMeals?: ProfileMealTouchedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutTouchWorkoutsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    bio?: StringFieldUpdateOperationsInput | string
    workouts?: WorkoutUncheckedUpdateManyWithoutProfileNestedInput
    meals?: MealUncheckedUpdateManyWithoutProfileNestedInput
    likedWorkouts?: ProfileWorkoutLikesUncheckedUpdateManyWithoutProfileNestedInput
    likedMeals?: ProfileMealLikesUncheckedUpdateManyWithoutProfileNestedInput
    touchMeals?: ProfileMealTouchedUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type WorkoutUpsertWithoutProfileTouchInput = {
    update: XOR<WorkoutUpdateWithoutProfileTouchInput, WorkoutUncheckedUpdateWithoutProfileTouchInput>
    create: XOR<WorkoutCreateWithoutProfileTouchInput, WorkoutUncheckedCreateWithoutProfileTouchInput>
    where?: WorkoutWhereInput
  }

  export type WorkoutUpdateToOneWithWhereWithoutProfileTouchInput = {
    where?: WorkoutWhereInput
    data: XOR<WorkoutUpdateWithoutProfileTouchInput, WorkoutUncheckedUpdateWithoutProfileTouchInput>
  }

  export type WorkoutUpdateWithoutProfileTouchInput = {
    notes?: StringFieldUpdateOperationsInput | string
    private?: BoolFieldUpdateOperationsInput | boolean
    profile?: ProfileUpdateOneRequiredWithoutWorkoutsNestedInput
    exercises?: ExerciseUpdateManyWithoutWorkoutNestedInput
    profileLikes?: ProfileWorkoutLikesUpdateManyWithoutWorkoutNestedInput
  }

  export type WorkoutUncheckedUpdateWithoutProfileTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    private?: BoolFieldUpdateOperationsInput | boolean
    exercises?: ExerciseUncheckedUpdateManyWithoutWorkoutNestedInput
    profileLikes?: ProfileWorkoutLikesUncheckedUpdateManyWithoutWorkoutNestedInput
  }

  export type ProfileCreateWithoutLikedMealsInput = {
    uid: string
    email: string
    name?: string
    sex?: string
    age?: number
    bio?: string
    workouts?: WorkoutCreateNestedManyWithoutProfileInput
    meals?: MealCreateNestedManyWithoutProfileInput
    likedWorkouts?: ProfileWorkoutLikesCreateNestedManyWithoutProfileInput
    touchWorkouts?: ProfileWorkoutTouchedCreateNestedManyWithoutProfileInput
    touchMeals?: ProfileMealTouchedCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutLikedMealsInput = {
    id?: number
    uid: string
    email: string
    name?: string
    sex?: string
    age?: number
    bio?: string
    workouts?: WorkoutUncheckedCreateNestedManyWithoutProfileInput
    meals?: MealUncheckedCreateNestedManyWithoutProfileInput
    likedWorkouts?: ProfileWorkoutLikesUncheckedCreateNestedManyWithoutProfileInput
    touchWorkouts?: ProfileWorkoutTouchedUncheckedCreateNestedManyWithoutProfileInput
    touchMeals?: ProfileMealTouchedUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutLikedMealsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutLikedMealsInput, ProfileUncheckedCreateWithoutLikedMealsInput>
  }

  export type MealCreateWithoutProfileLikesInput = {
    notes: string
    totalCalories: number
    totalCarbs: number
    totalFats: number
    totalProteins: number
    totalGrams: number
    private?: boolean
    profile: ProfileCreateNestedOneWithoutMealsInput
    foods?: FoodCreateNestedManyWithoutMealInput
    profileTouch?: ProfileMealTouchedCreateNestedManyWithoutMealInput
  }

  export type MealUncheckedCreateWithoutProfileLikesInput = {
    id?: number
    profileId: number
    notes: string
    totalCalories: number
    totalCarbs: number
    totalFats: number
    totalProteins: number
    totalGrams: number
    private?: boolean
    foods?: FoodUncheckedCreateNestedManyWithoutMealInput
    profileTouch?: ProfileMealTouchedUncheckedCreateNestedManyWithoutMealInput
  }

  export type MealCreateOrConnectWithoutProfileLikesInput = {
    where: MealWhereUniqueInput
    create: XOR<MealCreateWithoutProfileLikesInput, MealUncheckedCreateWithoutProfileLikesInput>
  }

  export type ProfileUpsertWithoutLikedMealsInput = {
    update: XOR<ProfileUpdateWithoutLikedMealsInput, ProfileUncheckedUpdateWithoutLikedMealsInput>
    create: XOR<ProfileCreateWithoutLikedMealsInput, ProfileUncheckedCreateWithoutLikedMealsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutLikedMealsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutLikedMealsInput, ProfileUncheckedUpdateWithoutLikedMealsInput>
  }

  export type ProfileUpdateWithoutLikedMealsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    bio?: StringFieldUpdateOperationsInput | string
    workouts?: WorkoutUpdateManyWithoutProfileNestedInput
    meals?: MealUpdateManyWithoutProfileNestedInput
    likedWorkouts?: ProfileWorkoutLikesUpdateManyWithoutProfileNestedInput
    touchWorkouts?: ProfileWorkoutTouchedUpdateManyWithoutProfileNestedInput
    touchMeals?: ProfileMealTouchedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutLikedMealsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    bio?: StringFieldUpdateOperationsInput | string
    workouts?: WorkoutUncheckedUpdateManyWithoutProfileNestedInput
    meals?: MealUncheckedUpdateManyWithoutProfileNestedInput
    likedWorkouts?: ProfileWorkoutLikesUncheckedUpdateManyWithoutProfileNestedInput
    touchWorkouts?: ProfileWorkoutTouchedUncheckedUpdateManyWithoutProfileNestedInput
    touchMeals?: ProfileMealTouchedUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type MealUpsertWithoutProfileLikesInput = {
    update: XOR<MealUpdateWithoutProfileLikesInput, MealUncheckedUpdateWithoutProfileLikesInput>
    create: XOR<MealCreateWithoutProfileLikesInput, MealUncheckedCreateWithoutProfileLikesInput>
    where?: MealWhereInput
  }

  export type MealUpdateToOneWithWhereWithoutProfileLikesInput = {
    where?: MealWhereInput
    data: XOR<MealUpdateWithoutProfileLikesInput, MealUncheckedUpdateWithoutProfileLikesInput>
  }

  export type MealUpdateWithoutProfileLikesInput = {
    notes?: StringFieldUpdateOperationsInput | string
    totalCalories?: FloatFieldUpdateOperationsInput | number
    totalCarbs?: FloatFieldUpdateOperationsInput | number
    totalFats?: FloatFieldUpdateOperationsInput | number
    totalProteins?: FloatFieldUpdateOperationsInput | number
    totalGrams?: FloatFieldUpdateOperationsInput | number
    private?: BoolFieldUpdateOperationsInput | boolean
    profile?: ProfileUpdateOneRequiredWithoutMealsNestedInput
    foods?: FoodUpdateManyWithoutMealNestedInput
    profileTouch?: ProfileMealTouchedUpdateManyWithoutMealNestedInput
  }

  export type MealUncheckedUpdateWithoutProfileLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    totalCalories?: FloatFieldUpdateOperationsInput | number
    totalCarbs?: FloatFieldUpdateOperationsInput | number
    totalFats?: FloatFieldUpdateOperationsInput | number
    totalProteins?: FloatFieldUpdateOperationsInput | number
    totalGrams?: FloatFieldUpdateOperationsInput | number
    private?: BoolFieldUpdateOperationsInput | boolean
    foods?: FoodUncheckedUpdateManyWithoutMealNestedInput
    profileTouch?: ProfileMealTouchedUncheckedUpdateManyWithoutMealNestedInput
  }

  export type ProfileCreateWithoutTouchMealsInput = {
    uid: string
    email: string
    name?: string
    sex?: string
    age?: number
    bio?: string
    workouts?: WorkoutCreateNestedManyWithoutProfileInput
    meals?: MealCreateNestedManyWithoutProfileInput
    likedWorkouts?: ProfileWorkoutLikesCreateNestedManyWithoutProfileInput
    touchWorkouts?: ProfileWorkoutTouchedCreateNestedManyWithoutProfileInput
    likedMeals?: ProfileMealLikesCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutTouchMealsInput = {
    id?: number
    uid: string
    email: string
    name?: string
    sex?: string
    age?: number
    bio?: string
    workouts?: WorkoutUncheckedCreateNestedManyWithoutProfileInput
    meals?: MealUncheckedCreateNestedManyWithoutProfileInput
    likedWorkouts?: ProfileWorkoutLikesUncheckedCreateNestedManyWithoutProfileInput
    touchWorkouts?: ProfileWorkoutTouchedUncheckedCreateNestedManyWithoutProfileInput
    likedMeals?: ProfileMealLikesUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutTouchMealsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutTouchMealsInput, ProfileUncheckedCreateWithoutTouchMealsInput>
  }

  export type MealCreateWithoutProfileTouchInput = {
    notes: string
    totalCalories: number
    totalCarbs: number
    totalFats: number
    totalProteins: number
    totalGrams: number
    private?: boolean
    profile: ProfileCreateNestedOneWithoutMealsInput
    foods?: FoodCreateNestedManyWithoutMealInput
    profileLikes?: ProfileMealLikesCreateNestedManyWithoutMealInput
  }

  export type MealUncheckedCreateWithoutProfileTouchInput = {
    id?: number
    profileId: number
    notes: string
    totalCalories: number
    totalCarbs: number
    totalFats: number
    totalProteins: number
    totalGrams: number
    private?: boolean
    foods?: FoodUncheckedCreateNestedManyWithoutMealInput
    profileLikes?: ProfileMealLikesUncheckedCreateNestedManyWithoutMealInput
  }

  export type MealCreateOrConnectWithoutProfileTouchInput = {
    where: MealWhereUniqueInput
    create: XOR<MealCreateWithoutProfileTouchInput, MealUncheckedCreateWithoutProfileTouchInput>
  }

  export type ProfileUpsertWithoutTouchMealsInput = {
    update: XOR<ProfileUpdateWithoutTouchMealsInput, ProfileUncheckedUpdateWithoutTouchMealsInput>
    create: XOR<ProfileCreateWithoutTouchMealsInput, ProfileUncheckedCreateWithoutTouchMealsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutTouchMealsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutTouchMealsInput, ProfileUncheckedUpdateWithoutTouchMealsInput>
  }

  export type ProfileUpdateWithoutTouchMealsInput = {
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    bio?: StringFieldUpdateOperationsInput | string
    workouts?: WorkoutUpdateManyWithoutProfileNestedInput
    meals?: MealUpdateManyWithoutProfileNestedInput
    likedWorkouts?: ProfileWorkoutLikesUpdateManyWithoutProfileNestedInput
    touchWorkouts?: ProfileWorkoutTouchedUpdateManyWithoutProfileNestedInput
    likedMeals?: ProfileMealLikesUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutTouchMealsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sex?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    bio?: StringFieldUpdateOperationsInput | string
    workouts?: WorkoutUncheckedUpdateManyWithoutProfileNestedInput
    meals?: MealUncheckedUpdateManyWithoutProfileNestedInput
    likedWorkouts?: ProfileWorkoutLikesUncheckedUpdateManyWithoutProfileNestedInput
    touchWorkouts?: ProfileWorkoutTouchedUncheckedUpdateManyWithoutProfileNestedInput
    likedMeals?: ProfileMealLikesUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type MealUpsertWithoutProfileTouchInput = {
    update: XOR<MealUpdateWithoutProfileTouchInput, MealUncheckedUpdateWithoutProfileTouchInput>
    create: XOR<MealCreateWithoutProfileTouchInput, MealUncheckedCreateWithoutProfileTouchInput>
    where?: MealWhereInput
  }

  export type MealUpdateToOneWithWhereWithoutProfileTouchInput = {
    where?: MealWhereInput
    data: XOR<MealUpdateWithoutProfileTouchInput, MealUncheckedUpdateWithoutProfileTouchInput>
  }

  export type MealUpdateWithoutProfileTouchInput = {
    notes?: StringFieldUpdateOperationsInput | string
    totalCalories?: FloatFieldUpdateOperationsInput | number
    totalCarbs?: FloatFieldUpdateOperationsInput | number
    totalFats?: FloatFieldUpdateOperationsInput | number
    totalProteins?: FloatFieldUpdateOperationsInput | number
    totalGrams?: FloatFieldUpdateOperationsInput | number
    private?: BoolFieldUpdateOperationsInput | boolean
    profile?: ProfileUpdateOneRequiredWithoutMealsNestedInput
    foods?: FoodUpdateManyWithoutMealNestedInput
    profileLikes?: ProfileMealLikesUpdateManyWithoutMealNestedInput
  }

  export type MealUncheckedUpdateWithoutProfileTouchInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    totalCalories?: FloatFieldUpdateOperationsInput | number
    totalCarbs?: FloatFieldUpdateOperationsInput | number
    totalFats?: FloatFieldUpdateOperationsInput | number
    totalProteins?: FloatFieldUpdateOperationsInput | number
    totalGrams?: FloatFieldUpdateOperationsInput | number
    private?: BoolFieldUpdateOperationsInput | boolean
    foods?: FoodUncheckedUpdateManyWithoutMealNestedInput
    profileLikes?: ProfileMealLikesUncheckedUpdateManyWithoutMealNestedInput
  }

  export type WorkoutCreateManyProfileInput = {
    id?: number
    notes: string
    private?: boolean
  }

  export type MealCreateManyProfileInput = {
    id?: number
    notes: string
    totalCalories: number
    totalCarbs: number
    totalFats: number
    totalProteins: number
    totalGrams: number
    private?: boolean
  }

  export type ProfileWorkoutLikesCreateManyProfileInput = {
    id?: number
    workoutId?: number | null
  }

  export type ProfileWorkoutTouchedCreateManyProfileInput = {
    id?: number
    workoutId?: number | null
  }

  export type ProfileMealLikesCreateManyProfileInput = {
    id?: number
    mealId?: number | null
  }

  export type ProfileMealTouchedCreateManyProfileInput = {
    id?: number
    mealId?: number | null
  }

  export type WorkoutUpdateWithoutProfileInput = {
    notes?: StringFieldUpdateOperationsInput | string
    private?: BoolFieldUpdateOperationsInput | boolean
    exercises?: ExerciseUpdateManyWithoutWorkoutNestedInput
    profileLikes?: ProfileWorkoutLikesUpdateManyWithoutWorkoutNestedInput
    profileTouch?: ProfileWorkoutTouchedUpdateManyWithoutWorkoutNestedInput
  }

  export type WorkoutUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    private?: BoolFieldUpdateOperationsInput | boolean
    exercises?: ExerciseUncheckedUpdateManyWithoutWorkoutNestedInput
    profileLikes?: ProfileWorkoutLikesUncheckedUpdateManyWithoutWorkoutNestedInput
    profileTouch?: ProfileWorkoutTouchedUncheckedUpdateManyWithoutWorkoutNestedInput
  }

  export type WorkoutUncheckedUpdateManyWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    private?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MealUpdateWithoutProfileInput = {
    notes?: StringFieldUpdateOperationsInput | string
    totalCalories?: FloatFieldUpdateOperationsInput | number
    totalCarbs?: FloatFieldUpdateOperationsInput | number
    totalFats?: FloatFieldUpdateOperationsInput | number
    totalProteins?: FloatFieldUpdateOperationsInput | number
    totalGrams?: FloatFieldUpdateOperationsInput | number
    private?: BoolFieldUpdateOperationsInput | boolean
    foods?: FoodUpdateManyWithoutMealNestedInput
    profileLikes?: ProfileMealLikesUpdateManyWithoutMealNestedInput
    profileTouch?: ProfileMealTouchedUpdateManyWithoutMealNestedInput
  }

  export type MealUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    totalCalories?: FloatFieldUpdateOperationsInput | number
    totalCarbs?: FloatFieldUpdateOperationsInput | number
    totalFats?: FloatFieldUpdateOperationsInput | number
    totalProteins?: FloatFieldUpdateOperationsInput | number
    totalGrams?: FloatFieldUpdateOperationsInput | number
    private?: BoolFieldUpdateOperationsInput | boolean
    foods?: FoodUncheckedUpdateManyWithoutMealNestedInput
    profileLikes?: ProfileMealLikesUncheckedUpdateManyWithoutMealNestedInput
    profileTouch?: ProfileMealTouchedUncheckedUpdateManyWithoutMealNestedInput
  }

  export type MealUncheckedUpdateManyWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    totalCalories?: FloatFieldUpdateOperationsInput | number
    totalCarbs?: FloatFieldUpdateOperationsInput | number
    totalFats?: FloatFieldUpdateOperationsInput | number
    totalProteins?: FloatFieldUpdateOperationsInput | number
    totalGrams?: FloatFieldUpdateOperationsInput | number
    private?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProfileWorkoutLikesUpdateWithoutProfileInput = {
    workout?: WorkoutUpdateOneWithoutProfileLikesNestedInput
  }

  export type ProfileWorkoutLikesUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    workoutId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfileWorkoutLikesUncheckedUpdateManyWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    workoutId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfileWorkoutTouchedUpdateWithoutProfileInput = {
    workout?: WorkoutUpdateOneWithoutProfileTouchNestedInput
  }

  export type ProfileWorkoutTouchedUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    workoutId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfileWorkoutTouchedUncheckedUpdateManyWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    workoutId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfileMealLikesUpdateWithoutProfileInput = {
    meal?: MealUpdateOneWithoutProfileLikesNestedInput
  }

  export type ProfileMealLikesUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    mealId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfileMealLikesUncheckedUpdateManyWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    mealId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfileMealTouchedUpdateWithoutProfileInput = {
    meal?: MealUpdateOneWithoutProfileTouchNestedInput
  }

  export type ProfileMealTouchedUncheckedUpdateWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    mealId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfileMealTouchedUncheckedUpdateManyWithoutProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    mealId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExerciseCreateManyWorkoutInput = {
    id?: number
    name: string
  }

  export type ProfileWorkoutLikesCreateManyWorkoutInput = {
    id?: number
    profileId?: number | null
  }

  export type ProfileWorkoutTouchedCreateManyWorkoutInput = {
    id?: number
    profileId?: number | null
  }

  export type ExerciseUpdateWithoutWorkoutInput = {
    name?: StringFieldUpdateOperationsInput | string
    sets?: SetUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutWorkoutInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    sets?: SetUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateManyWithoutWorkoutInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileWorkoutLikesUpdateWithoutWorkoutInput = {
    profile?: ProfileUpdateOneWithoutLikedWorkoutsNestedInput
  }

  export type ProfileWorkoutLikesUncheckedUpdateWithoutWorkoutInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfileWorkoutLikesUncheckedUpdateManyWithoutWorkoutInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfileWorkoutTouchedUpdateWithoutWorkoutInput = {
    profile?: ProfileUpdateOneWithoutTouchWorkoutsNestedInput
  }

  export type ProfileWorkoutTouchedUncheckedUpdateWithoutWorkoutInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfileWorkoutTouchedUncheckedUpdateManyWithoutWorkoutInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SetCreateManyExerciseInput = {
    id?: number
    weight: number
    reps: number
  }

  export type SetUpdateWithoutExerciseInput = {
    weight?: FloatFieldUpdateOperationsInput | number
    reps?: IntFieldUpdateOperationsInput | number
  }

  export type SetUncheckedUpdateWithoutExerciseInput = {
    id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    reps?: IntFieldUpdateOperationsInput | number
  }

  export type SetUncheckedUpdateManyWithoutExerciseInput = {
    id?: IntFieldUpdateOperationsInput | number
    weight?: FloatFieldUpdateOperationsInput | number
    reps?: IntFieldUpdateOperationsInput | number
  }

  export type FoodCreateManyMealInput = {
    id?: number
    name: string
    calories: number
    carbs: number
    fats: number
    proteins: number
    grams: number
  }

  export type ProfileMealLikesCreateManyMealInput = {
    id?: number
    profileId?: number | null
  }

  export type ProfileMealTouchedCreateManyMealInput = {
    id?: number
    profileId?: number | null
  }

  export type FoodUpdateWithoutMealInput = {
    name?: StringFieldUpdateOperationsInput | string
    calories?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    proteins?: FloatFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
  }

  export type FoodUncheckedUpdateWithoutMealInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    calories?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    proteins?: FloatFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
  }

  export type FoodUncheckedUpdateManyWithoutMealInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    calories?: FloatFieldUpdateOperationsInput | number
    carbs?: FloatFieldUpdateOperationsInput | number
    fats?: FloatFieldUpdateOperationsInput | number
    proteins?: FloatFieldUpdateOperationsInput | number
    grams?: FloatFieldUpdateOperationsInput | number
  }

  export type ProfileMealLikesUpdateWithoutMealInput = {
    profile?: ProfileUpdateOneWithoutLikedMealsNestedInput
  }

  export type ProfileMealLikesUncheckedUpdateWithoutMealInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfileMealLikesUncheckedUpdateManyWithoutMealInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfileMealTouchedUpdateWithoutMealInput = {
    profile?: ProfileUpdateOneWithoutTouchMealsNestedInput
  }

  export type ProfileMealTouchedUncheckedUpdateWithoutMealInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProfileMealTouchedUncheckedUpdateManyWithoutMealInput = {
    id?: IntFieldUpdateOperationsInput | number
    profileId?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ProfileCountOutputTypeDefaultArgs instead
     */
    export type ProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkoutCountOutputTypeDefaultArgs instead
     */
    export type WorkoutCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkoutCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExerciseCountOutputTypeDefaultArgs instead
     */
    export type ExerciseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExerciseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MealCountOutputTypeDefaultArgs instead
     */
    export type MealCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MealCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileDefaultArgs instead
     */
    export type ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkoutDefaultArgs instead
     */
    export type WorkoutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkoutDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExerciseDefaultArgs instead
     */
    export type ExerciseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExerciseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SetDefaultArgs instead
     */
    export type SetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MealDefaultArgs instead
     */
    export type MealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MealDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FoodDefaultArgs instead
     */
    export type FoodArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FoodDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileWorkoutLikesDefaultArgs instead
     */
    export type ProfileWorkoutLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileWorkoutLikesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileWorkoutTouchedDefaultArgs instead
     */
    export type ProfileWorkoutTouchedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileWorkoutTouchedDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileMealLikesDefaultArgs instead
     */
    export type ProfileMealLikesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileMealLikesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileMealTouchedDefaultArgs instead
     */
    export type ProfileMealTouchedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileMealTouchedDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}